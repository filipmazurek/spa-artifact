## Adding Cache Variability

Note: these changes were all done on the v22.1.0.0 tag of gem5.

Based on [add citation here], can observe pretty good program variability by adding a uniform random distribution of [0, 4] cycles to L2 cache accesses.


### First Build

If building on a regular Linux system, use the script `docs/running-parsec-gem5/build-gem5.sh`. For subsequent builds:

```bash
python 'which scons' build/X86/gem5.fast -j 4 PROTOCOL="MOESI_hammer"
```

If building on a Slurm system:

```bash
cd docs/running-parsec-gem5
conda env create -f slurm-gem5-env.yml
conda activate gem5_env
sbatch build-gem5-slurm.sh
```

For every subsequent build:
```bash
cd docs/running-parsec-gem5
sbatch build-gem5-slurm.sh
```

### Classic Caches

Fairly straightforward. All changes done in `gem5/srs/mem/cache/cache.cc`
create a random number generator as well as a global int (not necessary, just lazy)

`gem5/srs/mem/cache/cache.cc`
```C
#include <random>
std::default_random_engine generator(std::random_device{}());
std::uniform_int_distribution<int> distribution(0,4);
int randomDelay;
```

Then add the delays in the `serviceMSHRTargets` function. Added in 3 separate places.

```C
completion_time += clockEdge(responseLatency) + randomDelay + pkt->payloadDelay;
```

Every time adding to the `completion_time` variable
In order to check if the time is added to only the L2 cache / other long latency caches and not to quick messages, add this check.

```C
// Adding own random number generated delay in the case of a miss.
randomDelay = 0;
// Only actually add the random delay if it is the L2 cache.
// Hacked here as only a check of the latency of the current packet
if (dataLatency > 15) {
   randomDelay = distribution(generator);
   DPRINTF(Cache, "Random delay added to the cache: %d\n", randomDelay);
}
```

At this point, compile the gem5 executable, and it should work fine for adding random delays in the L2 cache.


### Ruby Caches

The Ruby memory system is a little tricker. Basically, gem5 is an event-driven simulator, where all things happen as individual events - have a name, a submission time, and a due time. They will fire and immediately happen at the due time.

But gem5 was originally separate from the whole GEMS project. Where Ruby was a network simulator

Because of this, the CPU, DRAM, etc. of gem5 treats Ruby as a sort of black box.

Ruby protocols (such as MESI_Two_Level, etc.) are defined through SLICC files. These files define the cache coherence protocols. These files are then compiled to .cc files, which are then compiled to be run.

There are also Ruby memory code files which are the common backbone of this sort of memory system code

I created a hacky workaround in order to easily change the functionality - directly change the `L2 cache controller`. This is a file automatically generated by the SLICC compiler. Steps to change it:

Compile gem5 normally. This will ensure that all necessary SLICC compiled .cc files are created and in the `gem5/build/` directory.

This is a slicc compiler specification.

Comment out line 1223 (or in the area. All that matters is that these are the `.cc` files, as well as all the files which are `.hh.`). These lines generate the built `.cc` and `.hh` files.

`gem5/src/mem/slicc/symbols/StateMachine.py`
```Python
# code.write(path, "%s.cc" % c_ident)
# code.write(path, "%s.hh" % c_ident)
```

This is what actually creates the slicc-created files. This means that the files will no longer be generated when compiling gem5 again

Go to `gem5/build/X86/mem/ruby/protocol/L2Cache_Controller.cc`

Run `chmod` so that the file is editable

Add code to the top of the file:

NOTE: the global variable cache will only be for custom adding the seed. No need for it now, but consider adding here regardless.

```C
#include <random>
#include "global_variable_cache/global_variable_cache.hh"
std::default_random_engine generator_L2(std::random_device{}());
std::uniform_int_distribution<int> distribution_L2(0,4);
int total_ruby_random_delay_L2;
```

Go to `gem5/build/X86/mem/ruby/protocol/L2Cache_Controller.hh`
Run `chmod` so that the file is editable
Add code to the top of the file:

```C
#include "global_variable_cache/global_variable_cache.hh"
extern int total_ruby_random_delay_L2;
```

Modify the function `L2Cache_Controller::a_issueFetchToMemory` so that random delays are inserted

NOTE: Notice how the caches already have a randomization part to the code - this inserts a more randomized delay every time any message is passed (unless it is turned off for that message). There are some randomization settings (such as the ones turned on in the configuration file `gem5/configs/example/ruby_random_test.py`). This configuration file is used to insert a lot of random delays for the coherence protocol. Essentially this will stress test the coherence protocol. There might be some value in using it later on.
For now, simply insert the same code as in classic caches in order to insert the random delays into the message passing protocol - but only for the L2 cache controller.

```C
   int randomDelay_L2 = distribution_L2(generator_L2);
   total_ruby_random_delay_L2 += randomDelay_L2;
   DPRINTF(RubyGenerated, "adding %d cycle latency to L2 a_issueFetchToMemory\n", randomDelay_L2);

   ...

   ((*m_DirRequestFromL2Cache_ptr)).enqueue(out_msg, clockEdge(),
     cyclesToTicks(Cycles(m_l2_request_latency + Cycles(randomDelay_L2))));
```

This is bad practice, directly modifying the generated .cc files in the `build` folder. But it is convenient and works as it should. Could create some macro to generate this code in the cache controller and further tune the random number generation.

In order to keep track of the total delay, create a global variable in the L2Cache_Controller to keep track of it. Then during the exit, write out the total latency
This can be done in `gem5/src/sim/pseudo_inst.cc`

at the top of the file, include the global variable location

```C
#include "mem/ruby/protocol/L2Cache_Controller.hh"
```

In the m5exit command:
```C
printf("Total ruby extra latency: %d\n", total_ruby_random_delay_L2);
```

Because this code has the code for the `global_variable_cache`, that needs to be added as well.

```bash
cd gem5/src
mkdir global_variable_cache
```

Into that folder, paste the following four files, located in `docs/running-parsec-gem5/global_variable_cache/`:

```
global_variable_cache.cc
global_variable_cache.hh
GlobalVariableCache.py
SConscript
```

From here, build gem5 as normal.
