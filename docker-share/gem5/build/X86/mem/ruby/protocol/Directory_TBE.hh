/**
 * DO NOT EDIT THIS FILE!
 * File automatically generated by
 *   /shared/gem5/src/mem/slicc/symbols/Type.py:443
 */

#ifndef __Directory_TBE_HH__
#define __Directory_TBE_HH__

#include <iostream>

#include "mem/ruby/slicc_interface/RubySlicc_Util.hh"

#include "mem/ruby/protocol/Directory_State.hh"
#include "mem/ruby/protocol/CoherenceResponseType.hh"
#include "mem/ruby/protocol/DataBlock.hh"
#include "mem/ruby/protocol/DataBlock.hh"
#include "mem/ruby/protocol/MachineID.hh"
#include "mem/ruby/protocol/NetDest.hh"
namespace gem5
{

namespace ruby
{

class Directory_TBE
{
  public:
    Directory_TBE
()
		{
        // m_PhysicalAddress has no default
        m_TBEState = Directory_State_E;
         // default value of Directory_State
        m_ResponseType = CoherenceResponseType_NUM;
         // default value of CoherenceResponseType
        m_Acks = 0; // default for this field
        m_SilentAcks = 0; // default for this field
        // m_DmaDataBlk has no default
        // m_DataBlk has no default
        m_Len = 0;
         // default value of int
        // m_DmaRequestor has no default
        // m_GetSRequestors has no default
        m_NumPendingMsgs = 0;
         // default value of int
        m_CacheDirty = false; // default for this field
        m_Sharers = false; // default for this field
        m_Owned = false; // default for this field
    }
    Directory_TBE(const Directory_TBE&) = default;
    Directory_TBE
    &operator=(const Directory_TBE&) = default;
    Directory_TBE(const Addr& local_PhysicalAddress, const Directory_State& local_TBEState, const CoherenceResponseType& local_ResponseType, const int& local_Acks, const int& local_SilentAcks, const DataBlock& local_DmaDataBlk, const DataBlock& local_DataBlk, const int& local_Len, const MachineID& local_DmaRequestor, const NetDest& local_GetSRequestors, const int& local_NumPendingMsgs, const bool& local_CacheDirty, const bool& local_Sharers, const bool& local_Owned)
    {
        m_PhysicalAddress = local_PhysicalAddress;
        m_TBEState = local_TBEState;
        m_ResponseType = local_ResponseType;
        m_Acks = local_Acks;
        m_SilentAcks = local_SilentAcks;
        m_DmaDataBlk = local_DmaDataBlk;
        m_DataBlk = local_DataBlk;
        m_Len = local_Len;
        m_DmaRequestor = local_DmaRequestor;
        m_GetSRequestors = local_GetSRequestors;
        m_NumPendingMsgs = local_NumPendingMsgs;
        m_CacheDirty = local_CacheDirty;
        m_Sharers = local_Sharers;
        m_Owned = local_Owned;
    }
    Directory_TBE*
    clone() const
    {
         return new Directory_TBE(*this);
    }
    // Const accessors methods for each field
    /** \brief Const accessor method for PhysicalAddress field.
     *  \return PhysicalAddress field
     */
    const Addr&
    getPhysicalAddress() const
    {
        return m_PhysicalAddress;
    }
    /** \brief Const accessor method for TBEState field.
     *  \return TBEState field
     */
    const Directory_State&
    getTBEState() const
    {
        return m_TBEState;
    }
    /** \brief Const accessor method for ResponseType field.
     *  \return ResponseType field
     */
    const CoherenceResponseType&
    getResponseType() const
    {
        return m_ResponseType;
    }
    /** \brief Const accessor method for Acks field.
     *  \return Acks field
     */
    const int&
    getAcks() const
    {
        return m_Acks;
    }
    /** \brief Const accessor method for SilentAcks field.
     *  \return SilentAcks field
     */
    const int&
    getSilentAcks() const
    {
        return m_SilentAcks;
    }
    /** \brief Const accessor method for DmaDataBlk field.
     *  \return DmaDataBlk field
     */
    const DataBlock&
    getDmaDataBlk() const
    {
        return m_DmaDataBlk;
    }
    /** \brief Const accessor method for DataBlk field.
     *  \return DataBlk field
     */
    const DataBlock&
    getDataBlk() const
    {
        return m_DataBlk;
    }
    /** \brief Const accessor method for Len field.
     *  \return Len field
     */
    const int&
    getLen() const
    {
        return m_Len;
    }
    /** \brief Const accessor method for DmaRequestor field.
     *  \return DmaRequestor field
     */
    const MachineID&
    getDmaRequestor() const
    {
        return m_DmaRequestor;
    }
    /** \brief Const accessor method for GetSRequestors field.
     *  \return GetSRequestors field
     */
    const NetDest&
    getGetSRequestors() const
    {
        return m_GetSRequestors;
    }
    /** \brief Const accessor method for NumPendingMsgs field.
     *  \return NumPendingMsgs field
     */
    const int&
    getNumPendingMsgs() const
    {
        return m_NumPendingMsgs;
    }
    /** \brief Const accessor method for CacheDirty field.
     *  \return CacheDirty field
     */
    const bool&
    getCacheDirty() const
    {
        return m_CacheDirty;
    }
    /** \brief Const accessor method for Sharers field.
     *  \return Sharers field
     */
    const bool&
    getSharers() const
    {
        return m_Sharers;
    }
    /** \brief Const accessor method for Owned field.
     *  \return Owned field
     */
    const bool&
    getOwned() const
    {
        return m_Owned;
    }
    // Non const Accessors methods for each field
    /** \brief Non-const accessor method for PhysicalAddress field.
     *  \return PhysicalAddress field
     */
    Addr&
    getPhysicalAddress()
    {
        return m_PhysicalAddress;
    }
    /** \brief Non-const accessor method for TBEState field.
     *  \return TBEState field
     */
    Directory_State&
    getTBEState()
    {
        return m_TBEState;
    }
    /** \brief Non-const accessor method for ResponseType field.
     *  \return ResponseType field
     */
    CoherenceResponseType&
    getResponseType()
    {
        return m_ResponseType;
    }
    /** \brief Non-const accessor method for Acks field.
     *  \return Acks field
     */
    int&
    getAcks()
    {
        return m_Acks;
    }
    /** \brief Non-const accessor method for SilentAcks field.
     *  \return SilentAcks field
     */
    int&
    getSilentAcks()
    {
        return m_SilentAcks;
    }
    /** \brief Non-const accessor method for DmaDataBlk field.
     *  \return DmaDataBlk field
     */
    DataBlock&
    getDmaDataBlk()
    {
        return m_DmaDataBlk;
    }
    /** \brief Non-const accessor method for DataBlk field.
     *  \return DataBlk field
     */
    DataBlock&
    getDataBlk()
    {
        return m_DataBlk;
    }
    /** \brief Non-const accessor method for Len field.
     *  \return Len field
     */
    int&
    getLen()
    {
        return m_Len;
    }
    /** \brief Non-const accessor method for DmaRequestor field.
     *  \return DmaRequestor field
     */
    MachineID&
    getDmaRequestor()
    {
        return m_DmaRequestor;
    }
    /** \brief Non-const accessor method for GetSRequestors field.
     *  \return GetSRequestors field
     */
    NetDest&
    getGetSRequestors()
    {
        return m_GetSRequestors;
    }
    /** \brief Non-const accessor method for NumPendingMsgs field.
     *  \return NumPendingMsgs field
     */
    int&
    getNumPendingMsgs()
    {
        return m_NumPendingMsgs;
    }
    /** \brief Non-const accessor method for CacheDirty field.
     *  \return CacheDirty field
     */
    bool&
    getCacheDirty()
    {
        return m_CacheDirty;
    }
    /** \brief Non-const accessor method for Sharers field.
     *  \return Sharers field
     */
    bool&
    getSharers()
    {
        return m_Sharers;
    }
    /** \brief Non-const accessor method for Owned field.
     *  \return Owned field
     */
    bool&
    getOwned()
    {
        return m_Owned;
    }
    // Mutator methods for each field
    /** \brief Mutator method for PhysicalAddress field */
    void
    setPhysicalAddress(const Addr& local_PhysicalAddress)
    {
        m_PhysicalAddress = local_PhysicalAddress;
    }
    /** \brief Mutator method for TBEState field */
    void
    setTBEState(const Directory_State& local_TBEState)
    {
        m_TBEState = local_TBEState;
    }
    /** \brief Mutator method for ResponseType field */
    void
    setResponseType(const CoherenceResponseType& local_ResponseType)
    {
        m_ResponseType = local_ResponseType;
    }
    /** \brief Mutator method for Acks field */
    void
    setAcks(const int& local_Acks)
    {
        m_Acks = local_Acks;
    }
    /** \brief Mutator method for SilentAcks field */
    void
    setSilentAcks(const int& local_SilentAcks)
    {
        m_SilentAcks = local_SilentAcks;
    }
    /** \brief Mutator method for DmaDataBlk field */
    void
    setDmaDataBlk(const DataBlock& local_DmaDataBlk)
    {
        m_DmaDataBlk = local_DmaDataBlk;
    }
    /** \brief Mutator method for DataBlk field */
    void
    setDataBlk(const DataBlock& local_DataBlk)
    {
        m_DataBlk = local_DataBlk;
    }
    /** \brief Mutator method for Len field */
    void
    setLen(const int& local_Len)
    {
        m_Len = local_Len;
    }
    /** \brief Mutator method for DmaRequestor field */
    void
    setDmaRequestor(const MachineID& local_DmaRequestor)
    {
        m_DmaRequestor = local_DmaRequestor;
    }
    /** \brief Mutator method for GetSRequestors field */
    void
    setGetSRequestors(const NetDest& local_GetSRequestors)
    {
        m_GetSRequestors = local_GetSRequestors;
    }
    /** \brief Mutator method for NumPendingMsgs field */
    void
    setNumPendingMsgs(const int& local_NumPendingMsgs)
    {
        m_NumPendingMsgs = local_NumPendingMsgs;
    }
    /** \brief Mutator method for CacheDirty field */
    void
    setCacheDirty(const bool& local_CacheDirty)
    {
        m_CacheDirty = local_CacheDirty;
    }
    /** \brief Mutator method for Sharers field */
    void
    setSharers(const bool& local_Sharers)
    {
        m_Sharers = local_Sharers;
    }
    /** \brief Mutator method for Owned field */
    void
    setOwned(const bool& local_Owned)
    {
        m_Owned = local_Owned;
    }
    void print(std::ostream& out) const;
  //private:
    /** physical address */
    Addr m_PhysicalAddress;
    /** Transient State */
    Directory_State m_TBEState;
    /** The type for the subsequent response message */
    CoherenceResponseType m_ResponseType;
    /** The number of acks that the waiting response represents */
    int m_Acks;
    /** The number of silent acks associated with this transaction */
    int m_SilentAcks;
    /** DMA Data to be written.  Partial blocks need to merged with system memory */
    DataBlock m_DmaDataBlk;
    /** The current view of system memory */
    DataBlock m_DataBlk;
    /** ... */
    int m_Len;
    /** DMA requestor */
    MachineID m_DmaRequestor;
    /** GETS merged requestors */
    NetDest m_GetSRequestors;
    /** Number of pending acks/messages */
    int m_NumPendingMsgs;
    /** Indicates whether a cache has responded with dirty data */
    bool m_CacheDirty;
    /** Indicates whether a cache has indicated it is currently a sharer */
    bool m_Sharers;
    /** Indicates whether a cache has indicated it is currently a sharer */
    bool m_Owned;
};
inline ::std::ostream&
operator<<(::std::ostream& out, const Directory_TBE& obj)
{
    obj.print(out);
    out << ::std::flush;
    return out;
}

} // namespace ruby
} // namespace gem5

#endif // __Directory_TBE_HH__
