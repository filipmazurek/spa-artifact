/**
 * DO NOT EDIT THIS FILE!
 * File automatically generated by
 *   /shared/gem5/src/mem/slicc/symbols/Type.py:935
 */

#include <cassert>
#include <iostream>
#include <string>

#include "base/logging.hh"
#include "mem/ruby/protocol/L1Cache_Event.hh"

namespace gem5
{

namespace ruby
{

// Code for output operator
::std::ostream&
operator<<(::std::ostream& out, const L1Cache_Event& obj)
{
    out << L1Cache_Event_to_string(obj);
    out << ::std::flush;
    return out;
}

// Code to convert state to a string
std::string
L1Cache_Event_to_string(const L1Cache_Event& obj)
{
    switch(obj) {
      case L1Cache_Event_Load:
        return "Load";
      case L1Cache_Event_Ifetch:
        return "Ifetch";
      case L1Cache_Event_Store:
        return "Store";
      case L1Cache_Event_L2_Replacement:
        return "L2_Replacement";
      case L1Cache_Event_L1_to_L2:
        return "L1_to_L2";
      case L1Cache_Event_Trigger_L2_to_L1D:
        return "Trigger_L2_to_L1D";
      case L1Cache_Event_Trigger_L2_to_L1I:
        return "Trigger_L2_to_L1I";
      case L1Cache_Event_Complete_L2_to_L1:
        return "Complete_L2_to_L1";
      case L1Cache_Event_Other_GETX:
        return "Other_GETX";
      case L1Cache_Event_Other_GETS:
        return "Other_GETS";
      case L1Cache_Event_Merged_GETS:
        return "Merged_GETS";
      case L1Cache_Event_Other_GETS_No_Mig:
        return "Other_GETS_No_Mig";
      case L1Cache_Event_NC_DMA_GETS:
        return "NC_DMA_GETS";
      case L1Cache_Event_Invalidate:
        return "Invalidate";
      case L1Cache_Event_Ack:
        return "Ack";
      case L1Cache_Event_Shared_Ack:
        return "Shared_Ack";
      case L1Cache_Event_Data:
        return "Data";
      case L1Cache_Event_Shared_Data:
        return "Shared_Data";
      case L1Cache_Event_Exclusive_Data:
        return "Exclusive_Data";
      case L1Cache_Event_Writeback_Ack:
        return "Writeback_Ack";
      case L1Cache_Event_Writeback_Nack:
        return "Writeback_Nack";
      case L1Cache_Event_All_acks:
        return "All_acks";
      case L1Cache_Event_All_acks_no_sharers:
        return "All_acks_no_sharers";
      case L1Cache_Event_Flush_line:
        return "Flush_line";
      case L1Cache_Event_Block_Ack:
        return "Block_Ack";
      default:
        panic("Invalid range for type L1Cache_Event");
    }
    // Appease the compiler since this function has a return value
    return "";
}

// Code to convert from a string to the enumeration
L1Cache_Event
string_to_L1Cache_Event(const std::string& str)
{
    if (str == "Load") {
        return L1Cache_Event_Load;
    } else if (str == "Ifetch") {
        return L1Cache_Event_Ifetch;
    } else if (str == "Store") {
        return L1Cache_Event_Store;
    } else if (str == "L2_Replacement") {
        return L1Cache_Event_L2_Replacement;
    } else if (str == "L1_to_L2") {
        return L1Cache_Event_L1_to_L2;
    } else if (str == "Trigger_L2_to_L1D") {
        return L1Cache_Event_Trigger_L2_to_L1D;
    } else if (str == "Trigger_L2_to_L1I") {
        return L1Cache_Event_Trigger_L2_to_L1I;
    } else if (str == "Complete_L2_to_L1") {
        return L1Cache_Event_Complete_L2_to_L1;
    } else if (str == "Other_GETX") {
        return L1Cache_Event_Other_GETX;
    } else if (str == "Other_GETS") {
        return L1Cache_Event_Other_GETS;
    } else if (str == "Merged_GETS") {
        return L1Cache_Event_Merged_GETS;
    } else if (str == "Other_GETS_No_Mig") {
        return L1Cache_Event_Other_GETS_No_Mig;
    } else if (str == "NC_DMA_GETS") {
        return L1Cache_Event_NC_DMA_GETS;
    } else if (str == "Invalidate") {
        return L1Cache_Event_Invalidate;
    } else if (str == "Ack") {
        return L1Cache_Event_Ack;
    } else if (str == "Shared_Ack") {
        return L1Cache_Event_Shared_Ack;
    } else if (str == "Data") {
        return L1Cache_Event_Data;
    } else if (str == "Shared_Data") {
        return L1Cache_Event_Shared_Data;
    } else if (str == "Exclusive_Data") {
        return L1Cache_Event_Exclusive_Data;
    } else if (str == "Writeback_Ack") {
        return L1Cache_Event_Writeback_Ack;
    } else if (str == "Writeback_Nack") {
        return L1Cache_Event_Writeback_Nack;
    } else if (str == "All_acks") {
        return L1Cache_Event_All_acks;
    } else if (str == "All_acks_no_sharers") {
        return L1Cache_Event_All_acks_no_sharers;
    } else if (str == "Flush_line") {
        return L1Cache_Event_Flush_line;
    } else if (str == "Block_Ack") {
        return L1Cache_Event_Block_Ack;
    } else {
        panic("Invalid string conversion for %s, type L1Cache_Event", str);
    }
}

// Code to increment an enumeration type
L1Cache_Event&
operator++(L1Cache_Event& e)
{
    assert(e < L1Cache_Event_NUM);
    return e = L1Cache_Event(e+1);
}
} // namespace ruby
} // namespace gem5
