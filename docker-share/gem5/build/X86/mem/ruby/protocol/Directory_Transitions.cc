/**
 * DO NOT EDIT THIS FILE!
 * File automatically generated by
 *   /shared/gem5/src/mem/slicc/symbols/StateMachine.py:1814
 */

// Directory: AMD Hammer-like protocol

#include <cassert>

#include "base/logging.hh"
#include "base/trace.hh"
#include "debug/ProtocolTrace.hh"
#include "debug/RubyGenerated.hh"
#include "mem/ruby/protocol/Directory_Controller.hh"
#include "mem/ruby/protocol/Directory_Event.hh"
#include "mem/ruby/protocol/Directory_State.hh"
#include "mem/ruby/protocol/Types.hh"
#include "mem/ruby/system/RubySystem.hh"

#define HASH_FUN(state, event)  ((int(state)*Directory_Event_NUM)+int(event))

#define GET_TRANSITION_COMMENT() (Directory_transitionComment.str())
#define CLEAR_TRANSITION_COMMENT() (Directory_transitionComment.str(""))

namespace gem5
{

namespace ruby
{

TransitionResult
Directory_Controller::doTransition(Directory_Event event,
                                  Directory_PfEntry* m_cache_entry_ptr,
                                  Directory_TBE* m_tbe_ptr,
                                  Addr addr)
{
    Directory_State state = getState(m_tbe_ptr, m_cache_entry_ptr, addr);
    Directory_State next_state = state;

    DPRINTF(RubyGenerated, "%s, Time: %lld, state: %s, event: %s, addr: %#x\n",
            *this, curCycle(), Directory_State_to_string(state),
            Directory_Event_to_string(event), addr);

    TransitionResult result =
    doTransitionWorker(event, state, next_state, m_tbe_ptr, m_cache_entry_ptr, addr);

    if (result == TransitionResult_Valid) {
        DPRINTF(RubyGenerated, "next_state: %s\n",
                Directory_State_to_string(next_state));
        countTransition(state, event);

        DPRINTFR(ProtocolTrace, "%15d %3s %10s%20s %6s>%-6s %#x %s\n",
                 curTick(), m_version, "Directory",
                 Directory_Event_to_string(event),
                 Directory_State_to_string(state),
                 Directory_State_to_string(next_state),
                 printAddress(addr), GET_TRANSITION_COMMENT());

        CLEAR_TRANSITION_COMMENT();
    setState(m_tbe_ptr, m_cache_entry_ptr, addr, next_state);
    setAccessPermission(m_cache_entry_ptr, addr, next_state);
    } else if (result == TransitionResult_ResourceStall) {
        DPRINTFR(ProtocolTrace, "%15s %3s %10s%20s %6s>%-6s %#x %s\n",
                 curTick(), m_version, "Directory",
                 Directory_Event_to_string(event),
                 Directory_State_to_string(state),
                 Directory_State_to_string(next_state),
                 printAddress(addr), "Resource Stall");
    } else if (result == TransitionResult_ProtocolStall) {
        DPRINTF(RubyGenerated, "stalling\n");
        DPRINTFR(ProtocolTrace, "%15s %3s %10s%20s %6s>%-6s %#x %s\n",
                 curTick(), m_version, "Directory",
                 Directory_Event_to_string(event),
                 Directory_State_to_string(state),
                 Directory_State_to_string(next_state),
                 printAddress(addr), "Protocol Stall");
    }

    return result;
}

TransitionResult
Directory_Controller::doTransitionWorker(Directory_Event event,
                                        Directory_State state,
                                        Directory_State& next_state,
                                        Directory_TBE*& m_tbe_ptr,
                                        Directory_PfEntry*& m_cache_entry_ptr,
                                        Addr addr)
{
    m_curTransitionEvent = event;
    m_curTransitionNextState = next_state;
    switch(HASH_FUN(state, event)) {
  case HASH_FUN(Directory_State_E, Directory_Event_GETX):
  case HASH_FUN(Directory_State_E, Directory_Event_GETS):
    next_state = Directory_State_NO_B_W; m_curTransitionNextState = next_state;
    if (!(*m_TBEs_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(2, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_requestToMemory_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    pfa_probeFilterAllocate(m_tbe_ptr, m_cache_entry_ptr, addr);
    v_allocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    rx_recordExclusiveInTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    saa_setAcksToAllIfPF(m_tbe_ptr, m_cache_entry_ptr, addr);
    qf_queueMemoryFetchRequest(m_tbe_ptr, m_cache_entry_ptr, addr);
    fn_forwardRequestIfNecessary(m_tbe_ptr, m_cache_entry_ptr, addr);
    i_popIncomingRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_E, Directory_Event_GETF):
    next_state = Directory_State_NO_F_W; m_curTransitionNextState = next_state;
    if (!(*m_TBEs_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(2, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_requestToMemory_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    pfa_probeFilterAllocate(m_tbe_ptr, m_cache_entry_ptr, addr);
    v_allocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    rx_recordExclusiveInTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    saa_setAcksToAllIfPF(m_tbe_ptr, m_cache_entry_ptr, addr);
    qf_queueMemoryFetchRequest(m_tbe_ptr, m_cache_entry_ptr, addr);
    fn_forwardRequestIfNecessary(m_tbe_ptr, m_cache_entry_ptr, addr);
    i_popIncomingRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_E, Directory_Event_DMA_READ):
    next_state = Directory_State_NO_DR_B_W; m_curTransitionNextState = next_state;
    if (!(*m_TBEs_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_requestToMemory_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    vd_allocateDmaRequestInTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    qd_queueMemoryRequestFromDmaRead(m_tbe_ptr, m_cache_entry_ptr, addr);
    spa_setPendingAcksToZeroIfPF(m_tbe_ptr, m_cache_entry_ptr, addr);
    f_forwardReadFromDma(m_tbe_ptr, m_cache_entry_ptr, addr);
    p_popDmaRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_E, Directory_Event_DMA_WRITE):
    next_state = Directory_State_NO_DW_B_W; m_curTransitionNextState = next_state;
    if (!(*m_TBEs_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_triggerQueue_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    vd_allocateDmaRequestInTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    spa_setPendingAcksToZeroIfPF(m_tbe_ptr, m_cache_entry_ptr, addr);
    sc_signalCompletionIfPF(m_tbe_ptr, m_cache_entry_ptr, addr);
    f_forwardWriteFromDma(m_tbe_ptr, m_cache_entry_ptr, addr);
    p_popDmaRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_O, Directory_Event_GETX):
    next_state = Directory_State_NO_B_W; m_curTransitionNextState = next_state;
    if (!(*m_TBEs_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(2, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_requestToMemory_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_responseFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    r_setMRU(m_tbe_ptr, m_cache_entry_ptr, addr);
    v_allocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    r_recordDataInTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    sa_setAcksToOne(m_tbe_ptr, m_cache_entry_ptr, addr);
    qf_queueMemoryFetchRequest(m_tbe_ptr, m_cache_entry_ptr, addr);
    fb_forwardRequestBcast(m_tbe_ptr, m_cache_entry_ptr, addr);
    cs_clearSharers(m_tbe_ptr, m_cache_entry_ptr, addr);
    i_popIncomingRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_O, Directory_Event_GETF):
    next_state = Directory_State_NO_F_W; m_curTransitionNextState = next_state;
    if (!(*m_TBEs_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(2, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_requestToMemory_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_responseFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    r_setMRU(m_tbe_ptr, m_cache_entry_ptr, addr);
    v_allocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    r_recordDataInTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    sa_setAcksToOne(m_tbe_ptr, m_cache_entry_ptr, addr);
    qf_queueMemoryFetchRequest(m_tbe_ptr, m_cache_entry_ptr, addr);
    fb_forwardRequestBcast(m_tbe_ptr, m_cache_entry_ptr, addr);
    cs_clearSharers(m_tbe_ptr, m_cache_entry_ptr, addr);
    i_popIncomingRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_O, Directory_Event_GETS):
    next_state = Directory_State_O_B_W; m_curTransitionNextState = next_state;
    if (!(*m_TBEs_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(2, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_requestToMemory_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    r_setMRU(m_tbe_ptr, m_cache_entry_ptr, addr);
    v_allocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    r_recordDataInTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    saa_setAcksToAllIfPF(m_tbe_ptr, m_cache_entry_ptr, addr);
    qf_queueMemoryFetchRequest(m_tbe_ptr, m_cache_entry_ptr, addr);
    fn_forwardRequestIfNecessary(m_tbe_ptr, m_cache_entry_ptr, addr);
    i_popIncomingRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_O, Directory_Event_DMA_READ):
    next_state = Directory_State_O_DR_B_W; m_curTransitionNextState = next_state;
    if (!(*m_TBEs_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_requestToMemory_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    vd_allocateDmaRequestInTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    spa_setPendingAcksToZeroIfPF(m_tbe_ptr, m_cache_entry_ptr, addr);
    qd_queueMemoryRequestFromDmaRead(m_tbe_ptr, m_cache_entry_ptr, addr);
    f_forwardReadFromDma(m_tbe_ptr, m_cache_entry_ptr, addr);
    p_popDmaRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_O, Directory_Event_Pf_Replacement):
    next_state = Directory_State_O_R; m_curTransitionNextState = next_state;
    if (!(*m_TBEs_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(2, clockEdge()))
        return TransitionResult_ResourceStall;
    v_allocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    pa_setPendingMsgsToAll(m_tbe_ptr, m_cache_entry_ptr, addr);
    ia_invalidateAllRequest(m_tbe_ptr, m_cache_entry_ptr, addr);
    pfd_probeFilterDeallocate(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_S, Directory_Event_Pf_Replacement):
    next_state = Directory_State_S_R; m_curTransitionNextState = next_state;
    if (!(*m_TBEs_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(2, clockEdge()))
        return TransitionResult_ResourceStall;
    v_allocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    pa_setPendingMsgsToAll(m_tbe_ptr, m_cache_entry_ptr, addr);
    ia_invalidateAllRequest(m_tbe_ptr, m_cache_entry_ptr, addr);
    pfd_probeFilterDeallocate(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO, Directory_Event_Pf_Replacement):
    next_state = Directory_State_NO_R; m_curTransitionNextState = next_state;
    if (!(*m_TBEs_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    v_allocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    po_setPendingMsgsToOne(m_tbe_ptr, m_cache_entry_ptr, addr);
    io_invalidateOwnerRequest(m_tbe_ptr, m_cache_entry_ptr, addr);
    pfd_probeFilterDeallocate(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NX, Directory_Event_Pf_Replacement):
    next_state = Directory_State_NO_R; m_curTransitionNextState = next_state;
    if (!(*m_TBEs_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(2, clockEdge()))
        return TransitionResult_ResourceStall;
    v_allocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    pa_setPendingMsgsToAll(m_tbe_ptr, m_cache_entry_ptr, addr);
    ia_invalidateAllRequest(m_tbe_ptr, m_cache_entry_ptr, addr);
    pfd_probeFilterDeallocate(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_O, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_S, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_NO, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_NX, Directory_Event_DMA_WRITE):
    next_state = Directory_State_NO_DW_B_W; m_curTransitionNextState = next_state;
    if (!(*m_TBEs_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    vd_allocateDmaRequestInTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    f_forwardWriteFromDma(m_tbe_ptr, m_cache_entry_ptr, addr);
    p_popDmaRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NX, Directory_Event_GETX):
  case HASH_FUN(Directory_State_S, Directory_Event_GETX):
    next_state = Directory_State_NO_B; m_curTransitionNextState = next_state;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(2, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_responseFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    r_setMRU(m_tbe_ptr, m_cache_entry_ptr, addr);
    fb_forwardRequestBcast(m_tbe_ptr, m_cache_entry_ptr, addr);
    cs_clearSharers(m_tbe_ptr, m_cache_entry_ptr, addr);
    i_popIncomingRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NX, Directory_Event_GETF):
  case HASH_FUN(Directory_State_S, Directory_Event_GETF):
    next_state = Directory_State_NO_F; m_curTransitionNextState = next_state;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(2, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_responseFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    r_setMRU(m_tbe_ptr, m_cache_entry_ptr, addr);
    fb_forwardRequestBcast(m_tbe_ptr, m_cache_entry_ptr, addr);
    cs_clearSharers(m_tbe_ptr, m_cache_entry_ptr, addr);
    i_popIncomingRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO, Directory_Event_GETX):
    next_state = Directory_State_NO_B; m_curTransitionNextState = next_state;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(2, clockEdge()))
        return TransitionResult_ResourceStall;
    r_setMRU(m_tbe_ptr, m_cache_entry_ptr, addr);
    ano_assertNotOwner(m_tbe_ptr, m_cache_entry_ptr, addr);
    fc_forwardRequestConditionalOwner(m_tbe_ptr, m_cache_entry_ptr, addr);
    cs_clearSharers(m_tbe_ptr, m_cache_entry_ptr, addr);
    i_popIncomingRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO, Directory_Event_GETF):
    next_state = Directory_State_NO_F; m_curTransitionNextState = next_state;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(2, clockEdge()))
        return TransitionResult_ResourceStall;
    r_setMRU(m_tbe_ptr, m_cache_entry_ptr, addr);
    nofc_forwardRequestConditionalOwner(m_tbe_ptr, m_cache_entry_ptr, addr);
    cs_clearSharers(m_tbe_ptr, m_cache_entry_ptr, addr);
    oc_sendBlockAck(m_tbe_ptr, m_cache_entry_ptr, addr);
    i_popIncomingRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_S, Directory_Event_GETS):
    next_state = Directory_State_NO_B; m_curTransitionNextState = next_state;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(2, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_responseFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    r_setMRU(m_tbe_ptr, m_cache_entry_ptr, addr);
    ano_assertNotOwner(m_tbe_ptr, m_cache_entry_ptr, addr);
    fb_forwardRequestBcast(m_tbe_ptr, m_cache_entry_ptr, addr);
    i_popIncomingRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO, Directory_Event_GETS):
    next_state = Directory_State_NO_B; m_curTransitionNextState = next_state;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(2, clockEdge()))
        return TransitionResult_ResourceStall;
    r_setMRU(m_tbe_ptr, m_cache_entry_ptr, addr);
    ano_assertNotOwner(m_tbe_ptr, m_cache_entry_ptr, addr);
    ans_assertNotSharer(m_tbe_ptr, m_cache_entry_ptr, addr);
    fc_forwardRequestConditionalOwner(m_tbe_ptr, m_cache_entry_ptr, addr);
    i_popIncomingRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NX, Directory_Event_GETS):
    next_state = Directory_State_NO_B; m_curTransitionNextState = next_state;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(2, clockEdge()))
        return TransitionResult_ResourceStall;
    r_setMRU(m_tbe_ptr, m_cache_entry_ptr, addr);
    ano_assertNotOwner(m_tbe_ptr, m_cache_entry_ptr, addr);
    fc_forwardRequestConditionalOwner(m_tbe_ptr, m_cache_entry_ptr, addr);
    i_popIncomingRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO, Directory_Event_PUT):
  case HASH_FUN(Directory_State_NX, Directory_Event_PUT):
  case HASH_FUN(Directory_State_S, Directory_Event_PUT):
  case HASH_FUN(Directory_State_NO_F, Directory_Event_PUTF):
    next_state = Directory_State_WB; m_curTransitionNextState = next_state;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    a_sendWriteBackAck(m_tbe_ptr, m_cache_entry_ptr, addr);
    i_popIncomingRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_NX, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_S, Directory_Event_DMA_READ):
    next_state = Directory_State_NO_DR_B_D; m_curTransitionNextState = next_state;
    if (!(*m_TBEs_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    vd_allocateDmaRequestInTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    f_forwardReadFromDma(m_tbe_ptr, m_cache_entry_ptr, addr);
    p_popDmaRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_O, Directory_Event_PUT):
  case HASH_FUN(Directory_State_E, Directory_Event_PUT):
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    b_sendWriteBackNack(m_tbe_ptr, m_cache_entry_ptr, addr);
    i_popIncomingRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_B_X, Directory_Event_GETS):
  case HASH_FUN(Directory_State_NO_B_X, Directory_Event_GETX):
  case HASH_FUN(Directory_State_NO_B_X, Directory_Event_GETF):
  case HASH_FUN(Directory_State_NO_B_X, Directory_Event_PUT):
  case HASH_FUN(Directory_State_NO_B_X, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_O_B, Directory_Event_GETS):
  case HASH_FUN(Directory_State_O_B, Directory_Event_GETX):
  case HASH_FUN(Directory_State_O_B, Directory_Event_GETF):
  case HASH_FUN(Directory_State_O_B, Directory_Event_PUT):
  case HASH_FUN(Directory_State_O_B, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_NO_DR_B_W, Directory_Event_GETS):
  case HASH_FUN(Directory_State_NO_DR_B_W, Directory_Event_GETX):
  case HASH_FUN(Directory_State_NO_DR_B_W, Directory_Event_GETF):
  case HASH_FUN(Directory_State_NO_DR_B_W, Directory_Event_PUT):
  case HASH_FUN(Directory_State_NO_DR_B_W, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_NO_DW_B_W, Directory_Event_GETS):
  case HASH_FUN(Directory_State_NO_DW_B_W, Directory_Event_GETX):
  case HASH_FUN(Directory_State_NO_DW_B_W, Directory_Event_GETF):
  case HASH_FUN(Directory_State_NO_DW_B_W, Directory_Event_PUT):
  case HASH_FUN(Directory_State_NO_DW_B_W, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_NO_B_W, Directory_Event_GETS):
  case HASH_FUN(Directory_State_NO_B_W, Directory_Event_GETX):
  case HASH_FUN(Directory_State_NO_B_W, Directory_Event_GETF):
  case HASH_FUN(Directory_State_NO_B_W, Directory_Event_PUT):
  case HASH_FUN(Directory_State_NO_B_W, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_NO_DR_B_D, Directory_Event_GETS):
  case HASH_FUN(Directory_State_NO_DR_B_D, Directory_Event_GETX):
  case HASH_FUN(Directory_State_NO_DR_B_D, Directory_Event_GETF):
  case HASH_FUN(Directory_State_NO_DR_B_D, Directory_Event_PUT):
  case HASH_FUN(Directory_State_NO_DR_B_D, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_NO_DR_B, Directory_Event_GETS):
  case HASH_FUN(Directory_State_NO_DR_B, Directory_Event_GETX):
  case HASH_FUN(Directory_State_NO_DR_B, Directory_Event_GETF):
  case HASH_FUN(Directory_State_NO_DR_B, Directory_Event_PUT):
  case HASH_FUN(Directory_State_NO_DR_B, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_O_DR_B, Directory_Event_GETS):
  case HASH_FUN(Directory_State_O_DR_B, Directory_Event_GETX):
  case HASH_FUN(Directory_State_O_DR_B, Directory_Event_GETF):
  case HASH_FUN(Directory_State_O_DR_B, Directory_Event_PUT):
  case HASH_FUN(Directory_State_O_DR_B, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_O_B_W, Directory_Event_GETS):
  case HASH_FUN(Directory_State_O_B_W, Directory_Event_GETX):
  case HASH_FUN(Directory_State_O_B_W, Directory_Event_GETF):
  case HASH_FUN(Directory_State_O_B_W, Directory_Event_PUT):
  case HASH_FUN(Directory_State_O_B_W, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_O_DR_B_W, Directory_Event_GETS):
  case HASH_FUN(Directory_State_O_DR_B_W, Directory_Event_GETX):
  case HASH_FUN(Directory_State_O_DR_B_W, Directory_Event_GETF):
  case HASH_FUN(Directory_State_O_DR_B_W, Directory_Event_PUT):
  case HASH_FUN(Directory_State_O_DR_B_W, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_NO_DW_W, Directory_Event_GETS):
  case HASH_FUN(Directory_State_NO_DW_W, Directory_Event_GETX):
  case HASH_FUN(Directory_State_NO_DW_W, Directory_Event_GETF):
  case HASH_FUN(Directory_State_NO_DW_W, Directory_Event_PUT):
  case HASH_FUN(Directory_State_NO_DW_W, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_NO_B_S_W, Directory_Event_GETS):
  case HASH_FUN(Directory_State_NO_B_S_W, Directory_Event_GETX):
  case HASH_FUN(Directory_State_NO_B_S_W, Directory_Event_GETF):
  case HASH_FUN(Directory_State_NO_B_S_W, Directory_Event_PUT):
  case HASH_FUN(Directory_State_NO_B_S_W, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_NO_W, Directory_Event_GETS):
  case HASH_FUN(Directory_State_NO_W, Directory_Event_GETX):
  case HASH_FUN(Directory_State_NO_W, Directory_Event_GETF):
  case HASH_FUN(Directory_State_NO_W, Directory_Event_PUT):
  case HASH_FUN(Directory_State_NO_W, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_O_W, Directory_Event_GETS):
  case HASH_FUN(Directory_State_O_W, Directory_Event_GETX):
  case HASH_FUN(Directory_State_O_W, Directory_Event_GETF):
  case HASH_FUN(Directory_State_O_W, Directory_Event_PUT):
  case HASH_FUN(Directory_State_O_W, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_WB, Directory_Event_GETS):
  case HASH_FUN(Directory_State_WB, Directory_Event_GETX):
  case HASH_FUN(Directory_State_WB, Directory_Event_GETF):
  case HASH_FUN(Directory_State_WB, Directory_Event_PUT):
  case HASH_FUN(Directory_State_WB, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_WB_E_W, Directory_Event_GETS):
  case HASH_FUN(Directory_State_WB_E_W, Directory_Event_GETX):
  case HASH_FUN(Directory_State_WB_E_W, Directory_Event_GETF):
  case HASH_FUN(Directory_State_WB_E_W, Directory_Event_PUT):
  case HASH_FUN(Directory_State_WB_E_W, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_WB_O_W, Directory_Event_GETS):
  case HASH_FUN(Directory_State_WB_O_W, Directory_Event_GETX):
  case HASH_FUN(Directory_State_WB_O_W, Directory_Event_GETF):
  case HASH_FUN(Directory_State_WB_O_W, Directory_Event_PUT):
  case HASH_FUN(Directory_State_WB_O_W, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_O_R, Directory_Event_GETS):
  case HASH_FUN(Directory_State_O_R, Directory_Event_GETX):
  case HASH_FUN(Directory_State_O_R, Directory_Event_GETF):
  case HASH_FUN(Directory_State_O_R, Directory_Event_PUT):
  case HASH_FUN(Directory_State_O_R, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_S_R, Directory_Event_GETS):
  case HASH_FUN(Directory_State_S_R, Directory_Event_GETX):
  case HASH_FUN(Directory_State_S_R, Directory_Event_GETF):
  case HASH_FUN(Directory_State_S_R, Directory_Event_PUT):
  case HASH_FUN(Directory_State_S_R, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_NO_R, Directory_Event_GETS):
  case HASH_FUN(Directory_State_NO_R, Directory_Event_GETX):
  case HASH_FUN(Directory_State_NO_R, Directory_Event_GETF):
  case HASH_FUN(Directory_State_NO_R, Directory_Event_PUT):
  case HASH_FUN(Directory_State_NO_R, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_NO_F_W, Directory_Event_GETS):
  case HASH_FUN(Directory_State_NO_F_W, Directory_Event_GETX):
  case HASH_FUN(Directory_State_NO_F_W, Directory_Event_GETF):
  case HASH_FUN(Directory_State_NO_F_W, Directory_Event_PUT):
  case HASH_FUN(Directory_State_NO_F_W, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_NO_F, Directory_Event_GETS):
  case HASH_FUN(Directory_State_NO_F, Directory_Event_GETX):
  case HASH_FUN(Directory_State_NO_F, Directory_Event_GETF):
  case HASH_FUN(Directory_State_NO_F, Directory_Event_PUT):
  case HASH_FUN(Directory_State_NO_F, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_NO_B, Directory_Event_PUT):
  case HASH_FUN(Directory_State_NO_B, Directory_Event_Pf_Replacement):
  case HASH_FUN(Directory_State_NO_B_S, Directory_Event_GETX):
  case HASH_FUN(Directory_State_NO_B_S, Directory_Event_GETF):
  case HASH_FUN(Directory_State_NO_B_S, Directory_Event_PUT):
  case HASH_FUN(Directory_State_NO_B_S, Directory_Event_Pf_Replacement):
    z_stallAndWaitRequest(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_B, Directory_Event_GETX):
  case HASH_FUN(Directory_State_NO_B, Directory_Event_GETF):
    next_state = Directory_State_NO_B_X; m_curTransitionNextState = next_state;
    z_stallAndWaitRequest(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_B_X, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_NO_B_X, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_NO_B, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_NO_B, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_NO_B_S, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_NO_B_S, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_O_B, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_O_B, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_NO_DR_B_W, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_NO_DR_B_W, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_NO_DW_B_W, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_NO_DW_B_W, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_NO_B_W, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_NO_B_W, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_NO_DR_B_D, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_NO_DR_B_D, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_NO_DR_B, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_NO_DR_B, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_O_DR_B, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_O_DR_B, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_O_B_W, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_O_B_W, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_O_DR_B_W, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_O_DR_B_W, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_NO_DW_W, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_NO_DW_W, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_NO_B_S_W, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_NO_B_S_W, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_NO_W, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_NO_W, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_O_W, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_O_W, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_WB, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_WB, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_WB_E_W, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_WB_E_W, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_WB_O_W, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_WB_O_W, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_O_R, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_O_R, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_S_R, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_S_R, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_NO_R, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_NO_R, Directory_Event_DMA_WRITE):
  case HASH_FUN(Directory_State_NO_F_W, Directory_Event_DMA_READ):
  case HASH_FUN(Directory_State_NO_F_W, Directory_Event_DMA_WRITE):
    zd_stallAndWaitDMARequest(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_B, Directory_Event_GETS):
    next_state = Directory_State_NO_B_S; m_curTransitionNextState = next_state;
    if (!(*m_TBEs_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    v_allocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    rs_recordGetSRequestor(m_tbe_ptr, m_cache_entry_ptr, addr);
    i_popIncomingRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_B_S, Directory_Event_GETS):
    rs_recordGetSRequestor(m_tbe_ptr, m_cache_entry_ptr, addr);
    i_popIncomingRequestQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_B, Directory_Event_UnblockS):
  case HASH_FUN(Directory_State_NO_B_X, Directory_Event_UnblockS):
    next_state = Directory_State_NX; m_curTransitionNextState = next_state;
    us_updateSharerIfFBD(m_tbe_ptr, m_cache_entry_ptr, addr);
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    j_popIncomingUnblockQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_B, Directory_Event_UnblockM):
  case HASH_FUN(Directory_State_NO_B_X, Directory_Event_UnblockM):
    next_state = Directory_State_NO; m_curTransitionNextState = next_state;
    uo_updateOwnerIfPf(m_tbe_ptr, m_cache_entry_ptr, addr);
    us_updateSharerIfFBD(m_tbe_ptr, m_cache_entry_ptr, addr);
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    j_popIncomingUnblockQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_B_S, Directory_Event_UnblockS):
    next_state = Directory_State_NO_B_S_W; m_curTransitionNextState = next_state;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    us_updateSharerIfFBD(m_tbe_ptr, m_cache_entry_ptr, addr);
    fr_forwardMergeReadRequestsToOwner(m_tbe_ptr, m_cache_entry_ptr, addr);
    sp_setPendingMsgsToMergedSharers(m_tbe_ptr, m_cache_entry_ptr, addr);
    j_popIncomingUnblockQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_B_S, Directory_Event_UnblockM):
    next_state = Directory_State_NO_B_S_W; m_curTransitionNextState = next_state;
    if (!(*m_forwardFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    uo_updateOwnerIfPf(m_tbe_ptr, m_cache_entry_ptr, addr);
    fr_forwardMergeReadRequestsToOwner(m_tbe_ptr, m_cache_entry_ptr, addr);
    sp_setPendingMsgsToMergedSharers(m_tbe_ptr, m_cache_entry_ptr, addr);
    j_popIncomingUnblockQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_B_S_W, Directory_Event_UnblockS):
    if (!(*m_triggerQueue_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    us_updateSharerIfFBD(m_tbe_ptr, m_cache_entry_ptr, addr);
    mu_decrementNumberOfUnblocks(m_tbe_ptr, m_cache_entry_ptr, addr);
    os_checkForMergedGetSCompletion(m_tbe_ptr, m_cache_entry_ptr, addr);
    j_popIncomingUnblockQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_B_S_W, Directory_Event_All_Unblocks):
    next_state = Directory_State_NX; m_curTransitionNextState = next_state;
    w_deallocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    g_popTriggerQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_O_B, Directory_Event_UnblockS):
    next_state = Directory_State_O; m_curTransitionNextState = next_state;
    us_updateSharerIfFBD(m_tbe_ptr, m_cache_entry_ptr, addr);
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    j_popIncomingUnblockQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_O_B, Directory_Event_UnblockM):
    next_state = Directory_State_NO; m_curTransitionNextState = next_state;
    us_updateSharerIfFBD(m_tbe_ptr, m_cache_entry_ptr, addr);
    uo_updateOwnerIfPf(m_tbe_ptr, m_cache_entry_ptr, addr);
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    j_popIncomingUnblockQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_B_W, Directory_Event_Memory_Data):
    next_state = Directory_State_NO_B; m_curTransitionNextState = next_state;
    if (!(*m_responseFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    d_sendData(m_tbe_ptr, m_cache_entry_ptr, addr);
    w_deallocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    l_popMemQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_F_W, Directory_Event_Memory_Data):
    next_state = Directory_State_NO_F; m_curTransitionNextState = next_state;
    if (!(*m_responseFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    d_sendData(m_tbe_ptr, m_cache_entry_ptr, addr);
    w_deallocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    l_popMemQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_DR_B_W, Directory_Event_Memory_Data):
    next_state = Directory_State_NO_DR_B; m_curTransitionNextState = next_state;
    if (!(*m_triggerQueue_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    r_recordMemoryData(m_tbe_ptr, m_cache_entry_ptr, addr);
    o_checkForCompletion(m_tbe_ptr, m_cache_entry_ptr, addr);
    l_popMemQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_O_DR_B_W, Directory_Event_Memory_Data):
    next_state = Directory_State_O_DR_B; m_curTransitionNextState = next_state;
    if (!(*m_dmaResponseFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_triggerQueue_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    r_recordMemoryData(m_tbe_ptr, m_cache_entry_ptr, addr);
    dr_sendDmaData(m_tbe_ptr, m_cache_entry_ptr, addr);
    o_checkForCompletion(m_tbe_ptr, m_cache_entry_ptr, addr);
    l_popMemQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_DR_B, Directory_Event_Ack):
  case HASH_FUN(Directory_State_O_DR_B, Directory_Event_Ack):
  case HASH_FUN(Directory_State_NO_DR_B_D, Directory_Event_Ack):
  case HASH_FUN(Directory_State_NO_DW_B_W, Directory_Event_Ack):
  case HASH_FUN(Directory_State_O_R, Directory_Event_Ack):
  case HASH_FUN(Directory_State_S_R, Directory_Event_Ack):
  case HASH_FUN(Directory_State_NO_R, Directory_Event_Ack):
  case HASH_FUN(Directory_State_S_R, Directory_Event_Data):
    if (!(*m_triggerQueue_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    m_decrementNumberOfMessages(m_tbe_ptr, m_cache_entry_ptr, addr);
    o_checkForCompletion(m_tbe_ptr, m_cache_entry_ptr, addr);
    n_popResponseQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_R, Directory_Event_Data):
  case HASH_FUN(Directory_State_NO_R, Directory_Event_Exclusive_Data):
  case HASH_FUN(Directory_State_NO_DR_B, Directory_Event_Exclusive_Data):
  case HASH_FUN(Directory_State_NO_DR_B, Directory_Event_Data):
  case HASH_FUN(Directory_State_NO_DR_B_D, Directory_Event_Exclusive_Data):
  case HASH_FUN(Directory_State_NO_DR_B_D, Directory_Event_Data):
  case HASH_FUN(Directory_State_NO_DW_B_W, Directory_Event_Exclusive_Data):
  case HASH_FUN(Directory_State_NO_DW_B_W, Directory_Event_Data):
    if (!(*m_triggerQueue_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    r_recordCacheData(m_tbe_ptr, m_cache_entry_ptr, addr);
    m_decrementNumberOfMessages(m_tbe_ptr, m_cache_entry_ptr, addr);
    o_checkForCompletion(m_tbe_ptr, m_cache_entry_ptr, addr);
    n_popResponseQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_O_R, Directory_Event_All_acks_and_data_no_sharers):
  case HASH_FUN(Directory_State_S_R, Directory_Event_All_acks_and_data_no_sharers):
    next_state = Directory_State_E; m_curTransitionNextState = next_state;
    w_deallocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    g_popTriggerQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_R, Directory_Event_All_acks_and_data_no_sharers):
    next_state = Directory_State_WB_E_W; m_curTransitionNextState = next_state;
    if (!(*m_requestToMemory_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    ly_queueMemoryWriteFromTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    w_deallocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    g_popTriggerQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_DR_B_W, Directory_Event_Ack):
  case HASH_FUN(Directory_State_O_DR_B_W, Directory_Event_Ack):
    m_decrementNumberOfMessages(m_tbe_ptr, m_cache_entry_ptr, addr);
    n_popResponseQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_DR_B_W, Directory_Event_Shared_Ack):
  case HASH_FUN(Directory_State_O_DR_B_W, Directory_Event_Shared_Ack):
    m_decrementNumberOfMessages(m_tbe_ptr, m_cache_entry_ptr, addr);
    r_setSharerBit(m_tbe_ptr, m_cache_entry_ptr, addr);
    n_popResponseQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_O_DR_B, Directory_Event_Shared_Ack):
  case HASH_FUN(Directory_State_NO_DR_B, Directory_Event_Shared_Ack):
  case HASH_FUN(Directory_State_NO_DR_B_D, Directory_Event_Shared_Ack):
    if (!(*m_triggerQueue_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    m_decrementNumberOfMessages(m_tbe_ptr, m_cache_entry_ptr, addr);
    r_setSharerBit(m_tbe_ptr, m_cache_entry_ptr, addr);
    o_checkForCompletion(m_tbe_ptr, m_cache_entry_ptr, addr);
    n_popResponseQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_DR_B_W, Directory_Event_Shared_Data):
  case HASH_FUN(Directory_State_NO_DR_B, Directory_Event_Shared_Data):
  case HASH_FUN(Directory_State_NO_DR_B_D, Directory_Event_Shared_Data):
    if (!(*m_triggerQueue_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    r_recordCacheData(m_tbe_ptr, m_cache_entry_ptr, addr);
    m_decrementNumberOfMessages(m_tbe_ptr, m_cache_entry_ptr, addr);
    so_setOwnerBit(m_tbe_ptr, m_cache_entry_ptr, addr);
    o_checkForCompletion(m_tbe_ptr, m_cache_entry_ptr, addr);
    n_popResponseQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_DR_B_W, Directory_Event_Exclusive_Data):
  case HASH_FUN(Directory_State_NO_DR_B_W, Directory_Event_Data):
    r_recordCacheData(m_tbe_ptr, m_cache_entry_ptr, addr);
    m_decrementNumberOfMessages(m_tbe_ptr, m_cache_entry_ptr, addr);
    n_popResponseQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_DR_B, Directory_Event_All_acks_and_owner_data):
  case HASH_FUN(Directory_State_NO_DR_B_D, Directory_Event_All_acks_and_owner_data):
    next_state = Directory_State_WB_O_W; m_curTransitionNextState = next_state;
    if (!(*m_dmaResponseFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_requestToMemory_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    dt_sendDmaDataFromTbe(m_tbe_ptr, m_cache_entry_ptr, addr);
    ly_queueMemoryWriteFromTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    w_deallocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    g_popTriggerQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_DR_B, Directory_Event_All_acks_and_shared_data):
  case HASH_FUN(Directory_State_NO_DR_B_D, Directory_Event_All_acks_and_shared_data):
    next_state = Directory_State_S; m_curTransitionNextState = next_state;
    if (!(*m_dmaResponseFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    dt_sendDmaDataFromTbe(m_tbe_ptr, m_cache_entry_ptr, addr);
    w_deallocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    g_popTriggerQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_O_DR_B, Directory_Event_All_acks_and_owner_data):
    next_state = Directory_State_WB_O_W; m_curTransitionNextState = next_state;
    if (!(*m_requestToMemory_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    ly_queueMemoryWriteFromTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    w_deallocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    g_popTriggerQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_O_DR_B, Directory_Event_All_acks_and_data_no_sharers):
    next_state = Directory_State_WB_E_W; m_curTransitionNextState = next_state;
    if (!(*m_requestToMemory_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    ly_queueMemoryWriteFromTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    w_deallocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    pfd_probeFilterDeallocate(m_tbe_ptr, m_cache_entry_ptr, addr);
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    g_popTriggerQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_DR_B, Directory_Event_All_acks_and_data_no_sharers):
    next_state = Directory_State_WB_E_W; m_curTransitionNextState = next_state;
    if (!(*m_dmaResponseFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_requestToMemory_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    dt_sendDmaDataFromTbe(m_tbe_ptr, m_cache_entry_ptr, addr);
    ly_queueMemoryWriteFromTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    w_deallocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    ppfd_possibleProbeFilterDeallocate(m_tbe_ptr, m_cache_entry_ptr, addr);
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    g_popTriggerQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_DR_B_D, Directory_Event_All_acks_and_data_no_sharers):
    next_state = Directory_State_WB_E_W; m_curTransitionNextState = next_state;
    if (!(*m_dmaResponseFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    if (!(*m_requestToMemory_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    a_assertCacheData(m_tbe_ptr, m_cache_entry_ptr, addr);
    dt_sendDmaDataFromTbe(m_tbe_ptr, m_cache_entry_ptr, addr);
    ly_queueMemoryWriteFromTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    w_deallocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    ppfd_possibleProbeFilterDeallocate(m_tbe_ptr, m_cache_entry_ptr, addr);
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    g_popTriggerQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_DW_B_W, Directory_Event_All_acks_and_data_no_sharers):
    next_state = Directory_State_NO_DW_W; m_curTransitionNextState = next_state;
    if (!(*m_requestToMemory_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    ld_queueMemoryDmaWrite(m_tbe_ptr, m_cache_entry_ptr, addr);
    g_popTriggerQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_DW_W, Directory_Event_Memory_Ack):
    next_state = Directory_State_E; m_curTransitionNextState = next_state;
    if (!(*m_dmaResponseFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    da_sendDmaAck(m_tbe_ptr, m_cache_entry_ptr, addr);
    w_deallocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    ppfd_possibleProbeFilterDeallocate(m_tbe_ptr, m_cache_entry_ptr, addr);
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    l_popMemQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_O_B_W, Directory_Event_Memory_Data):
    next_state = Directory_State_O_B; m_curTransitionNextState = next_state;
    if (!(*m_responseFromDir_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    d_sendData(m_tbe_ptr, m_cache_entry_ptr, addr);
    w_deallocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    l_popMemQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_B_W, Directory_Event_UnblockM):
    next_state = Directory_State_NO_W; m_curTransitionNextState = next_state;
    uo_updateOwnerIfPf(m_tbe_ptr, m_cache_entry_ptr, addr);
    j_popIncomingUnblockQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_B_W, Directory_Event_UnblockS):
    next_state = Directory_State_NO_W; m_curTransitionNextState = next_state;
    us_updateSharerIfFBD(m_tbe_ptr, m_cache_entry_ptr, addr);
    j_popIncomingUnblockQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_O_B_W, Directory_Event_UnblockS):
    next_state = Directory_State_O_W; m_curTransitionNextState = next_state;
    us_updateSharerIfFBD(m_tbe_ptr, m_cache_entry_ptr, addr);
    j_popIncomingUnblockQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_W, Directory_Event_Memory_Data):
    next_state = Directory_State_NO; m_curTransitionNextState = next_state;
    w_deallocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    l_popMemQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_O_W, Directory_Event_Memory_Data):
    next_state = Directory_State_O; m_curTransitionNextState = next_state;
    w_deallocateTBE(m_tbe_ptr, m_cache_entry_ptr, addr);
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    l_popMemQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_WB, Directory_Event_Writeback_Dirty):
    next_state = Directory_State_WB_O_W; m_curTransitionNextState = next_state;
    if (!(*m_requestToMemory_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    rs_removeSharer(m_tbe_ptr, m_cache_entry_ptr, addr);
    l_queueMemoryWBRequest(m_tbe_ptr, m_cache_entry_ptr, addr);
    j_popIncomingUnblockQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_WB, Directory_Event_Writeback_Exclusive_Dirty):
    next_state = Directory_State_WB_E_W; m_curTransitionNextState = next_state;
    if (!(*m_requestToMemory_ptr).areNSlotsAvailable(1, clockEdge()))
        return TransitionResult_ResourceStall;
    rs_removeSharer(m_tbe_ptr, m_cache_entry_ptr, addr);
    l_queueMemoryWBRequest(m_tbe_ptr, m_cache_entry_ptr, addr);
    pfd_probeFilterDeallocate(m_tbe_ptr, m_cache_entry_ptr, addr);
    j_popIncomingUnblockQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_WB_E_W, Directory_Event_Memory_Ack):
    next_state = Directory_State_E; m_curTransitionNextState = next_state;
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    l_popMemQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_WB_O_W, Directory_Event_Memory_Ack):
    next_state = Directory_State_O; m_curTransitionNextState = next_state;
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    l_popMemQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_WB, Directory_Event_Writeback_Clean):
    next_state = Directory_State_O; m_curTransitionNextState = next_state;
    ll_checkIncomingWriteback(m_tbe_ptr, m_cache_entry_ptr, addr);
    rs_removeSharer(m_tbe_ptr, m_cache_entry_ptr, addr);
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    j_popIncomingUnblockQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_WB, Directory_Event_Writeback_Exclusive_Clean):
    next_state = Directory_State_E; m_curTransitionNextState = next_state;
    ll_checkIncomingWriteback(m_tbe_ptr, m_cache_entry_ptr, addr);
    rs_removeSharer(m_tbe_ptr, m_cache_entry_ptr, addr);
    pfd_probeFilterDeallocate(m_tbe_ptr, m_cache_entry_ptr, addr);
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    j_popIncomingUnblockQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_WB, Directory_Event_Unblock):
    next_state = Directory_State_NX; m_curTransitionNextState = next_state;
    auno_assertUnblockerNotOwner(m_tbe_ptr, m_cache_entry_ptr, addr);
    k_wakeUpDependents(m_tbe_ptr, m_cache_entry_ptr, addr);
    j_popIncomingUnblockQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

  case HASH_FUN(Directory_State_NO_F, Directory_Event_UnblockM):
    us_updateSharerIfFBD(m_tbe_ptr, m_cache_entry_ptr, addr);
    uo_updateOwnerIfPf(m_tbe_ptr, m_cache_entry_ptr, addr);
    j_popIncomingUnblockQueue(m_tbe_ptr, m_cache_entry_ptr, addr);
    return TransitionResult_Valid;

      default:
        panic("Invalid transition\n"
              "%s time: %d addr: %#x event: %s state: %s\n",
              name(), curCycle(), addr, event, state);
    }

    return TransitionResult_Valid;
}

} // namespace ruby
} // namespace gem5
