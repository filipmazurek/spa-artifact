/**
 * DO NOT EDIT THIS FILE!
 * File automatically generated by
 *   /shared/gem5/src/mem/slicc/symbols/StateMachine.py:1348
 */

// Created by slicc definition of Module "AMD Hammer-like protocol"

#include <sys/types.h>
#include <unistd.h>

#include <cassert>
#include <sstream>
#include <string>
#include <typeinfo>

#include "mem/ruby/common/BoolVec.hh"

#include "base/compiler.hh"
#include "base/cprintf.hh"

#include "debug/RubyGenerated.hh"
#include "debug/RubySlicc.hh"
#include "mem/ruby/network/Network.hh"
#include "mem/ruby/protocol/Directory_Controller.hh"
#include "mem/ruby/protocol/Directory_Event.hh"
#include "mem/ruby/protocol/Directory_State.hh"
#include "mem/ruby/protocol/Types.hh"
#include "mem/ruby/system/RubySystem.hh"

#include "mem/ruby/slicc_interface/RubySlicc_includes.hh"
#include "mem/ruby/protocol/Set.hh"
#include "mem/ruby/protocol/TBETable.hh"
namespace gem5
{

namespace ruby
{

int Directory_Controller::m_num_controllers = 0;
std::vector<statistics::Vector *>  Directory_Controller::eventVec;
std::vector<std::vector<statistics::Vector *> >  Directory_Controller::transVec;

// for adding information to the protocol debug trace
std::stringstream Directory_transitionComment;

#ifndef NDEBUG
#define APPEND_TRANSITION_COMMENT(str) (Directory_transitionComment << str)
#else
#define APPEND_TRANSITION_COMMENT(str) do {} while (0)
#endif

/** \brief constructor */
Directory_Controller::Directory_Controller(const Params &p)
    : AbstractController(p)
{
    m_machineID.type = MachineType_Directory;
    m_machineID.num = m_version;
    m_num_controllers++;
    p.ruby_system->registerAbstractController(this);

    m_in_ports = 6;
    m_directory_ptr = p.directory;
    m_probeFilter_ptr = p.probeFilter;
    m_from_memory_controller_latency = p.from_memory_controller_latency;
    m_to_memory_controller_latency = p.to_memory_controller_latency;
    m_probe_filter_enabled = p.probe_filter_enabled;
    m_full_bit_dir_enabled = p.full_bit_dir_enabled;
    m_forwardFromDir_ptr = p.forwardFromDir;
    m_responseFromDir_ptr = p.responseFromDir;
    m_dmaResponseFromDir_ptr = p.dmaResponseFromDir;
    m_unblockToDir_ptr = p.unblockToDir;
    m_responseToDir_ptr = p.responseToDir;
    m_requestToDir_ptr = p.requestToDir;
    m_dmaRequestToDir_ptr = p.dmaRequestToDir;
    m_triggerQueue_ptr = p.triggerQueue;
    m_requestToMemory_ptr = p.requestToMemory;
    m_responseFromMemory_ptr = p.responseFromMemory;

    for (int state = 0; state < Directory_State_NUM; state++) {
        for (int event = 0; event < Directory_Event_NUM; event++) {
            m_possible[state][event] = false;
            m_counters[state][event] = 0;
        }
    }
    for (int event = 0; event < Directory_Event_NUM; event++) {
        m_event_counters[event] = 0;
    }
}

void
Directory_Controller::initNetQueues()
{
    MachineType machine_type = string_to_MachineType("Directory");
    [[maybe_unused]] int base = MachineType_base_number(machine_type);

    assert(m_forwardFromDir_ptr != NULL);
    m_net_ptr->setToNetQueue(m_version + base, m_forwardFromDir_ptr->getOrdered(), 3,
                                     "forward", m_forwardFromDir_ptr);
    assert(m_responseFromDir_ptr != NULL);
    m_net_ptr->setToNetQueue(m_version + base, m_responseFromDir_ptr->getOrdered(), 4,
                                     "response", m_responseFromDir_ptr);
    assert(m_dmaResponseFromDir_ptr != NULL);
    m_net_ptr->setToNetQueue(m_version + base, m_dmaResponseFromDir_ptr->getOrdered(), 1,
                                     "response", m_dmaResponseFromDir_ptr);
    assert(m_unblockToDir_ptr != NULL);
    m_net_ptr->setFromNetQueue(m_version + base, m_unblockToDir_ptr->getOrdered(), 5,
                                     "unblock", m_unblockToDir_ptr);
    assert(m_responseToDir_ptr != NULL);
    m_net_ptr->setFromNetQueue(m_version + base, m_responseToDir_ptr->getOrdered(), 4,
                                     "response", m_responseToDir_ptr);
    assert(m_requestToDir_ptr != NULL);
    m_net_ptr->setFromNetQueue(m_version + base, m_requestToDir_ptr->getOrdered(), 2,
                                     "request", m_requestToDir_ptr);
    assert(m_dmaRequestToDir_ptr != NULL);
    m_net_ptr->setFromNetQueue(m_version + base, m_dmaRequestToDir_ptr->getOrdered(), 0,
                                     "request", m_dmaRequestToDir_ptr);
}

void
Directory_Controller::init()
{
    // initialize objects
    m_fwd_set_ptr  = new Set();
    assert(m_fwd_set_ptr != NULL);
    m_TBEs_ptr  = new TBETable<Directory_TBE>(m_number_of_TBEs);
    assert(m_TBEs_ptr != NULL);


    (*m_triggerQueue_ptr).setConsumer(this);
    (*m_unblockToDir_ptr).setConsumer(this);
    (*m_responseToDir_ptr).setConsumer(this);
    (*m_responseFromMemory_ptr).setConsumer(this);
    (*m_requestToDir_ptr).setConsumer(this);
    (*m_dmaRequestToDir_ptr).setConsumer(this);

    possibleTransition(Directory_State_E, Directory_Event_GETX);
    possibleTransition(Directory_State_E, Directory_Event_GETF);
    possibleTransition(Directory_State_E, Directory_Event_GETS);
    possibleTransition(Directory_State_E, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_E, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_O, Directory_Event_GETX);
    possibleTransition(Directory_State_O, Directory_Event_GETF);
    possibleTransition(Directory_State_O, Directory_Event_GETS);
    possibleTransition(Directory_State_O, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_O, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_S, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_NO, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_NX, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_O, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_S, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_NO, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_NX, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_NX, Directory_Event_GETX);
    possibleTransition(Directory_State_NX, Directory_Event_GETF);
    possibleTransition(Directory_State_NO, Directory_Event_GETX);
    possibleTransition(Directory_State_NO, Directory_Event_GETF);
    possibleTransition(Directory_State_S, Directory_Event_GETX);
    possibleTransition(Directory_State_S, Directory_Event_GETF);
    possibleTransition(Directory_State_S, Directory_Event_GETS);
    possibleTransition(Directory_State_NO, Directory_Event_GETS);
    possibleTransition(Directory_State_NX, Directory_Event_GETS);
    possibleTransition(Directory_State_NO, Directory_Event_PUT);
    possibleTransition(Directory_State_NX, Directory_Event_PUT);
    possibleTransition(Directory_State_S, Directory_Event_PUT);
    possibleTransition(Directory_State_NO, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_NX, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_S, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_O, Directory_Event_PUT);
    possibleTransition(Directory_State_E, Directory_Event_PUT);
    possibleTransition(Directory_State_NO_B_X, Directory_Event_GETS);
    possibleTransition(Directory_State_NO_B_X, Directory_Event_GETX);
    possibleTransition(Directory_State_NO_B_X, Directory_Event_GETF);
    possibleTransition(Directory_State_NO_B_X, Directory_Event_PUT);
    possibleTransition(Directory_State_NO_B_X, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_O_B, Directory_Event_GETS);
    possibleTransition(Directory_State_O_B, Directory_Event_GETX);
    possibleTransition(Directory_State_O_B, Directory_Event_GETF);
    possibleTransition(Directory_State_O_B, Directory_Event_PUT);
    possibleTransition(Directory_State_O_B, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_NO_DR_B_W, Directory_Event_GETS);
    possibleTransition(Directory_State_NO_DR_B_W, Directory_Event_GETX);
    possibleTransition(Directory_State_NO_DR_B_W, Directory_Event_GETF);
    possibleTransition(Directory_State_NO_DR_B_W, Directory_Event_PUT);
    possibleTransition(Directory_State_NO_DR_B_W, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_NO_DW_B_W, Directory_Event_GETS);
    possibleTransition(Directory_State_NO_DW_B_W, Directory_Event_GETX);
    possibleTransition(Directory_State_NO_DW_B_W, Directory_Event_GETF);
    possibleTransition(Directory_State_NO_DW_B_W, Directory_Event_PUT);
    possibleTransition(Directory_State_NO_DW_B_W, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_NO_B_W, Directory_Event_GETS);
    possibleTransition(Directory_State_NO_B_W, Directory_Event_GETX);
    possibleTransition(Directory_State_NO_B_W, Directory_Event_GETF);
    possibleTransition(Directory_State_NO_B_W, Directory_Event_PUT);
    possibleTransition(Directory_State_NO_B_W, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_NO_DR_B_D, Directory_Event_GETS);
    possibleTransition(Directory_State_NO_DR_B_D, Directory_Event_GETX);
    possibleTransition(Directory_State_NO_DR_B_D, Directory_Event_GETF);
    possibleTransition(Directory_State_NO_DR_B_D, Directory_Event_PUT);
    possibleTransition(Directory_State_NO_DR_B_D, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_NO_DR_B, Directory_Event_GETS);
    possibleTransition(Directory_State_NO_DR_B, Directory_Event_GETX);
    possibleTransition(Directory_State_NO_DR_B, Directory_Event_GETF);
    possibleTransition(Directory_State_NO_DR_B, Directory_Event_PUT);
    possibleTransition(Directory_State_NO_DR_B, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_O_DR_B, Directory_Event_GETS);
    possibleTransition(Directory_State_O_DR_B, Directory_Event_GETX);
    possibleTransition(Directory_State_O_DR_B, Directory_Event_GETF);
    possibleTransition(Directory_State_O_DR_B, Directory_Event_PUT);
    possibleTransition(Directory_State_O_DR_B, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_O_B_W, Directory_Event_GETS);
    possibleTransition(Directory_State_O_B_W, Directory_Event_GETX);
    possibleTransition(Directory_State_O_B_W, Directory_Event_GETF);
    possibleTransition(Directory_State_O_B_W, Directory_Event_PUT);
    possibleTransition(Directory_State_O_B_W, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_O_DR_B_W, Directory_Event_GETS);
    possibleTransition(Directory_State_O_DR_B_W, Directory_Event_GETX);
    possibleTransition(Directory_State_O_DR_B_W, Directory_Event_GETF);
    possibleTransition(Directory_State_O_DR_B_W, Directory_Event_PUT);
    possibleTransition(Directory_State_O_DR_B_W, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_NO_DW_W, Directory_Event_GETS);
    possibleTransition(Directory_State_NO_DW_W, Directory_Event_GETX);
    possibleTransition(Directory_State_NO_DW_W, Directory_Event_GETF);
    possibleTransition(Directory_State_NO_DW_W, Directory_Event_PUT);
    possibleTransition(Directory_State_NO_DW_W, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_NO_B_S_W, Directory_Event_GETS);
    possibleTransition(Directory_State_NO_B_S_W, Directory_Event_GETX);
    possibleTransition(Directory_State_NO_B_S_W, Directory_Event_GETF);
    possibleTransition(Directory_State_NO_B_S_W, Directory_Event_PUT);
    possibleTransition(Directory_State_NO_B_S_W, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_NO_W, Directory_Event_GETS);
    possibleTransition(Directory_State_NO_W, Directory_Event_GETX);
    possibleTransition(Directory_State_NO_W, Directory_Event_GETF);
    possibleTransition(Directory_State_NO_W, Directory_Event_PUT);
    possibleTransition(Directory_State_NO_W, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_O_W, Directory_Event_GETS);
    possibleTransition(Directory_State_O_W, Directory_Event_GETX);
    possibleTransition(Directory_State_O_W, Directory_Event_GETF);
    possibleTransition(Directory_State_O_W, Directory_Event_PUT);
    possibleTransition(Directory_State_O_W, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_WB, Directory_Event_GETS);
    possibleTransition(Directory_State_WB, Directory_Event_GETX);
    possibleTransition(Directory_State_WB, Directory_Event_GETF);
    possibleTransition(Directory_State_WB, Directory_Event_PUT);
    possibleTransition(Directory_State_WB, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_WB_E_W, Directory_Event_GETS);
    possibleTransition(Directory_State_WB_E_W, Directory_Event_GETX);
    possibleTransition(Directory_State_WB_E_W, Directory_Event_GETF);
    possibleTransition(Directory_State_WB_E_W, Directory_Event_PUT);
    possibleTransition(Directory_State_WB_E_W, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_WB_O_W, Directory_Event_GETS);
    possibleTransition(Directory_State_WB_O_W, Directory_Event_GETX);
    possibleTransition(Directory_State_WB_O_W, Directory_Event_GETF);
    possibleTransition(Directory_State_WB_O_W, Directory_Event_PUT);
    possibleTransition(Directory_State_WB_O_W, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_O_R, Directory_Event_GETS);
    possibleTransition(Directory_State_O_R, Directory_Event_GETX);
    possibleTransition(Directory_State_O_R, Directory_Event_GETF);
    possibleTransition(Directory_State_O_R, Directory_Event_PUT);
    possibleTransition(Directory_State_O_R, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_S_R, Directory_Event_GETS);
    possibleTransition(Directory_State_S_R, Directory_Event_GETX);
    possibleTransition(Directory_State_S_R, Directory_Event_GETF);
    possibleTransition(Directory_State_S_R, Directory_Event_PUT);
    possibleTransition(Directory_State_S_R, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_NO_R, Directory_Event_GETS);
    possibleTransition(Directory_State_NO_R, Directory_Event_GETX);
    possibleTransition(Directory_State_NO_R, Directory_Event_GETF);
    possibleTransition(Directory_State_NO_R, Directory_Event_PUT);
    possibleTransition(Directory_State_NO_R, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_NO_F_W, Directory_Event_GETS);
    possibleTransition(Directory_State_NO_F_W, Directory_Event_GETX);
    possibleTransition(Directory_State_NO_F_W, Directory_Event_GETF);
    possibleTransition(Directory_State_NO_F_W, Directory_Event_PUT);
    possibleTransition(Directory_State_NO_F_W, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_NO_F, Directory_Event_GETS);
    possibleTransition(Directory_State_NO_F, Directory_Event_GETX);
    possibleTransition(Directory_State_NO_F, Directory_Event_GETF);
    possibleTransition(Directory_State_NO_F, Directory_Event_PUT);
    possibleTransition(Directory_State_NO_F, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_NO_B, Directory_Event_GETX);
    possibleTransition(Directory_State_NO_B, Directory_Event_GETF);
    possibleTransition(Directory_State_NO_B, Directory_Event_PUT);
    possibleTransition(Directory_State_NO_B, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_NO_B_S, Directory_Event_GETX);
    possibleTransition(Directory_State_NO_B_S, Directory_Event_GETF);
    possibleTransition(Directory_State_NO_B_S, Directory_Event_PUT);
    possibleTransition(Directory_State_NO_B_S, Directory_Event_Pf_Replacement);
    possibleTransition(Directory_State_NO_B_X, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_NO_B_X, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_NO_B, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_NO_B, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_NO_B_S, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_NO_B_S, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_O_B, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_O_B, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_NO_DR_B_W, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_NO_DR_B_W, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_NO_DW_B_W, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_NO_DW_B_W, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_NO_B_W, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_NO_B_W, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_NO_DR_B_D, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_NO_DR_B_D, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_NO_DR_B, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_NO_DR_B, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_O_DR_B, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_O_DR_B, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_O_B_W, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_O_B_W, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_O_DR_B_W, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_O_DR_B_W, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_NO_DW_W, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_NO_DW_W, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_NO_B_S_W, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_NO_B_S_W, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_NO_W, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_NO_W, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_O_W, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_O_W, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_WB, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_WB, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_WB_E_W, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_WB_E_W, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_WB_O_W, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_WB_O_W, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_O_R, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_O_R, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_S_R, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_S_R, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_NO_R, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_NO_R, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_NO_F_W, Directory_Event_DMA_READ);
    possibleTransition(Directory_State_NO_F_W, Directory_Event_DMA_WRITE);
    possibleTransition(Directory_State_NO_B, Directory_Event_GETS);
    possibleTransition(Directory_State_NO_B_S, Directory_Event_GETS);
    possibleTransition(Directory_State_NO_B, Directory_Event_UnblockS);
    possibleTransition(Directory_State_NO_B_X, Directory_Event_UnblockS);
    possibleTransition(Directory_State_NO_B, Directory_Event_UnblockM);
    possibleTransition(Directory_State_NO_B_X, Directory_Event_UnblockM);
    possibleTransition(Directory_State_NO_B_S, Directory_Event_UnblockS);
    possibleTransition(Directory_State_NO_B_S, Directory_Event_UnblockM);
    possibleTransition(Directory_State_NO_B_S_W, Directory_Event_UnblockS);
    possibleTransition(Directory_State_NO_B_S_W, Directory_Event_All_Unblocks);
    possibleTransition(Directory_State_O_B, Directory_Event_UnblockS);
    possibleTransition(Directory_State_O_B, Directory_Event_UnblockM);
    possibleTransition(Directory_State_NO_B_W, Directory_Event_Memory_Data);
    possibleTransition(Directory_State_NO_F_W, Directory_Event_Memory_Data);
    possibleTransition(Directory_State_NO_DR_B_W, Directory_Event_Memory_Data);
    possibleTransition(Directory_State_O_DR_B_W, Directory_Event_Memory_Data);
    possibleTransition(Directory_State_NO_DR_B, Directory_Event_Ack);
    possibleTransition(Directory_State_O_DR_B, Directory_Event_Ack);
    possibleTransition(Directory_State_NO_DR_B_D, Directory_Event_Ack);
    possibleTransition(Directory_State_NO_DW_B_W, Directory_Event_Ack);
    possibleTransition(Directory_State_O_R, Directory_Event_Ack);
    possibleTransition(Directory_State_S_R, Directory_Event_Ack);
    possibleTransition(Directory_State_NO_R, Directory_Event_Ack);
    possibleTransition(Directory_State_S_R, Directory_Event_Data);
    possibleTransition(Directory_State_NO_R, Directory_Event_Data);
    possibleTransition(Directory_State_NO_R, Directory_Event_Exclusive_Data);
    possibleTransition(Directory_State_O_R, Directory_Event_All_acks_and_data_no_sharers);
    possibleTransition(Directory_State_S_R, Directory_Event_All_acks_and_data_no_sharers);
    possibleTransition(Directory_State_NO_R, Directory_Event_All_acks_and_data_no_sharers);
    possibleTransition(Directory_State_NO_DR_B_W, Directory_Event_Ack);
    possibleTransition(Directory_State_O_DR_B_W, Directory_Event_Ack);
    possibleTransition(Directory_State_NO_DR_B_W, Directory_Event_Shared_Ack);
    possibleTransition(Directory_State_O_DR_B, Directory_Event_Shared_Ack);
    possibleTransition(Directory_State_O_DR_B_W, Directory_Event_Shared_Ack);
    possibleTransition(Directory_State_NO_DR_B, Directory_Event_Shared_Ack);
    possibleTransition(Directory_State_NO_DR_B_D, Directory_Event_Shared_Ack);
    possibleTransition(Directory_State_NO_DR_B_W, Directory_Event_Shared_Data);
    possibleTransition(Directory_State_NO_DR_B, Directory_Event_Shared_Data);
    possibleTransition(Directory_State_NO_DR_B_D, Directory_Event_Shared_Data);
    possibleTransition(Directory_State_NO_DR_B_W, Directory_Event_Exclusive_Data);
    possibleTransition(Directory_State_NO_DR_B_W, Directory_Event_Data);
    possibleTransition(Directory_State_NO_DR_B, Directory_Event_Exclusive_Data);
    possibleTransition(Directory_State_NO_DR_B, Directory_Event_Data);
    possibleTransition(Directory_State_NO_DR_B_D, Directory_Event_Exclusive_Data);
    possibleTransition(Directory_State_NO_DR_B_D, Directory_Event_Data);
    possibleTransition(Directory_State_NO_DW_B_W, Directory_Event_Exclusive_Data);
    possibleTransition(Directory_State_NO_DW_B_W, Directory_Event_Data);
    possibleTransition(Directory_State_NO_DR_B, Directory_Event_All_acks_and_owner_data);
    possibleTransition(Directory_State_NO_DR_B, Directory_Event_All_acks_and_shared_data);
    possibleTransition(Directory_State_NO_DR_B_D, Directory_Event_All_acks_and_owner_data);
    possibleTransition(Directory_State_NO_DR_B_D, Directory_Event_All_acks_and_shared_data);
    possibleTransition(Directory_State_O_DR_B, Directory_Event_All_acks_and_owner_data);
    possibleTransition(Directory_State_O_DR_B, Directory_Event_All_acks_and_data_no_sharers);
    possibleTransition(Directory_State_NO_DR_B, Directory_Event_All_acks_and_data_no_sharers);
    possibleTransition(Directory_State_NO_DR_B_D, Directory_Event_All_acks_and_data_no_sharers);
    possibleTransition(Directory_State_NO_DW_B_W, Directory_Event_All_acks_and_data_no_sharers);
    possibleTransition(Directory_State_NO_DW_W, Directory_Event_Memory_Ack);
    possibleTransition(Directory_State_O_B_W, Directory_Event_Memory_Data);
    possibleTransition(Directory_State_NO_B_W, Directory_Event_UnblockM);
    possibleTransition(Directory_State_NO_B_W, Directory_Event_UnblockS);
    possibleTransition(Directory_State_O_B_W, Directory_Event_UnblockS);
    possibleTransition(Directory_State_NO_W, Directory_Event_Memory_Data);
    possibleTransition(Directory_State_O_W, Directory_Event_Memory_Data);
    possibleTransition(Directory_State_WB, Directory_Event_Writeback_Dirty);
    possibleTransition(Directory_State_WB, Directory_Event_Writeback_Exclusive_Dirty);
    possibleTransition(Directory_State_WB_E_W, Directory_Event_Memory_Ack);
    possibleTransition(Directory_State_WB_O_W, Directory_Event_Memory_Ack);
    possibleTransition(Directory_State_WB, Directory_Event_Writeback_Clean);
    possibleTransition(Directory_State_WB, Directory_Event_Writeback_Exclusive_Clean);
    possibleTransition(Directory_State_WB, Directory_Event_Unblock);
    possibleTransition(Directory_State_NO_F, Directory_Event_PUTF);
    possibleTransition(Directory_State_NO_F, Directory_Event_UnblockM);
    AbstractController::init();
    resetStats();
}

Sequencer*
Directory_Controller::getCPUSequencer() const
{
    return NULL;
}

DMASequencer*
Directory_Controller::getDMASequencer() const
{
    return NULL;
}

GPUCoalescer*
Directory_Controller::getGPUCoalescer() const
{
    return NULL;
}

void
Directory_Controller::regStats()
{
    AbstractController::regStats();

    // For each type of controllers, one controller of that type is picked
    // to aggregate stats of all controllers of that type.
    if (m_version == 0) {

        Profiler *profiler = params().ruby_system->getProfiler();
        statistics::Group *profilerStatsPtr = &profiler->rubyProfilerStats;

        for (Directory_Event event = Directory_Event_FIRST;
             event < Directory_Event_NUM; ++event) {
            std::string stat_name =
                "Directory_Controller." + Directory_Event_to_string(event);
            statistics::Vector *t =
                new statistics::Vector(profilerStatsPtr, stat_name.c_str());
            t->init(m_num_controllers);
            t->flags(statistics::pdf | statistics::total |
                statistics::oneline | statistics::nozero);

            eventVec.push_back(t);
        }

        for (Directory_State state = Directory_State_FIRST;
             state < Directory_State_NUM; ++state) {

            transVec.push_back(std::vector<statistics::Vector *>());

            for (Directory_Event event = Directory_Event_FIRST;
                 event < Directory_Event_NUM; ++event) {
                std::string stat_name = "Directory_Controller." +
                    Directory_State_to_string(state) +
                    "." + Directory_Event_to_string(event);
                statistics::Vector *t = new statistics::Vector(
                    profilerStatsPtr, stat_name.c_str());
                t->init(m_num_controllers);
                t->flags(statistics::pdf | statistics::total |
                    statistics::oneline | statistics::nozero);
                transVec[state].push_back(t);
            }
        }
    }

    for (Directory_Event event = Directory_Event_FIRST;
                 event < Directory_Event_NUM; ++event) {
        std::string stat_name =
            "outTransLatHist." + Directory_Event_to_string(event);
        statistics::Histogram* t =
            new statistics::Histogram(&stats, stat_name.c_str());
        stats.outTransLatHist.push_back(t);
        t->init(5);
        t->flags(statistics::pdf | statistics::total |
                 statistics::oneline | statistics::nozero);

        statistics::Scalar* r = new statistics::Scalar(&stats,
                                             (stat_name + ".retries").c_str());
        stats.outTransLatHistRetries.push_back(r);
        r->flags(statistics::nozero);
    }

    for (Directory_Event event = Directory_Event_FIRST;
                 event < Directory_Event_NUM; ++event) {
        std::string stat_name = "inTransLatHist." +
                                Directory_Event_to_string(event);
        statistics::Scalar* r = new statistics::Scalar(&stats,
                                             (stat_name + ".total").c_str());
        stats.inTransLatTotal.push_back(r);
        r->flags(statistics::nozero);

        r = new statistics::Scalar(&stats,
                              (stat_name + ".retries").c_str());
        stats.inTransLatRetries.push_back(r);
        r->flags(statistics::nozero);

        stats.inTransLatHist.emplace_back();
        for (Directory_State initial_state = Directory_State_FIRST;
             initial_state < Directory_State_NUM; ++initial_state) {
            stats.inTransLatHist.back().emplace_back();
            for (Directory_State final_state = Directory_State_FIRST;
                 final_state < Directory_State_NUM; ++final_state) {
                std::string stat_name = "inTransLatHist." +
                    Directory_Event_to_string(event) + "." +
                    Directory_State_to_string(initial_state) + "." +
                    Directory_State_to_string(final_state);
                statistics::Histogram* t =
                    new statistics::Histogram(&stats, stat_name.c_str());
                stats.inTransLatHist.back().back().push_back(t);
                t->init(5);
                t->flags(statistics::pdf | statistics::total |
                         statistics::oneline | statistics::nozero);
            }
        }
    }
}

void
Directory_Controller::collateStats()
{
    for (Directory_Event event = Directory_Event_FIRST;
         event < Directory_Event_NUM; ++event) {
        for (unsigned int i = 0; i < m_num_controllers; ++i) {
            RubySystem *rs = params().ruby_system;
            std::map<uint32_t, AbstractController *>::iterator it =
                     rs->m_abstract_controls[MachineType_Directory].find(i);
            assert(it != rs->m_abstract_controls[MachineType_Directory].end());
            (*eventVec[event])[i] =
                ((Directory_Controller *)(*it).second)->getEventCount(event);
        }
    }

    for (Directory_State state = Directory_State_FIRST;
         state < Directory_State_NUM; ++state) {

        for (Directory_Event event = Directory_Event_FIRST;
             event < Directory_Event_NUM; ++event) {

            for (unsigned int i = 0; i < m_num_controllers; ++i) {
                RubySystem *rs = params().ruby_system;
                std::map<uint32_t, AbstractController *>::iterator it =
                         rs->m_abstract_controls[MachineType_Directory].find(i);
                assert(it != rs->m_abstract_controls[MachineType_Directory].end());
                (*transVec[state][event])[i] =
                    ((Directory_Controller *)(*it).second)->getTransitionCount(state, event);
            }
        }
    }
}

void
Directory_Controller::countTransition(Directory_State state, Directory_Event event)
{
    assert(m_possible[state][event]);
    m_counters[state][event]++;
    m_event_counters[event]++;
}
void
Directory_Controller::possibleTransition(Directory_State state,
                             Directory_Event event)
{
    m_possible[state][event] = true;
}

uint64_t
Directory_Controller::getEventCount(Directory_Event event)
{
    return m_event_counters[event];
}

bool
Directory_Controller::isPossible(Directory_State state, Directory_Event event)
{
    return m_possible[state][event];
}

uint64_t
Directory_Controller::getTransitionCount(Directory_State state,
                             Directory_Event event)
{
    return m_counters[state][event];
}

int
Directory_Controller::getNumControllers()
{
    return m_num_controllers;
}

MessageBuffer*
Directory_Controller::getMandatoryQueue() const
{
    return NULL;
}

MessageBuffer*
Directory_Controller::getMemReqQueue() const
{
    return m_requestToMemory_ptr;
}

MessageBuffer*
Directory_Controller::getMemRespQueue() const
{
    return m_responseFromMemory_ptr;
}

void
Directory_Controller::print(std::ostream& out) const
{
    out << "[Directory_Controller " << m_version << "]";
}

void Directory_Controller::resetStats()
{
    for (int state = 0; state < Directory_State_NUM; state++) {
        for (int event = 0; event < Directory_Event_NUM; event++) {
            m_counters[state][event] = 0;
        }
    }

    for (int event = 0; event < Directory_Event_NUM; event++) {
        m_event_counters[event] = 0;
    }

    AbstractController::resetStats();
}

// Set and Reset for cache_entry variable
void
Directory_Controller::set_cache_entry(Directory_PfEntry*& m_cache_entry_ptr, AbstractCacheEntry* m_new_cache_entry)
{
  m_cache_entry_ptr = (Directory_PfEntry*)m_new_cache_entry;
}

void
Directory_Controller::unset_cache_entry(Directory_PfEntry*& m_cache_entry_ptr)
{
  m_cache_entry_ptr = 0;
}

// Set and Reset for tbe variable
void
Directory_Controller::set_tbe(Directory_TBE*& m_tbe_ptr, Directory_TBE* m_new_tbe)
{
  m_tbe_ptr = m_new_tbe;
}

void
Directory_Controller::unset_tbe(Directory_TBE*& m_tbe_ptr)
{
  m_tbe_ptr = NULL;
}

void
Directory_Controller::recordCacheTrace(int cntrl, CacheRecorder* tr)
{
    m_probeFilter_ptr->recordCacheContents(cntrl, tr);
}

// Actions
/** \brief manually set the MRU bit for pf entry */
void
Directory_Controller::r_setMRU(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing r_setMRU\n");
    try {
           if ((m_probe_filter_enabled || m_full_bit_dir_enabled)) {
        #ifndef NDEBUG
        if (!((m_cache_entry_ptr != NULL))) {
            panic("Runtime Error at MOESI_hammer-dir.sm:462: %s.\n", "assert failure");

        }
        #endif
        ;
        (((*m_probeFilter_ptr)).setMRU(addr));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:r_setMRU: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief assert unblocker not owner */
void
Directory_Controller::auno_assertUnblockerNotOwner(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing auno_assertUnblockerNotOwner\n");
    try {
           if ((m_probe_filter_enabled || m_full_bit_dir_enabled)) {
        #ifndef NDEBUG
        if (!((m_cache_entry_ptr != NULL))) {
            panic("Runtime Error at MOESI_hammer-dir.sm:469: %s.\n", "assert failure");

        }
        #endif
        ;
        {
            // Declare message
            [[maybe_unused]] const ResponseMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const ResponseMsg *>(((*m_unblockToDir_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        #ifndef NDEBUG
        if (!(((*m_cache_entry_ptr).m_Owner != ((*in_msg_ptr)).m_Sender))) {
            panic("Runtime Error at MOESI_hammer-dir.sm:471: %s.\n", "assert failure");

        }
        #endif
        ;
            if (m_full_bit_dir_enabled) {
                #ifndef NDEBUG
                if (!(((((*m_cache_entry_ptr).m_Sharers).isElement((machineIDToNodeID(((*in_msg_ptr)).m_Sender)))) == (false)))) {
                    panic("Runtime Error at MOESI_hammer-dir.sm:473: %s.\n", "assert failure");

                }
                #endif
                ;
            }
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:auno_assertUnblockerNotOwner: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief update owner */
void
Directory_Controller::uo_updateOwnerIfPf(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing uo_updateOwnerIfPf\n");
    try {
           if ((m_probe_filter_enabled || m_full_bit_dir_enabled)) {
        #ifndef NDEBUG
        if (!((m_cache_entry_ptr != NULL))) {
            panic("Runtime Error at MOESI_hammer-dir.sm:481: %s.\n", "assert failure");

        }
        #endif
        ;
        {
            // Declare message
            [[maybe_unused]] const ResponseMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const ResponseMsg *>(((*m_unblockToDir_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        (*m_cache_entry_ptr).m_Owner = ((*in_msg_ptr)).m_Sender;
            if (m_full_bit_dir_enabled) {
                (((*m_cache_entry_ptr).m_Sharers).clear());
                (((*m_cache_entry_ptr).m_Sharers).add((machineIDToNodeID(((*in_msg_ptr)).m_Sender))));
                APPEND_TRANSITION_COMMENT((*m_cache_entry_ptr).m_Sharers);
                DPRINTF(RubySlicc, "MOESI_hammer-dir.sm:488: Sharers = %d\n", (*m_cache_entry_ptr).m_Sharers);
            }
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:uo_updateOwnerIfPf: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief update sharer if full-bit directory */
void
Directory_Controller::us_updateSharerIfFBD(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing us_updateSharerIfFBD\n");
    try {
           if (m_full_bit_dir_enabled) {
        #ifndef NDEBUG
        if (!((((*m_probeFilter_ptr)).isTagPresent(addr)))) {
            panic("Runtime Error at MOESI_hammer-dir.sm:496: %s.\n", "assert failure");

        }
        #endif
        ;
        {
            // Declare message
            [[maybe_unused]] const ResponseMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const ResponseMsg *>(((*m_unblockToDir_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        (((*m_cache_entry_ptr).m_Sharers).add((machineIDToNodeID(((*in_msg_ptr)).m_Sender))));
        }
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:us_updateSharerIfFBD: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Send writeback ack to requestor */
void
Directory_Controller::a_sendWriteBackAck(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing a_sendWriteBackAck\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const RequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<RequestMsg> out_msg = std::make_shared<RequestMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_Type = CoherenceRequestType_WB_ACK;
    (*out_msg).m_Requestor = ((*in_msg_ptr)).m_Requestor;
    (((*out_msg).m_Destination).add(((*in_msg_ptr)).m_Requestor));
    (*out_msg).m_MessageSize = MessageSizeType_Writeback_Control;
    ((*m_forwardFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_from_memory_controller_latency)));
}
}

    } catch (const RejectException & e) {
       fatal("Error in action Directory:a_sendWriteBackAck: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Send block ack to the owner */
void
Directory_Controller::oc_sendBlockAck(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing oc_sendBlockAck\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const RequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if ((((m_probe_filter_enabled || m_full_bit_dir_enabled) && (((*in_msg_ptr)).m_Requestor == (*m_cache_entry_ptr).m_Owner)) || ((machineCount(MachineType_L1Cache)) == (1)))) {
        {
            std::shared_ptr<RequestMsg> out_msg = std::make_shared<RequestMsg>(clockEdge());
            (*out_msg).m_addr = addr;
            (*out_msg).m_Type = CoherenceRequestType_BLOCK_ACK;
            (*out_msg).m_Requestor = ((*in_msg_ptr)).m_Requestor;
            (((*out_msg).m_Destination).add(((*in_msg_ptr)).m_Requestor));
            (*out_msg).m_MessageSize = MessageSizeType_Writeback_Control;
            ((*m_forwardFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_from_memory_controller_latency)));
        }
    }
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:oc_sendBlockAck: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Send writeback nack to requestor */
void
Directory_Controller::b_sendWriteBackNack(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing b_sendWriteBackNack\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const RequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<RequestMsg> out_msg = std::make_shared<RequestMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_Type = CoherenceRequestType_WB_NACK;
    (*out_msg).m_Requestor = ((*in_msg_ptr)).m_Requestor;
    (((*out_msg).m_Destination).add(((*in_msg_ptr)).m_Requestor));
    (*out_msg).m_MessageSize = MessageSizeType_Writeback_Control;
    ((*m_forwardFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_from_memory_controller_latency)));
}
}

    } catch (const RejectException & e) {
       fatal("Error in action Directory:b_sendWriteBackNack: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Allocate ProbeFilterEntry */
void
Directory_Controller::pfa_probeFilterAllocate(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing pfa_probeFilterAllocate\n");
    try {
           if ((m_probe_filter_enabled || m_full_bit_dir_enabled)) {
        {
            // Declare message
            [[maybe_unused]] const RequestMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        set_cache_entry(m_cache_entry_ptr, (((*m_probeFilter_ptr)).allocate(addr, new Directory_PfEntry)));;
        (*m_cache_entry_ptr).m_Owner = ((*in_msg_ptr)).m_Requestor;
        (((*m_cache_entry_ptr).m_Sharers).setSize((machineCount(MachineType_L1Cache))));
        }
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:pfa_probeFilterAllocate: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Deallocate ProbeFilterEntry */
void
Directory_Controller::pfd_probeFilterDeallocate(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing pfd_probeFilterDeallocate\n");
    try {
           if ((m_probe_filter_enabled || m_full_bit_dir_enabled)) {
        (((*m_probeFilter_ptr)).deallocate(addr));
        unset_cache_entry(m_cache_entry_ptr);;
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:pfd_probeFilterDeallocate: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Deallocate ProbeFilterEntry */
void
Directory_Controller::ppfd_possibleProbeFilterDeallocate(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ppfd_possibleProbeFilterDeallocate\n");
    try {
           if (((m_probe_filter_enabled || m_full_bit_dir_enabled) && (m_cache_entry_ptr != NULL))) {
        (((*m_probeFilter_ptr)).deallocate(addr));
        unset_cache_entry(m_cache_entry_ptr);;
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:ppfd_possibleProbeFilterDeallocate: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Allocate TBE */
void
Directory_Controller::v_allocateTBE(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing v_allocateTBE\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const RequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
(((*m_TBEs_ptr)).allocate(addr));
set_tbe(m_tbe_ptr, (((*m_TBEs_ptr)).lookup(addr)));;
(*m_tbe_ptr).m_PhysicalAddress = addr;
(*m_tbe_ptr).m_ResponseType = CoherenceResponseType_NULL;
}

    } catch (const RejectException & e) {
       fatal("Error in action Directory:v_allocateTBE: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Record Data in TBE */
void
Directory_Controller::vd_allocateDmaRequestInTBE(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing vd_allocateDmaRequestInTBE\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const DMARequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const DMARequestMsg *>(((*m_dmaRequestToDir_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
(((*m_TBEs_ptr)).allocate(addr));
set_tbe(m_tbe_ptr, (((*m_TBEs_ptr)).lookup(addr)));;
(*m_tbe_ptr).m_DmaDataBlk = ((*in_msg_ptr)).m_DataBlk;
(*m_tbe_ptr).m_PhysicalAddress = ((*in_msg_ptr)).m_PhysicalAddress;
(*m_tbe_ptr).m_Len = ((*in_msg_ptr)).m_Len;
(*m_tbe_ptr).m_DmaRequestor = ((*in_msg_ptr)).m_Requestor;
(*m_tbe_ptr).m_ResponseType = CoherenceResponseType_DATA_EXCLUSIVE;
(*m_tbe_ptr).m_NumPendingMsgs = (machineCount(MachineType_L1Cache));
(*m_tbe_ptr).m_CacheDirty = (false);
}

    } catch (const RejectException & e) {
       fatal("Error in action Directory:vd_allocateDmaRequestInTBE: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief set pending msgs to all */
void
Directory_Controller::pa_setPendingMsgsToAll(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing pa_setPendingMsgsToAll\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:598: %s.\n", "assert failure");

}
#endif
;
    if (m_full_bit_dir_enabled) {
        #ifndef NDEBUG
        if (!((m_cache_entry_ptr != NULL))) {
            panic("Runtime Error at MOESI_hammer-dir.sm:600: %s.\n", "assert failure");

        }
        #endif
        ;
        (*m_tbe_ptr).m_NumPendingMsgs = (((*m_cache_entry_ptr).m_Sharers).count());
    } else {
        (*m_tbe_ptr).m_NumPendingMsgs = (machineCount(MachineType_L1Cache));
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:pa_setPendingMsgsToAll: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief set pending msgs to one */
void
Directory_Controller::po_setPendingMsgsToOne(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing po_setPendingMsgsToOne\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:608: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_NumPendingMsgs = (1);

    } catch (const RejectException & e) {
       fatal("Error in action Directory:po_setPendingMsgsToOne: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Deallocate TBE */
void
Directory_Controller::w_deallocateTBE(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing w_deallocateTBE\n");
    try {
       (((*m_TBEs_ptr)).deallocate(addr));
unset_tbe(m_tbe_ptr);;

    } catch (const RejectException & e) {
       fatal("Error in action Directory:w_deallocateTBE: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Forwarded request, set the ack amount to one */
void
Directory_Controller::sa_setAcksToOne(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing sa_setAcksToOne\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:618: %s.\n", "assert failure");

}
#endif
;
{
    // Declare message
    [[maybe_unused]] const RequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
    if (m_full_bit_dir_enabled) {
        #ifndef NDEBUG
        if (!((m_cache_entry_ptr != NULL))) {
            panic("Runtime Error at MOESI_hammer-dir.sm:621: %s.\n", "assert failure");

        }
        #endif
        ;
        (*m_fwd_set_ptr) = (*m_cache_entry_ptr).m_Sharers;
        (((*m_fwd_set_ptr)).remove((machineIDToNodeID(((*in_msg_ptr)).m_Requestor))));
            if (((((*m_fwd_set_ptr)).count()) > (0))) {
                (*m_tbe_ptr).m_Acks = (1);
                (*m_tbe_ptr).m_SilentAcks = ((machineCount(MachineType_L1Cache)) - (((*m_fwd_set_ptr)).count()));
                (*m_tbe_ptr).m_SilentAcks = ((*m_tbe_ptr).m_SilentAcks - (1));
            } else {
                (*m_tbe_ptr).m_Acks = (machineCount(MachineType_L1Cache));
                (*m_tbe_ptr).m_SilentAcks = (0);
            }
        } else {
            (*m_tbe_ptr).m_Acks = (1);
        }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:sa_setAcksToOne: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Non-forwarded request, set the ack amount to all */
void
Directory_Controller::saa_setAcksToAllIfPF(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing saa_setAcksToAllIfPF\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:643: %s.\n", "assert failure");

}
#endif
;
    if ((m_probe_filter_enabled || m_full_bit_dir_enabled)) {
        (*m_tbe_ptr).m_Acks = (machineCount(MachineType_L1Cache));
        (*m_tbe_ptr).m_SilentAcks = (0);
    } else {
        (*m_tbe_ptr).m_Acks = (1);
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:saa_setAcksToAllIfPF: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Decrement the number of messages for which we're waiting */
void
Directory_Controller::m_decrementNumberOfMessages(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing m_decrementNumberOfMessages\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const ResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const ResponseMsg *>(((*m_responseToDir_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
#ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:654: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*in_msg_ptr)).m_Acks > (0)))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:655: %s.\n", "assert failure");

}
#endif
;
DPRINTF(RubySlicc, "MOESI_hammer-dir.sm:656: %d\n", (*m_tbe_ptr).m_NumPendingMsgs);
    if ((((((*in_msg_ptr)).m_Type == CoherenceResponseType_DATA_SHARED) || (((*in_msg_ptr)).m_Type == CoherenceResponseType_DATA)) || (((*in_msg_ptr)).m_Type == CoherenceResponseType_DATA_EXCLUSIVE))) {
        (*m_tbe_ptr).m_NumPendingMsgs = ((*m_tbe_ptr).m_NumPendingMsgs - (1));
    } else {
        (*m_tbe_ptr).m_NumPendingMsgs = ((*m_tbe_ptr).m_NumPendingMsgs - ((*in_msg_ptr)).m_Acks);
    }
    DPRINTF(RubySlicc, "MOESI_hammer-dir.sm:669: %d\n", (*m_tbe_ptr).m_NumPendingMsgs);
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:m_decrementNumberOfMessages: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Decrement the number of messages for which we're waiting */
void
Directory_Controller::mu_decrementNumberOfUnblocks(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing mu_decrementNumberOfUnblocks\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const ResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const ResponseMsg *>(((*m_unblockToDir_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
#ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:675: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*in_msg_ptr)).m_Type == CoherenceResponseType_UNBLOCKS))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:676: %s.\n", "assert failure");

}
#endif
;
DPRINTF(RubySlicc, "MOESI_hammer-dir.sm:677: %d\n", (*m_tbe_ptr).m_NumPendingMsgs);
(*m_tbe_ptr).m_NumPendingMsgs = ((*m_tbe_ptr).m_NumPendingMsgs - (1));
DPRINTF(RubySlicc, "MOESI_hammer-dir.sm:679: %d\n", (*m_tbe_ptr).m_NumPendingMsgs);
}

    } catch (const RejectException & e) {
       fatal("Error in action Directory:mu_decrementNumberOfUnblocks: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Pop response queue */
void
Directory_Controller::n_popResponseQueue(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing n_popResponseQueue\n");
    try {
       (((*m_responseToDir_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Directory:n_popResponseQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Check if we have received all the messages required for completion */
void
Directory_Controller::o_checkForCompletion(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing o_checkForCompletion\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:688: %s.\n", "assert failure");

}
#endif
;
    if (((*m_tbe_ptr).m_NumPendingMsgs == (0))) {
        {
            std::shared_ptr<TriggerMsg> out_msg = std::make_shared<TriggerMsg>(clockEdge());
            (*out_msg).m_addr = addr;
                if ((*m_tbe_ptr).m_Sharers) {
                        if ((*m_tbe_ptr).m_Owned) {
                            (*out_msg).m_Type = TriggerType_ALL_ACKS_OWNER_EXISTS;
                        } else {
                            (*out_msg).m_Type = TriggerType_ALL_ACKS;
                        }
                    } else {
                        (*out_msg).m_Type = TriggerType_ALL_ACKS_NO_SHARERS;
                    }
                    ((*m_triggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(1)));
                }
            }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:o_checkForCompletion: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Check for merged GETS completion */
void
Directory_Controller::os_checkForMergedGetSCompletion(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing os_checkForMergedGetSCompletion\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:706: %s.\n", "assert failure");

}
#endif
;
    if (((*m_tbe_ptr).m_NumPendingMsgs == (0))) {
        {
            std::shared_ptr<TriggerMsg> out_msg = std::make_shared<TriggerMsg>(clockEdge());
            (*out_msg).m_addr = addr;
            (*out_msg).m_Type = TriggerType_ALL_UNBLOCKS;
            ((*m_triggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(1)));
        }
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:os_checkForMergedGetSCompletion: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Set pending messages to waiting sharers */
void
Directory_Controller::sp_setPendingMsgsToMergedSharers(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing sp_setPendingMsgsToMergedSharers\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:716: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_NumPendingMsgs = (((*m_tbe_ptr).m_GetSRequestors).count());

    } catch (const RejectException & e) {
       fatal("Error in action Directory:sp_setPendingMsgsToMergedSharers: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief if probe filter, no need to wait for acks */
void
Directory_Controller::spa_setPendingAcksToZeroIfPF(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing spa_setPendingAcksToZeroIfPF\n");
    try {
           if ((m_probe_filter_enabled || m_full_bit_dir_enabled)) {
        #ifndef NDEBUG
        if (!((m_tbe_ptr != NULL))) {
            panic("Runtime Error at MOESI_hammer-dir.sm:722: %s.\n", "assert failure");

        }
        #endif
        ;
        (*m_tbe_ptr).m_NumPendingMsgs = (0);
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:spa_setPendingAcksToZeroIfPF: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief indicate that we should skip waiting for cpu acks */
void
Directory_Controller::sc_signalCompletionIfPF(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing sc_signalCompletionIfPF\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:728: %s.\n", "assert failure");

}
#endif
;
    if (((*m_tbe_ptr).m_NumPendingMsgs == (0))) {
        #ifndef NDEBUG
        if (!((m_probe_filter_enabled || m_full_bit_dir_enabled))) {
            panic("Runtime Error at MOESI_hammer-dir.sm:730: %s.\n", "assert failure");

        }
        #endif
        ;
        {
            std::shared_ptr<TriggerMsg> out_msg = std::make_shared<TriggerMsg>(clockEdge());
            (*out_msg).m_addr = addr;
            (*out_msg).m_Type = TriggerType_ALL_ACKS_NO_SHARERS;
            ((*m_triggerQueue_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(1)));
        }
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:sc_signalCompletionIfPF: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Send data to requestor */
void
Directory_Controller::d_sendData(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing d_sendData\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const MemoryMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const MemoryMsg *>(((*m_responseFromMemory_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<ResponseMsg> out_msg = std::make_shared<ResponseMsg>(clockEdge());
    #ifndef NDEBUG
    if (!((m_tbe_ptr != NULL))) {
        panic("Runtime Error at MOESI_hammer-dir.sm:741: %s.\n", "assert failure");

    }
    #endif
    ;
    (*out_msg).m_addr = addr;
    (*out_msg).m_Type = (*m_tbe_ptr).m_ResponseType;
    (*out_msg).m_Sender = m_machineID;
    (((*out_msg).m_Destination).add(((*in_msg_ptr)).m_OriginalRequestorMachId));
    (*out_msg).m_DataBlk = ((*in_msg_ptr)).m_DataBlk;
    DPRINTF(RubySlicc, "MOESI_hammer-dir.sm:747: %s\n", (*out_msg).m_DataBlk);
    (*out_msg).m_Dirty = (false);
    (*out_msg).m_Acks = (*m_tbe_ptr).m_Acks;
    (*out_msg).m_SilentAcks = (*m_tbe_ptr).m_SilentAcks;
    DPRINTF(RubySlicc, "MOESI_hammer-dir.sm:751: %d\n", (*out_msg).m_Acks);
    #ifndef NDEBUG
    if (!(((*out_msg).m_Acks > (0)))) {
        panic("Runtime Error at MOESI_hammer-dir.sm:752: %s.\n", "assert failure");

    }
    #endif
    ;
    (*out_msg).m_MessageSize = MessageSizeType_Response_Data;
    ((*m_responseFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((1))));
}
}

    } catch (const RejectException & e) {
       fatal("Error in action Directory:d_sendData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Send Data to DMA controller from memory */
void
Directory_Controller::dr_sendDmaData(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing dr_sendDmaData\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const MemoryMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const MemoryMsg *>(((*m_responseFromMemory_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<DMAResponseMsg> out_msg = std::make_shared<DMAResponseMsg>(clockEdge());
    #ifndef NDEBUG
    if (!((m_tbe_ptr != NULL))) {
        panic("Runtime Error at MOESI_hammer-dir.sm:761: %s.\n", "assert failure");

    }
    #endif
    ;
    (*out_msg).m_PhysicalAddress = addr;
    (*out_msg).m_LineAddress = addr;
    (*out_msg).m_Type = DMAResponseType_DATA;
    (*out_msg).m_DataBlk = ((*in_msg_ptr)).m_DataBlk;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_DmaRequestor));
    (*out_msg).m_MessageSize = MessageSizeType_Response_Data;
    ((*m_dmaResponseFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((1))));
}
}

    } catch (const RejectException & e) {
       fatal("Error in action Directory:dr_sendDmaData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Send Data to DMA controller from tbe */
void
Directory_Controller::dt_sendDmaDataFromTbe(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing dt_sendDmaDataFromTbe\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const TriggerMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const TriggerMsg *>(((*m_triggerQueue_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<DMAResponseMsg> out_msg = std::make_shared<DMAResponseMsg>(clockEdge());
    #ifndef NDEBUG
    if (!((m_tbe_ptr != NULL))) {
        panic("Runtime Error at MOESI_hammer-dir.sm:779: %s.\n", "assert failure");

    }
    #endif
    ;
    (*out_msg).m_PhysicalAddress = addr;
    (*out_msg).m_LineAddress = addr;
    (*out_msg).m_Type = DMAResponseType_DATA;
    (*out_msg).m_DataBlk = (*m_tbe_ptr).m_DataBlk;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_DmaRequestor));
    (*out_msg).m_MessageSize = MessageSizeType_Response_Data;
    ((*m_dmaResponseFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((1))));
}
}

    } catch (const RejectException & e) {
       fatal("Error in action Directory:dt_sendDmaDataFromTbe: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Send Ack to DMA controller */
void
Directory_Controller::da_sendDmaAck(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing da_sendDmaAck\n");
    try {
       {
    std::shared_ptr<DMAResponseMsg> out_msg = std::make_shared<DMAResponseMsg>(clockEdge());
    #ifndef NDEBUG
    if (!((m_tbe_ptr != NULL))) {
        panic("Runtime Error at MOESI_hammer-dir.sm:796: %s.\n", "assert failure");

    }
    #endif
    ;
    (*out_msg).m_PhysicalAddress = addr;
    (*out_msg).m_LineAddress = addr;
    (*out_msg).m_Type = DMAResponseType_ACK;
    (((*out_msg).m_Destination).add((*m_tbe_ptr).m_DmaRequestor));
    (*out_msg).m_MessageSize = MessageSizeType_Writeback_Control;
    ((*m_dmaResponseFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((1))));
}

    } catch (const RejectException & e) {
       fatal("Error in action Directory:da_sendDmaAck: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Record Exclusive in TBE */
void
Directory_Controller::rx_recordExclusiveInTBE(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing rx_recordExclusiveInTBE\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const RequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
#ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:807: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_ResponseType = CoherenceResponseType_DATA_EXCLUSIVE;
}

    } catch (const RejectException & e) {
       fatal("Error in action Directory:rx_recordExclusiveInTBE: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Record Data in TBE */
void
Directory_Controller::r_recordDataInTBE(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing r_recordDataInTBE\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const RequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
#ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:814: %s.\n", "assert failure");

}
#endif
;
    if (m_full_bit_dir_enabled) {
        (*m_fwd_set_ptr) = (*m_cache_entry_ptr).m_Sharers;
        (((*m_fwd_set_ptr)).remove((machineIDToNodeID(((*in_msg_ptr)).m_Requestor))));
            if (((((*m_fwd_set_ptr)).count()) > (0))) {
                (*m_tbe_ptr).m_ResponseType = CoherenceResponseType_DATA;
            } else {
                (*m_tbe_ptr).m_ResponseType = CoherenceResponseType_DATA_EXCLUSIVE;
            }
        } else {
            (*m_tbe_ptr).m_ResponseType = CoherenceResponseType_DATA;
        }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:r_recordDataInTBE: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Record GETS requestor in TBE */
void
Directory_Controller::rs_recordGetSRequestor(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing rs_recordGetSRequestor\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const RequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
#ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:831: %s.\n", "assert failure");

}
#endif
;
(((*m_tbe_ptr).m_GetSRequestors).add(((*in_msg_ptr)).m_Requestor));
}

    } catch (const RejectException & e) {
       fatal("Error in action Directory:rs_recordGetSRequestor: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief We saw other sharers */
void
Directory_Controller::r_setSharerBit(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing r_setSharerBit\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:837: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_Sharers = (true);

    } catch (const RejectException & e) {
       fatal("Error in action Directory:r_setSharerBit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief We saw other sharers */
void
Directory_Controller::so_setOwnerBit(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing so_setOwnerBit\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:842: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_Sharers = (true);
(*m_tbe_ptr).m_Owned = (true);

    } catch (const RejectException & e) {
       fatal("Error in action Directory:so_setOwnerBit: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Queue off-chip fetch request */
void
Directory_Controller::qf_queueMemoryFetchRequest(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing qf_queueMemoryFetchRequest\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const RequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<MemoryMsg> out_msg = std::make_shared<MemoryMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_Type = MemoryRequestType_MEMORY_READ;
    (*out_msg).m_Sender = ((*in_msg_ptr)).m_Requestor;
    (*out_msg).m_MessageSize = MessageSizeType_Request_Control;
    (*out_msg).m_Len = (0);
    ((*m_requestToMemory_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_to_memory_controller_latency)));
}
}

    } catch (const RejectException & e) {
       fatal("Error in action Directory:qf_queueMemoryFetchRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Queue off-chip fetch request */
void
Directory_Controller::qd_queueMemoryRequestFromDmaRead(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing qd_queueMemoryRequestFromDmaRead\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const DMARequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const DMARequestMsg *>(((*m_dmaRequestToDir_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<MemoryMsg> out_msg = std::make_shared<MemoryMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_Type = MemoryRequestType_MEMORY_READ;
    (*out_msg).m_Sender = ((*in_msg_ptr)).m_Requestor;
    (*out_msg).m_MessageSize = MessageSizeType_Request_Control;
    (*out_msg).m_Len = (0);
    ((*m_requestToMemory_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_to_memory_controller_latency)));
}
}

    } catch (const RejectException & e) {
       fatal("Error in action Directory:qd_queueMemoryRequestFromDmaRead: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Forward requests if necessary */
void
Directory_Controller::fn_forwardRequestIfNecessary(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing fn_forwardRequestIfNecessary\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:872: %s.\n", "assert failure");

}
#endif
;
    if ((((machineCount(MachineType_L1Cache)) > (1)) && ((*m_tbe_ptr).m_Acks <= (1)))) {
            if (m_full_bit_dir_enabled) {
                #ifndef NDEBUG
                if (!((m_cache_entry_ptr != NULL))) {
                    panic("Runtime Error at MOESI_hammer-dir.sm:875: %s.\n", "assert failure");

                }
                #endif
                ;
                {
                    // Declare message
                    [[maybe_unused]] const RequestMsg* in_msg_ptr;
                    in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
                    if (in_msg_ptr == NULL) {
                        // If the cast fails, this is the wrong inport (wrong message type).
                        // Throw an exception, and the caller will decide to either try a
                        // different inport or punt.
                        throw RejectException();
                    }
                (*m_fwd_set_ptr) = (*m_cache_entry_ptr).m_Sharers;
                (((*m_fwd_set_ptr)).remove((machineIDToNodeID(((*in_msg_ptr)).m_Requestor))));
                    if (((((*m_fwd_set_ptr)).count()) > (0))) {
                        {
                            std::shared_ptr<RequestMsg> out_msg = std::make_shared<RequestMsg>(clockEdge());
                            (*out_msg).m_addr = addr;
                            (*out_msg).m_Type = ((*in_msg_ptr)).m_Type;
                            (*out_msg).m_Requestor = ((*in_msg_ptr)).m_Requestor;
                            (((*out_msg).m_Destination).setNetDest(MachineType_L1Cache, (*m_fwd_set_ptr)));
                            (*out_msg).m_MessageSize = MessageSizeType_Multicast_Control;
                            (*out_msg).m_InitialRequestTime = ((*in_msg_ptr)).m_InitialRequestTime;
                            (*out_msg).m_ForwardRequestTime = (curCycle());
                            #ifndef NDEBUG
                            if (!(((*m_tbe_ptr).m_SilentAcks > (0)))) {
                                panic("Runtime Error at MOESI_hammer-dir.sm:888: %s.\n", "assert failure");

                            }
                            #endif
                            ;
                            (*out_msg).m_SilentAcks = (*m_tbe_ptr).m_SilentAcks;
                            ((*m_forwardFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_from_memory_controller_latency)));
                        }
                    }
                    }
                } else {
                    {
                        // Declare message
                        [[maybe_unused]] const RequestMsg* in_msg_ptr;
                        in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
                        if (in_msg_ptr == NULL) {
                            // If the cast fails, this is the wrong inport (wrong message type).
                            // Throw an exception, and the caller will decide to either try a
                            // different inport or punt.
                            throw RejectException();
                        }
                    {
                        std::shared_ptr<RequestMsg> out_msg = std::make_shared<RequestMsg>(clockEdge());
                        (*out_msg).m_addr = addr;
                        (*out_msg).m_Type = ((*in_msg_ptr)).m_Type;
                        (*out_msg).m_Requestor = ((*in_msg_ptr)).m_Requestor;
                        (((*out_msg).m_Destination).broadcast(MachineType_L1Cache));
                        (((*out_msg).m_Destination).remove(((*in_msg_ptr)).m_Requestor));
                        (*out_msg).m_MessageSize = MessageSizeType_Broadcast_Control;
                        (*out_msg).m_InitialRequestTime = ((*in_msg_ptr)).m_InitialRequestTime;
                        (*out_msg).m_ForwardRequestTime = (curCycle());
                        ((*m_forwardFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_from_memory_controller_latency)));
                    }
                    }
                }
            }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:fn_forwardRequestIfNecessary: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief invalidate all copies */
void
Directory_Controller::ia_invalidateAllRequest(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ia_invalidateAllRequest\n");
    try {
           if (((machineCount(MachineType_L1Cache)) > (1))) {
            if (m_full_bit_dir_enabled) {
                #ifndef NDEBUG
                if (!(((((*m_cache_entry_ptr).m_Sharers).count()) > (0)))) {
                    panic("Runtime Error at MOESI_hammer-dir.sm:913: %s.\n", "assert failure");

                }
                #endif
                ;
                {
                    // Declare message
                    [[maybe_unused]] const RequestMsg* in_msg_ptr;
                    in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
                    if (in_msg_ptr == NULL) {
                        // If the cast fails, this is the wrong inport (wrong message type).
                        // Throw an exception, and the caller will decide to either try a
                        // different inport or punt.
                        throw RejectException();
                    }
                {
                    std::shared_ptr<RequestMsg> out_msg = std::make_shared<RequestMsg>(clockEdge());
                    (*out_msg).m_addr = addr;
                    (*out_msg).m_Type = CoherenceRequestType_INV;
                    (*out_msg).m_Requestor = m_machineID;
                    (((*out_msg).m_Destination).setNetDest(MachineType_L1Cache, (*m_cache_entry_ptr).m_Sharers));
                    (*out_msg).m_MessageSize = MessageSizeType_Multicast_Control;
                    ((*m_forwardFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_from_memory_controller_latency)));
                }
                }
            } else {
                {
                    std::shared_ptr<RequestMsg> out_msg = std::make_shared<RequestMsg>(clockEdge());
                    (*out_msg).m_addr = addr;
                    (*out_msg).m_Type = CoherenceRequestType_INV;
                    (*out_msg).m_Requestor = m_machineID;
                    (((*out_msg).m_Destination).broadcast(MachineType_L1Cache));
                    (*out_msg).m_MessageSize = MessageSizeType_Broadcast_Control;
                    ((*m_forwardFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_from_memory_controller_latency)));
                }
            }
        }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:ia_invalidateAllRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief invalidate all copies */
void
Directory_Controller::io_invalidateOwnerRequest(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing io_invalidateOwnerRequest\n");
    try {
           if (((machineCount(MachineType_L1Cache)) > (1))) {
        {
            std::shared_ptr<RequestMsg> out_msg = std::make_shared<RequestMsg>(clockEdge());
            #ifndef NDEBUG
            if (!((m_cache_entry_ptr != NULL))) {
                panic("Runtime Error at MOESI_hammer-dir.sm:938: %s.\n", "assert failure");

            }
            #endif
            ;
            (*out_msg).m_addr = addr;
            (*out_msg).m_Type = CoherenceRequestType_INV;
            (*out_msg).m_Requestor = m_machineID;
            (((*out_msg).m_Destination).add((*m_cache_entry_ptr).m_Owner));
            (*out_msg).m_MessageSize = MessageSizeType_Request_Control;
            (*out_msg).m_DirectedProbe = (true);
            ((*m_forwardFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_from_memory_controller_latency)));
        }
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:io_invalidateOwnerRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Forward requests to all nodes */
void
Directory_Controller::fb_forwardRequestBcast(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing fb_forwardRequestBcast\n");
    try {
           if (((machineCount(MachineType_L1Cache)) > (1))) {
        {
            // Declare message
            [[maybe_unused]] const RequestMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
            if (m_full_bit_dir_enabled) {
                (*m_fwd_set_ptr) = (*m_cache_entry_ptr).m_Sharers;
                (((*m_fwd_set_ptr)).remove((machineIDToNodeID(((*in_msg_ptr)).m_Requestor))));
                    if (((((*m_fwd_set_ptr)).count()) > (0))) {
                        {
                            std::shared_ptr<RequestMsg> out_msg = std::make_shared<RequestMsg>(clockEdge());
                            (*out_msg).m_addr = addr;
                            (*out_msg).m_Type = ((*in_msg_ptr)).m_Type;
                            (*out_msg).m_Requestor = ((*in_msg_ptr)).m_Requestor;
                            (((*out_msg).m_Destination).setNetDest(MachineType_L1Cache, (*m_fwd_set_ptr)));
                            (*out_msg).m_MessageSize = MessageSizeType_Multicast_Control;
                            (*out_msg).m_InitialRequestTime = ((*in_msg_ptr)).m_InitialRequestTime;
                            (*out_msg).m_ForwardRequestTime = (curCycle());
                            (*out_msg).m_SilentAcks = ((machineCount(MachineType_L1Cache)) - (((*m_fwd_set_ptr)).count()));
                            (*out_msg).m_SilentAcks = ((*out_msg).m_SilentAcks - (1));
                            ((*m_forwardFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_from_memory_controller_latency)));
                        }
                    }
                } else {
                    {
                        std::shared_ptr<RequestMsg> out_msg = std::make_shared<RequestMsg>(clockEdge());
                        (*out_msg).m_addr = addr;
                        (*out_msg).m_Type = ((*in_msg_ptr)).m_Type;
                        (*out_msg).m_Requestor = ((*in_msg_ptr)).m_Requestor;
                        (((*out_msg).m_Destination).broadcast(MachineType_L1Cache));
                        (((*out_msg).m_Destination).remove(((*in_msg_ptr)).m_Requestor));
                        (*out_msg).m_MessageSize = MessageSizeType_Broadcast_Control;
                        (*out_msg).m_InitialRequestTime = ((*in_msg_ptr)).m_InitialRequestTime;
                        (*out_msg).m_ForwardRequestTime = (curCycle());
                        ((*m_forwardFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_from_memory_controller_latency)));
                    }
                }
                }
            } else {
                {
                    // Declare message
                    [[maybe_unused]] const RequestMsg* in_msg_ptr;
                    in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
                    if (in_msg_ptr == NULL) {
                        // If the cast fails, this is the wrong inport (wrong message type).
                        // Throw an exception, and the caller will decide to either try a
                        // different inport or punt.
                        throw RejectException();
                    }
                {
                    std::shared_ptr<ResponseMsg> out_msg = std::make_shared<ResponseMsg>(clockEdge());
                    (*out_msg).m_addr = addr;
                    (*out_msg).m_Type = CoherenceResponseType_ACK;
                    (*out_msg).m_Sender = m_machineID;
                    (((*out_msg).m_Destination).add(((*in_msg_ptr)).m_Requestor));
                    (*out_msg).m_Dirty = (false);
                    (*out_msg).m_Acks = (0);
                    (*out_msg).m_SilentAcks = (0);
                    DPRINTF(RubySlicc, "MOESI_hammer-dir.sm:991: %d\n", (*out_msg).m_Acks);
                    (*out_msg).m_MessageSize = MessageSizeType_Response_Control;
                    ((*m_responseFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles((1))));
                }
                }
            }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:fb_forwardRequestBcast: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Forward coalesced read request to owner */
void
Directory_Controller::fr_forwardMergeReadRequestsToOwner(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing fr_forwardMergeReadRequestsToOwner\n");
    try {
       #ifndef NDEBUG
if (!(((machineCount(MachineType_L1Cache)) > (1)))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:999: %s.\n", "assert failure");

}
#endif
;
{
    // Declare message
    [[maybe_unused]] const ResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const ResponseMsg *>(((*m_unblockToDir_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<RequestMsg> out_msg = std::make_shared<RequestMsg>(clockEdge());
    #ifndef NDEBUG
    if (!((m_tbe_ptr != NULL))) {
        panic("Runtime Error at MOESI_hammer-dir.sm:1006: %s.\n", "assert failure");

    }
    #endif
    ;
    (*out_msg).m_addr = addr;
    (*out_msg).m_Type = CoherenceRequestType_MERGED_GETS;
    (*out_msg).m_MergedRequestors = (*m_tbe_ptr).m_GetSRequestors;
        if ((((*in_msg_ptr)).m_Type == CoherenceResponseType_UNBLOCKS)) {
            (((*out_msg).m_Destination).add(((*in_msg_ptr)).m_CurOwner));
        } else {
            (((*out_msg).m_Destination).add(((*in_msg_ptr)).m_Sender));
        }
        (*out_msg).m_MessageSize = MessageSizeType_Request_Control;
        (*out_msg).m_InitialRequestTime = (zero_time());
        (*out_msg).m_ForwardRequestTime = (curCycle());
        ((*m_forwardFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_from_memory_controller_latency)));
    }
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:fr_forwardMergeReadRequestsToOwner: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Forward request to one or more nodes */
void
Directory_Controller::fc_forwardRequestConditionalOwner(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing fc_forwardRequestConditionalOwner\n");
    try {
       #ifndef NDEBUG
if (!(((machineCount(MachineType_L1Cache)) > (1)))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:1023: %s.\n", "assert failure");

}
#endif
;
    if ((m_probe_filter_enabled || m_full_bit_dir_enabled)) {
        {
            // Declare message
            [[maybe_unused]] const RequestMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        {
            std::shared_ptr<RequestMsg> out_msg = std::make_shared<RequestMsg>(clockEdge());
            #ifndef NDEBUG
            if (!((m_cache_entry_ptr != NULL))) {
                panic("Runtime Error at MOESI_hammer-dir.sm:1027: %s.\n", "assert failure");

            }
            #endif
            ;
            (*out_msg).m_addr = addr;
            (*out_msg).m_Type = ((*in_msg_ptr)).m_Type;
            (*out_msg).m_Requestor = ((*in_msg_ptr)).m_Requestor;
            (((*out_msg).m_Destination).add((*m_cache_entry_ptr).m_Owner));
            (*out_msg).m_MessageSize = MessageSizeType_Request_Control;
            (*out_msg).m_DirectedProbe = (true);
            (*out_msg).m_InitialRequestTime = ((*in_msg_ptr)).m_InitialRequestTime;
            (*out_msg).m_ForwardRequestTime = (curCycle());
            ((*m_forwardFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_from_memory_controller_latency)));
        }
        }
    } else {
        {
            // Declare message
            [[maybe_unused]] const RequestMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        {
            std::shared_ptr<RequestMsg> out_msg = std::make_shared<RequestMsg>(clockEdge());
            (*out_msg).m_addr = addr;
            (*out_msg).m_Type = ((*in_msg_ptr)).m_Type;
            (*out_msg).m_Requestor = ((*in_msg_ptr)).m_Requestor;
            (((*out_msg).m_Destination).broadcast(MachineType_L1Cache));
            (((*out_msg).m_Destination).remove(((*in_msg_ptr)).m_Requestor));
            (*out_msg).m_MessageSize = MessageSizeType_Broadcast_Control;
            (*out_msg).m_InitialRequestTime = ((*in_msg_ptr)).m_InitialRequestTime;
            (*out_msg).m_ForwardRequestTime = (curCycle());
            ((*m_forwardFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_from_memory_controller_latency)));
        }
        }
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:fc_forwardRequestConditionalOwner: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Forward request to one or more nodes if the requestor is not the owner */
void
Directory_Controller::nofc_forwardRequestConditionalOwner(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing nofc_forwardRequestConditionalOwner\n");
    try {
           if (((machineCount(MachineType_L1Cache)) > (1))) {
            if ((m_probe_filter_enabled || m_full_bit_dir_enabled)) {
                {
                    // Declare message
                    [[maybe_unused]] const RequestMsg* in_msg_ptr;
                    in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
                    if (in_msg_ptr == NULL) {
                        // If the cast fails, this is the wrong inport (wrong message type).
                        // Throw an exception, and the caller will decide to either try a
                        // different inport or punt.
                        throw RejectException();
                    }
                    if ((((*in_msg_ptr)).m_Requestor != (*m_cache_entry_ptr).m_Owner)) {
                        {
                            std::shared_ptr<RequestMsg> out_msg = std::make_shared<RequestMsg>(clockEdge());
                            #ifndef NDEBUG
                            if (!((m_cache_entry_ptr != NULL))) {
                                panic("Runtime Error at MOESI_hammer-dir.sm:1061: %s.\n", "assert failure");

                            }
                            #endif
                            ;
                            (*out_msg).m_addr = addr;
                            (*out_msg).m_Type = ((*in_msg_ptr)).m_Type;
                            (*out_msg).m_Requestor = ((*in_msg_ptr)).m_Requestor;
                            (((*out_msg).m_Destination).add((*m_cache_entry_ptr).m_Owner));
                            (*out_msg).m_MessageSize = MessageSizeType_Request_Control;
                            (*out_msg).m_DirectedProbe = (true);
                            (*out_msg).m_InitialRequestTime = ((*in_msg_ptr)).m_InitialRequestTime;
                            (*out_msg).m_ForwardRequestTime = (curCycle());
                            ((*m_forwardFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_from_memory_controller_latency)));
                        }
                    }
                    }
                } else {
                    {
                        // Declare message
                        [[maybe_unused]] const RequestMsg* in_msg_ptr;
                        in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
                        if (in_msg_ptr == NULL) {
                            // If the cast fails, this is the wrong inport (wrong message type).
                            // Throw an exception, and the caller will decide to either try a
                            // different inport or punt.
                            throw RejectException();
                        }
                    {
                        std::shared_ptr<RequestMsg> out_msg = std::make_shared<RequestMsg>(clockEdge());
                        (*out_msg).m_addr = addr;
                        (*out_msg).m_Type = ((*in_msg_ptr)).m_Type;
                        (*out_msg).m_Requestor = ((*in_msg_ptr)).m_Requestor;
                        (((*out_msg).m_Destination).broadcast(MachineType_L1Cache));
                        (((*out_msg).m_Destination).remove(((*in_msg_ptr)).m_Requestor));
                        (*out_msg).m_MessageSize = MessageSizeType_Broadcast_Control;
                        (*out_msg).m_InitialRequestTime = ((*in_msg_ptr)).m_InitialRequestTime;
                        (*out_msg).m_ForwardRequestTime = (curCycle());
                        ((*m_forwardFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_from_memory_controller_latency)));
                    }
                    }
                }
            }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:nofc_forwardRequestConditionalOwner: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Forward requests */
void
Directory_Controller::f_forwardWriteFromDma(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing f_forwardWriteFromDma\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:1091: %s.\n", "assert failure");

}
#endif
;
    if (((*m_tbe_ptr).m_NumPendingMsgs > (0))) {
        {
            // Declare message
            [[maybe_unused]] const DMARequestMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const DMARequestMsg *>(((*m_dmaRequestToDir_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        {
            std::shared_ptr<RequestMsg> out_msg = std::make_shared<RequestMsg>(clockEdge());
            (*out_msg).m_addr = addr;
            (*out_msg).m_Type = CoherenceRequestType_GETX;
            (*out_msg).m_Requestor = m_machineID;
            (((*out_msg).m_Destination).broadcast(MachineType_L1Cache));
            (*out_msg).m_MessageSize = MessageSizeType_Broadcast_Control;
            ((*m_forwardFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_from_memory_controller_latency)));
        }
        }
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:f_forwardWriteFromDma: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Forward requests */
void
Directory_Controller::f_forwardReadFromDma(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing f_forwardReadFromDma\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:1110: %s.\n", "assert failure");

}
#endif
;
    if (((*m_tbe_ptr).m_NumPendingMsgs > (0))) {
        {
            // Declare message
            [[maybe_unused]] const DMARequestMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const DMARequestMsg *>(((*m_dmaRequestToDir_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        {
            std::shared_ptr<RequestMsg> out_msg = std::make_shared<RequestMsg>(clockEdge());
            (*out_msg).m_addr = addr;
            (*out_msg).m_Type = CoherenceRequestType_GETS;
            (*out_msg).m_Requestor = m_machineID;
            (((*out_msg).m_Destination).broadcast(MachineType_L1Cache));
            (*out_msg).m_MessageSize = MessageSizeType_Broadcast_Control;
            ((*m_forwardFromDir_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_from_memory_controller_latency)));
        }
        }
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:f_forwardReadFromDma: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Pop incoming request queue */
void
Directory_Controller::i_popIncomingRequestQueue(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing i_popIncomingRequestQueue\n");
    try {
       (((*m_requestToDir_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Directory:i_popIncomingRequestQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Pop incoming unblock queue */
void
Directory_Controller::j_popIncomingUnblockQueue(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing j_popIncomingUnblockQueue\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const ResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const ResponseMsg *>(((*m_unblockToDir_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
APPEND_TRANSITION_COMMENT(((*in_msg_ptr)).m_Sender);
}
(((*m_unblockToDir_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Directory:j_popIncomingUnblockQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief wake-up dependents */
void
Directory_Controller::k_wakeUpDependents(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing k_wakeUpDependents\n");
    try {
       (wakeUpBuffers(addr));

    } catch (const RejectException & e) {
       fatal("Error in action Directory:k_wakeUpDependents: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Pop off-chip request queue */
void
Directory_Controller::l_popMemQueue(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing l_popMemQueue\n");
    try {
       (((*m_responseFromMemory_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Directory:l_popMemQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Pop trigger queue */
void
Directory_Controller::g_popTriggerQueue(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing g_popTriggerQueue\n");
    try {
       (((*m_triggerQueue_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Directory:g_popTriggerQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief pop dma request queue */
void
Directory_Controller::p_popDmaRequestQueue(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing p_popDmaRequestQueue\n");
    try {
       (((*m_dmaRequestToDir_ptr)).dequeue((clockEdge())));

    } catch (const RejectException & e) {
       fatal("Error in action Directory:p_popDmaRequestQueue: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Stall and wait the dma request queue */
void
Directory_Controller::zd_stallAndWaitDMARequest(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing zd_stallAndWaitDMARequest\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const DMARequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const DMARequestMsg *>(((*m_dmaRequestToDir_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
APPEND_TRANSITION_COMMENT(((*in_msg_ptr)).m_Requestor);
}
        stallBuffer(&((*m_dmaRequestToDir_ptr)), addr);
        (*m_dmaRequestToDir_ptr).stallMessage(addr, clockEdge());
        

    } catch (const RejectException & e) {
       fatal("Error in action Directory:zd_stallAndWaitDMARequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief record data from memory to TBE */
void
Directory_Controller::r_recordMemoryData(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing r_recordMemoryData\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const MemoryMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const MemoryMsg *>(((*m_responseFromMemory_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
#ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:1164: %s.\n", "assert failure");

}
#endif
;
    if (((*m_tbe_ptr).m_CacheDirty == (false))) {
        (*m_tbe_ptr).m_DataBlk = ((*in_msg_ptr)).m_DataBlk;
    }
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:r_recordMemoryData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief record data from cache response to TBE */
void
Directory_Controller::r_recordCacheData(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing r_recordCacheData\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const ResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const ResponseMsg *>(((*m_responseToDir_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
#ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:1173: %s.\n", "assert failure");

}
#endif
;
(*m_tbe_ptr).m_CacheDirty = (true);
(*m_tbe_ptr).m_DataBlk = ((*in_msg_ptr)).m_DataBlk;
}

    } catch (const RejectException & e) {
       fatal("Error in action Directory:r_recordCacheData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Assert that a cache provided the data */
void
Directory_Controller::a_assertCacheData(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing a_assertCacheData\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:1180: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((*m_tbe_ptr).m_CacheDirty)) {
    panic("Runtime Error at MOESI_hammer-dir.sm:1181: %s.\n", "assert failure");

}
#endif
;

    } catch (const RejectException & e) {
       fatal("Error in action Directory:a_assertCacheData: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Assert that request is not current owner */
void
Directory_Controller::ano_assertNotOwner(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ano_assertNotOwner\n");
    try {
           if ((m_probe_filter_enabled || m_full_bit_dir_enabled)) {
        {
            // Declare message
            [[maybe_unused]] const RequestMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        #ifndef NDEBUG
        if (!((m_cache_entry_ptr != NULL))) {
            panic("Runtime Error at MOESI_hammer-dir.sm:1187: %s.\n", "assert failure");

        }
        #endif
        ;
        #ifndef NDEBUG
        if (!(((*m_cache_entry_ptr).m_Owner != ((*in_msg_ptr)).m_Requestor))) {
            panic("Runtime Error at MOESI_hammer-dir.sm:1188: %s.\n", "assert failure");

        }
        #endif
        ;
        }
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:ano_assertNotOwner: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Assert that request is not a current sharer */
void
Directory_Controller::ans_assertNotSharer(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ans_assertNotSharer\n");
    try {
           if (m_full_bit_dir_enabled) {
        {
            // Declare message
            [[maybe_unused]] const RequestMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        #ifndef NDEBUG
        if (!(((((*m_cache_entry_ptr).m_Sharers).isElement((machineIDToNodeID(((*in_msg_ptr)).m_Requestor)))) == (false)))) {
            panic("Runtime Error at MOESI_hammer-dir.sm:1196: %s.\n", "assert failure");

        }
        #endif
        ;
        }
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:ans_assertNotSharer: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief remove current sharer */
void
Directory_Controller::rs_removeSharer(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing rs_removeSharer\n");
    try {
           if (m_full_bit_dir_enabled) {
        {
            // Declare message
            [[maybe_unused]] const ResponseMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const ResponseMsg *>(((*m_unblockToDir_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        #ifndef NDEBUG
        if (!((((*m_cache_entry_ptr).m_Sharers).isElement((machineIDToNodeID(((*in_msg_ptr)).m_Sender)))))) {
            panic("Runtime Error at MOESI_hammer-dir.sm:1204: %s.\n", "assert failure");

        }
        #endif
        ;
        (((*m_cache_entry_ptr).m_Sharers).remove((machineIDToNodeID(((*in_msg_ptr)).m_Sender))));
        }
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:rs_removeSharer: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief clear current sharers */
void
Directory_Controller::cs_clearSharers(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing cs_clearSharers\n");
    try {
           if (m_full_bit_dir_enabled) {
        {
            // Declare message
            [[maybe_unused]] const RequestMsg* in_msg_ptr;
            in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
            if (in_msg_ptr == NULL) {
                // If the cast fails, this is the wrong inport (wrong message type).
                // Throw an exception, and the caller will decide to either try a
                // different inport or punt.
                throw RejectException();
            }
        (((*m_cache_entry_ptr).m_Sharers).clear());
        (((*m_cache_entry_ptr).m_Sharers).add((machineIDToNodeID(((*in_msg_ptr)).m_Requestor))));
        }
    }

    } catch (const RejectException & e) {
       fatal("Error in action Directory:cs_clearSharers: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Write PUTX data to memory */
void
Directory_Controller::l_queueMemoryWBRequest(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing l_queueMemoryWBRequest\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const ResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const ResponseMsg *>(((*m_unblockToDir_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
{
    std::shared_ptr<MemoryMsg> out_msg = std::make_shared<MemoryMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_Type = MemoryRequestType_MEMORY_WB;
    (*out_msg).m_Sender = ((*in_msg_ptr)).m_Sender;
    (*out_msg).m_MessageSize = MessageSizeType_Writeback_Data;
    (*out_msg).m_DataBlk = ((*in_msg_ptr)).m_DataBlk;
    (*out_msg).m_Len = (0);
    ((*m_requestToMemory_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_to_memory_controller_latency)));
}
}

    } catch (const RejectException & e) {
       fatal("Error in action Directory:l_queueMemoryWBRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Write DMA data to memory */
void
Directory_Controller::ld_queueMemoryDmaWrite(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ld_queueMemoryDmaWrite\n");
    try {
       #ifndef NDEBUG
if (!((m_tbe_ptr != NULL))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:1233: %s.\n", "assert failure");

}
#endif
;
{
    std::shared_ptr<MemoryMsg> out_msg = std::make_shared<MemoryMsg>(clockEdge());
    (*out_msg).m_addr = (*m_tbe_ptr).m_PhysicalAddress;
    (*out_msg).m_Type = MemoryRequestType_MEMORY_WB;
    (*out_msg).m_Sender = (*m_tbe_ptr).m_DmaRequestor;
    (*out_msg).m_MessageSize = MessageSizeType_Writeback_Data;
    (*out_msg).m_DataBlk = (*m_tbe_ptr).m_DmaDataBlk;
    (*out_msg).m_Len = (*m_tbe_ptr).m_Len;
    ((*m_requestToMemory_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_to_memory_controller_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Directory:ld_queueMemoryDmaWrite: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Write data to memory from TBE */
void
Directory_Controller::ly_queueMemoryWriteFromTBE(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ly_queueMemoryWriteFromTBE\n");
    try {
       {
    std::shared_ptr<MemoryMsg> out_msg = std::make_shared<MemoryMsg>(clockEdge());
    (*out_msg).m_addr = addr;
    (*out_msg).m_Type = MemoryRequestType_MEMORY_WB;
    (*out_msg).m_Sender = (*m_tbe_ptr).m_DmaRequestor;
    (*out_msg).m_MessageSize = MessageSizeType_Writeback_Data;
    (*out_msg).m_DataBlk = (*m_tbe_ptr).m_DataBlk;
    (*out_msg).m_Len = (0);
    ((*m_requestToMemory_ptr)).enqueue(out_msg, clockEdge(), cyclesToTicks(Cycles(m_to_memory_controller_latency)));
}

    } catch (const RejectException & e) {
       fatal("Error in action Directory:ly_queueMemoryWriteFromTBE: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Check PUTX/PUTO response message */
void
Directory_Controller::ll_checkIncomingWriteback(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing ll_checkIncomingWriteback\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const ResponseMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const ResponseMsg *>(((*m_unblockToDir_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
#ifndef NDEBUG
if (!((((*in_msg_ptr)).m_Dirty == (false)))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:1257: %s.\n", "assert failure");

}
#endif
;
#ifndef NDEBUG
if (!((((*in_msg_ptr)).m_MessageSize == MessageSizeType_Writeback_Control))) {
    panic("Runtime Error at MOESI_hammer-dir.sm:1258: %s.\n", "assert failure");

}
#endif
;
DPRINTF(RubySlicc, "MOESI_hammer-dir.sm:1259: %s\n", ((*in_msg_ptr)).m_DataBlk);
}

    } catch (const RejectException & e) {
       fatal("Error in action Directory:ll_checkIncomingWriteback: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

/** \brief Recycle the request queue */
void
Directory_Controller::z_stallAndWaitRequest(Directory_TBE*& m_tbe_ptr, Directory_PfEntry*& m_cache_entry_ptr, Addr addr)
{
    DPRINTF(RubyGenerated, "executing z_stallAndWaitRequest\n");
    try {
       {
    // Declare message
    [[maybe_unused]] const RequestMsg* in_msg_ptr;
    in_msg_ptr = dynamic_cast<const RequestMsg *>(((*m_requestToDir_ptr)).peek());
    if (in_msg_ptr == NULL) {
        // If the cast fails, this is the wrong inport (wrong message type).
        // Throw an exception, and the caller will decide to either try a
        // different inport or punt.
        throw RejectException();
    }
APPEND_TRANSITION_COMMENT(((*in_msg_ptr)).m_Requestor);
}
        stallBuffer(&((*m_requestToDir_ptr)), addr);
        (*m_requestToDir_ptr).stallMessage(addr, clockEdge());
        

    } catch (const RejectException & e) {
       fatal("Error in action Directory:z_stallAndWaitRequest: "
             "executed a peek statement with the wrong message "
             "type specified. ");
    }
}

Directory_Entry*
Directory_Controller::getDirectoryEntry(const Addr& param_addr)
{
Directory_Entry* dir_entry
 = static_cast<Directory_Entry *>((((*m_directory_ptr)).lookup(param_addr)))
;
    if ((dir_entry != NULL)) {
        return dir_entry;
    }
    dir_entry = static_cast<Directory_Entry *>((((*m_directory_ptr)).allocate(param_addr, new Directory_Entry)))
    ;
    return dir_entry;

}
Directory_PfEntry*
Directory_Controller::getProbeFilterEntry(const Addr& param_addr)
{
    if ((m_probe_filter_enabled || m_full_bit_dir_enabled)) {
        Directory_PfEntry* pfEntry
         = static_cast<Directory_PfEntry *>((((*m_probeFilter_ptr)).lookup(param_addr)))
        ;
        return pfEntry;
    }
    return NULL;

}
Directory_State
Directory_Controller::getState(Directory_TBE* param_tbe, Directory_PfEntry* param_pf_entry, const Addr& param_addr)
{
    if ((param_tbe != NULL)) {
        return (*param_tbe).m_TBEState;
    } else {
            if ((m_probe_filter_enabled || m_full_bit_dir_enabled)) {
                    if ((param_pf_entry != NULL)) {
                        #ifndef NDEBUG
                        if (!(((*param_pf_entry).m_PfState == (*(getDirectoryEntry(param_addr))).m_DirectoryState))) {
                            panic("Runtime Error at MOESI_hammer-dir.sm:225: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                    }
                }
                return (*(getDirectoryEntry(param_addr))).m_DirectoryState;
            }

}
void
Directory_Controller::setState(Directory_TBE* param_tbe, Directory_PfEntry* param_pf_entry, const Addr& param_addr, const Directory_State& param_state)
{
    if ((param_tbe != NULL)) {
        (*param_tbe).m_TBEState = param_state;
    }
        if ((m_probe_filter_enabled || m_full_bit_dir_enabled)) {
                if ((param_pf_entry != NULL)) {
                    (*param_pf_entry).m_PfState = param_state;
                }
                    if (((((param_state == Directory_State_NX) || (param_state == Directory_State_NO)) || (param_state == Directory_State_S)) || (param_state == Directory_State_O))) {
                        #ifndef NDEBUG
                        if (!((param_pf_entry != NULL))) {
                            panic("Runtime Error at MOESI_hammer-dir.sm:241: %s.\n", "assert failure");

                        }
                        #endif
                        ;
                    }
                        if ((param_state == Directory_State_E)) {
                            #ifndef NDEBUG
                            if (!(((param_pf_entry != NULL) == (false)))) {
                                panic("Runtime Error at MOESI_hammer-dir.sm:244: %s.\n", "assert failure");

                            }
                            #endif
                            ;
                        }
                    }
                        if ((((((param_state == Directory_State_E) || (param_state == Directory_State_NX)) || (param_state == Directory_State_NO)) || (param_state == Directory_State_S)) || (param_state == Directory_State_O))) {
                            #ifndef NDEBUG
                            if (!(((param_tbe != NULL) == (false)))) {
                                panic("Runtime Error at MOESI_hammer-dir.sm:249: %s.\n", "assert failure");

                            }
                            #endif
                            ;
                        }
                        (*(getDirectoryEntry(param_addr))).m_DirectoryState = param_state;

}
AccessPermission
Directory_Controller::getAccessPermission(const Addr& param_addr)
{
Directory_TBE* tbe
 = (((*m_TBEs_ptr)).lookup(param_addr));
    if ((tbe != NULL)) {
        return (Directory_State_to_permission((*tbe).m_TBEState));
    }
        if ((((*m_directory_ptr)).isPresent(param_addr))) {
            return (Directory_State_to_permission((*(getDirectoryEntry(param_addr))).m_DirectoryState));
        }
        return AccessPermission_NotPresent;

}
void
Directory_Controller::setAccessPermission(Directory_PfEntry* param_pf_entry, const Addr& param_addr, const Directory_State& param_state)
{
((*((getDirectoryEntry(param_addr)))).changePermission((Directory_State_to_permission(param_state))));

}
void
Directory_Controller::functionalRead(const Addr& param_addr, Packet* param_pkt)
{
Directory_TBE* tbe
 = (((*m_TBEs_ptr)).lookup(param_addr));
    if ((tbe != NULL)) {
        (testAndRead(param_addr, (*tbe).m_DataBlk, param_pkt));
    } else {
        (functionalMemoryRead(param_pkt));
    }

}
int
Directory_Controller::functionalWrite(const Addr& param_addr, Packet* param_pkt)
{
int num_functional_writes
 = (0);
Directory_TBE* tbe
 = (((*m_TBEs_ptr)).lookup(param_addr));
    if ((tbe != NULL)) {
        num_functional_writes = (num_functional_writes + (testAndWrite(param_addr, (*tbe).m_DataBlk, param_pkt)));
    }
    num_functional_writes = (num_functional_writes + (functionalMemoryWrite(param_pkt)));
    return num_functional_writes;

}
Directory_Event
Directory_Controller::cache_request_to_event(const CoherenceRequestType& param_type)
{
    if ((param_type == CoherenceRequestType_GETS)) {
        return Directory_Event_GETS;
    } else {
            if ((param_type == CoherenceRequestType_GETX)) {
                return Directory_Event_GETX;
            } else {
                    if ((param_type == CoherenceRequestType_GETF)) {
                        return Directory_Event_GETF;
                    } else {
                        panic("Runtime Error at MOESI_hammer-dir.sm:301: %s.\n", ("Invalid CoherenceRequestType"));
                        ;
                    }
                }
            }

}
int
Directory_Controller::functionalWriteBuffers(PacketPtr& pkt)
{
    int num_functional_writes = 0;
num_functional_writes += m_forwardFromDir_ptr->functionalWrite(pkt);
num_functional_writes += m_responseFromDir_ptr->functionalWrite(pkt);
num_functional_writes += m_dmaResponseFromDir_ptr->functionalWrite(pkt);
num_functional_writes += m_unblockToDir_ptr->functionalWrite(pkt);
num_functional_writes += m_responseToDir_ptr->functionalWrite(pkt);
num_functional_writes += m_requestToDir_ptr->functionalWrite(pkt);
num_functional_writes += m_dmaRequestToDir_ptr->functionalWrite(pkt);
num_functional_writes += m_triggerQueue_ptr->functionalWrite(pkt);
num_functional_writes += m_requestToMemory_ptr->functionalWrite(pkt);
num_functional_writes += m_responseFromMemory_ptr->functionalWrite(pkt);
    return num_functional_writes;
}
bool
Directory_Controller::functionalReadBuffers(PacketPtr& pkt)
{
if (m_forwardFromDir_ptr->functionalRead(pkt)) return true;
if (m_responseFromDir_ptr->functionalRead(pkt)) return true;
if (m_dmaResponseFromDir_ptr->functionalRead(pkt)) return true;
if (m_unblockToDir_ptr->functionalRead(pkt)) return true;
if (m_responseToDir_ptr->functionalRead(pkt)) return true;
if (m_requestToDir_ptr->functionalRead(pkt)) return true;
if (m_dmaRequestToDir_ptr->functionalRead(pkt)) return true;
if (m_triggerQueue_ptr->functionalRead(pkt)) return true;
if (m_requestToMemory_ptr->functionalRead(pkt)) return true;
if (m_responseFromMemory_ptr->functionalRead(pkt)) return true;
    return false;
}

bool
Directory_Controller::functionalReadBuffers(PacketPtr& pkt, WriteMask &mask)
{
    bool read = false;
if (m_forwardFromDir_ptr->functionalRead(pkt, mask)) read = true;
if (m_responseFromDir_ptr->functionalRead(pkt, mask)) read = true;
if (m_dmaResponseFromDir_ptr->functionalRead(pkt, mask)) read = true;
if (m_unblockToDir_ptr->functionalRead(pkt, mask)) read = true;
if (m_responseToDir_ptr->functionalRead(pkt, mask)) read = true;
if (m_requestToDir_ptr->functionalRead(pkt, mask)) read = true;
if (m_dmaRequestToDir_ptr->functionalRead(pkt, mask)) read = true;
if (m_triggerQueue_ptr->functionalRead(pkt, mask)) read = true;
if (m_requestToMemory_ptr->functionalRead(pkt, mask)) read = true;
if (m_responseFromMemory_ptr->functionalRead(pkt, mask)) read = true;
    return read;
}

} // namespace ruby
} // namespace gem5
