// DO NOT EDIT
// This file was automatically generated from an ISA description:
//   x86/isa/main.isa

#undef REX
#define REX	machInst.rex
#undef REX_PRESENT
#define REX_PRESENT	machInst.rex.present
#undef REX_W
#define REX_W	machInst.rex.w
#undef REX_R
#define REX_R	machInst.rex.r
#undef REX_X
#define REX_X	machInst.rex.x
#undef REX_B
#define REX_B	machInst.rex.b
#undef LEGACY
#define LEGACY	machInst.legacy
#undef LEGACY_DECODEVAL
#define LEGACY_DECODEVAL	machInst.legacy.decodeVal
#undef LEGACY_REPNE
#define LEGACY_REPNE	machInst.legacy.repne
#undef LEGACY_REP
#define LEGACY_REP	machInst.legacy.rep
#undef LEGACY_LOCK
#define LEGACY_LOCK	machInst.legacy.lock
#undef LEGACY_OP
#define LEGACY_OP	machInst.legacy.op
#undef LEGACY_ADDR
#define LEGACY_ADDR	machInst.legacy.addr
#undef LEGACY_SEG
#define LEGACY_SEG	machInst.legacy.seg
#undef OPCODE_TYPE
#define OPCODE_TYPE	machInst.opcode.type
#undef OPCODE_OP
#define OPCODE_OP	machInst.opcode.op
#undef OPCODE_OP_TOP5
#define OPCODE_OP_TOP5	machInst.opcode.op.top5
#undef OPCODE_OP_BOTTOM3
#define OPCODE_OP_BOTTOM3	machInst.opcode.op.bottom3
#undef IMMEDIATE
#define IMMEDIATE	machInst.immediate
#undef DISPLACEMENT
#define DISPLACEMENT	machInst.displacement
#undef MODRM
#define MODRM	machInst.modRM
#undef MODRM_MOD
#define MODRM_MOD	machInst.modRM.mod
#undef MODRM_REG
#define MODRM_REG	machInst.modRM.reg
#undef MODRM_RM
#define MODRM_RM	machInst.modRM.rm
#undef SIB
#define SIB	machInst.sib
#undef SIB_SCALE
#define SIB_SCALE	machInst.sib.scale
#undef SIB_INDEX
#define SIB_INDEX	machInst.sib.index
#undef SIB_BASE
#define SIB_BASE	machInst.sib.base
#undef OPSIZE
#define OPSIZE	machInst.opSize
#undef ADDRSIZE
#define ADDRSIZE	machInst.addrSize
#undef STACKSIZE
#define STACKSIZE	machInst.stackSize
#undef MODE
#define MODE	machInst.mode
#undef CPL
#define CPL	machInst.mode.cpl
#undef MODE_MODE
#define MODE_MODE	machInst.mode.mode
#undef MODE_SUBMODE
#define MODE_SUBMODE	machInst.mode.submode
#undef VEX_PRESENT
#define VEX_PRESENT	machInst.vex.present
#undef VEX_V
#define VEX_V	machInst.vex.v
#undef VEX_L
#define VEX_L	machInst.vex.l

    class CPUIDInst : public X86ISA::X86StaticInst
    {
      public:
        static const RegIndex foldOBit = 0;
        /// Constructor
        CPUIDInst(const char *_mnemonic, ExtMachInst _machInst,
                OpClass __opClass) :
            X86ISA::X86StaticInst(_mnemonic, _machInst, __opClass)
        {
            flags[IsSerializing] = 1;
            flags[IsSerializeAfter] = 1;
        }

        std::string generateDisassembly(Addr pc,
                const loader::SymbolTable *symtab) const override;
    };

    class MonitorInst : public X86ISA::X86StaticInst
    {
      public:
        static const RegIndex foldOBit = 0;
        /// Constructor
        MonitorInst(const char *_mnemonic, ExtMachInst _machInst,
                OpClass __opClass) :
            X86ISA::X86StaticInst(_mnemonic, _machInst, __opClass)
        { }

        std::string generateDisassembly(Addr pc,
                const loader::SymbolTable *symtab) const override;
    };

    class MwaitInst : public X86ISA::X86StaticInst
    {
      public:
        static const RegIndex foldOBit = 0;
        /// Constructor
        MwaitInst(const char *_mnemonic, ExtMachInst _machInst,
                OpClass __opClass) :
            X86ISA::X86StaticInst(_mnemonic, _machInst, __opClass)
        {
            flags[IsLoad] = 1;
        }

        std::string generateDisassembly(Addr pc,
                const loader::SymbolTable *symtab) const override;
    };

    /**
     * Class for Unknown/Illegal instructions
     */
    class Unknown : public X86ISA::X86StaticInst
    {
      public:

        // Constructor
        Unknown(ExtMachInst _machInst) :
                X86ISA::X86StaticInst("unknown", _machInst, No_OpClass)
        {
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;

        std::string generateDisassembly(
                Addr pc, const loader::SymbolTable *symtab) const override;

    };

    /**
     * Static instruction class for unimplemented instructions that
     * cause simulator termination.  Note that these are recognized
     * (legal) instructions that the simulator does not support; the
     * 'Unknown' class is used for unrecognized/illegal instructions.
     * This is a leaf class.
     */
    class FailUnimplemented : public X86ISA::X86StaticInst
    {
      public:
        /// Constructor
        FailUnimplemented(const char *_mnemonic, ExtMachInst _machInst)
            : X86ISA::X86StaticInst(_mnemonic, _machInst, No_OpClass)
        {
            // don't call execute() (which panics) if we're on a
            // speculative path
            flags[IsNonSpeculative] = true;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;

        std::string
        generateDisassembly(Addr pc,
                            const loader::SymbolTable *symtab) const override;
    };

    /**
     * Base class for unimplemented instructions that cause a warning
     * to be printed (but do not terminate simulation).  This
     * implementation is a little screwy in that it will print a
     * warning for each instance of a particular unimplemented machine
     * instruction, not just for each unimplemented opcode.  Should
     * probably make the 'warned' flag a static member of the derived
     * class.
     */
    class WarnUnimplemented : public X86ISA::X86StaticInst
    {
      private:
        /// Have we warned on this instruction yet?
        mutable bool warned = false;

      public:
        /// Constructor
        WarnUnimplemented(const char *_mnemonic, ExtMachInst _machInst)
            : X86ISA::X86StaticInst(_mnemonic, _machInst, No_OpClass)
        {
            // don't call execute() (which panics) if we're on a
            // speculative path
            flags[IsNonSpeculative] = true;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;

        std::string
        generateDisassembly(Addr pc,
                            const loader::SymbolTable *symtab) const override;
    };

    class NopInst : public X86ISA::X86StaticInst
    {
      public:
        static const RegIndex foldOBit = 0;
        /// Constructor
        NopInst(const char *_mnemonic, ExtMachInst _machInst,
                OpClass __opClass) :
            X86ISA::X86StaticInst(_mnemonic, _machInst, __opClass)
        {
        }

        std::string generateDisassembly(Addr pc,
                const loader::SymbolTable *symtab) const override;
    };

    class SyscallInst : public X86ISA::X86StaticInst
    {
      public:
        static const RegIndex foldOBit = 0;
        /// Constructor
        SyscallInst(const char *_mnemonic, ExtMachInst _machInst,
                OpClass __opClass) :
            X86ISA::X86StaticInst(_mnemonic, _machInst, __opClass)
        {
        }

        std::string generateDisassembly(Addr pc,
                const loader::SymbolTable *symtab) const override;
    };

    class MovfpTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        MovfpTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MovfpTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        MovfpTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Movfp : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Movfp(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MovfpFlagsTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        MovfpFlagsTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MovfpFlagsTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        MovfpFlagsTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MovfpFlags : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        MovfpFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class XorfpTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        XorfpTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class XorfpTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        XorfpTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Xorfp : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Xorfp(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SqrtfpTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        SqrtfpTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SqrtfpTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        SqrtfpTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Sqrtfp : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Sqrtfp(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class CosfpTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        CosfpTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class CosfpTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        CosfpTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cosfp : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Cosfp(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SinfpTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        SinfpTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SinfpTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        SinfpTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Sinfp : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Sinfp(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class TanfpTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        TanfpTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class TanfpTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        TanfpTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Tanfp : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Tanfp(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvtf_i2dTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::IntSrc1Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        Cvtf_i2dTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvtf_i2dTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::IntSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        Cvtf_i2dTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvtf_i2d : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::IntSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Cvtf_i2d(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvtf_i2d_hiTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::IntSrc1Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        Cvtf_i2d_hiTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvtf_i2d_hiTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::IntSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        Cvtf_i2d_hiTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvtf_i2d_hi : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::IntSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Cvtf_i2d_hi(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvtf_d2iTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FoldedDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        Cvtf_d2iTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvtf_d2iTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FoldedDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        Cvtf_d2iTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvtf_d2i : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FoldedDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Cvtf_d2i(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvtint_fp80TopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::IntSrc1Op, X86ISA::IntSrc2Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        Cvtint_fp80TopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvtint_fp80Top : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::IntSrc1Op, X86ISA::IntSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        Cvtint_fp80Top(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvtint_fp80 : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::IntSrc1Op, X86ISA::IntSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Cvtint_fp80(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvtfp80h_intTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::IntDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        Cvtfp80h_intTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvtfp80h_intTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::IntDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        Cvtfp80h_intTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvtfp80h_int : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::IntDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Cvtfp80h_int(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvtfp80l_intTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::IntDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        Cvtfp80l_intTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvtfp80l_intTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::IntDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        Cvtfp80l_intTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvtfp80l_int : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::IntDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Cvtfp80l_int(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AddfpTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        AddfpTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AddfpTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        AddfpTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Addfp : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Addfp(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MulfpTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        MulfpTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MulfpTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        MulfpTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mulfp : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mulfp(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class DivfpTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        DivfpTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class DivfpTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        DivfpTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Divfp : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Divfp(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SubfpTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        SubfpTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SubfpTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        SubfpTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Subfp : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Subfp(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Yl2xFpTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        Yl2xFpTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Yl2xFpTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        Yl2xFpTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Yl2xFp : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Yl2xFp(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class PremFpTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        PremFpTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class PremFpTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        PremFpTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class PremFp : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        PremFp(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class PremFpFlagsTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[4];

      public:
        template <typename ...Args>
        PremFpFlagsTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class PremFpFlagsTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        PremFpFlagsTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class PremFpFlags : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        PremFpFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class CompfpTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[4];

      public:
        template <typename ...Args>
        CompfpTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class CompfpTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        CompfpTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Compfp : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        Compfp(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class absfpTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        absfpTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class absfpTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        absfpTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class absfp : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        absfp(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class absfpFlagsTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[4];

      public:
        template <typename ...Args>
        absfpFlagsTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class absfpFlagsTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        absfpFlagsTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class absfpFlags : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        absfpFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class chsfpTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        chsfpTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class chsfpTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        chsfpTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class chsfp : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        chsfp(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class chsfpFlagsTopTag : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[4];

      public:
        template <typename ...Args>
        chsfpFlagsTopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class chsfpFlagsTop : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        chsfpFlagsTop(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class chsfpFlags : public X86ISA::InstOperands<X86ISA::FpOp, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        chsfpFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Pop87TopTag : public X86ISA::InstOperands<X86ISA::FpOp>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        Pop87TopTag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Pop87Top : public X86ISA::InstOperands<X86ISA::FpOp>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Pop87Top(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Pop87 : public X86ISA::InstOperands<X86ISA::FpOp>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        template <typename ...Args>
        Pop87(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, int8_t _spm,
                Args... args);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    enum SegmentSelectorCheck
    {
        SegNoCheck,
        SegCSCheck,
        SegCallGateCheck,
        SegIntGateCheck,
        SegSoftIntGateCheck,
        SegSSCheck,
        SegIretCheck,
        SegIntCSCheck,
        SegTRCheck,
        SegTSSCheck,
        SegInGDTCheck,
        SegLDTCheck
    };

    enum LongModeDescriptorType
    {
        LDT64 = 2,
        AvailableTSS64 = 9,
        BusyTSS64 = 0xb,
        CallGate64 = 0xc,
        IntGate64 = 0xe,
        TrapGate64 = 0xf
    };

    class Add : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Add(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "add", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AddBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        AddBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "add", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AddFlags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        AddFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "add", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AddFlagsBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        AddFlagsBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "add", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AddImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        AddImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "addi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AddImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        AddImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "addi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AddFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        AddFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "addi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AddFlagsImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        AddFlagsImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "addi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Or : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Or(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "or", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class OrBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        OrBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "or", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class OrFlags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        OrFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "or", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class OrFlagsBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        OrFlagsBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "or", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class OrImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        OrImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "ori", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class OrImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        OrImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "ori", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class OrFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        OrFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "ori", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class OrFlagsImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        OrFlagsImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "ori", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Adc : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Adc(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "adc", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AdcBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        AdcBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "adc", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AdcFlags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        AdcFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "adc", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AdcFlagsBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        AdcFlagsBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "adc", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AdcImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        AdcImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "adci", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AdcImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        AdcImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "adci", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AdcFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        AdcFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "adci", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AdcFlagsImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        AdcFlagsImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "adci", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Sbb : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Sbb(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sbb", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SbbBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SbbBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sbb", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SbbFlags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SbbFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sbb", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SbbFlagsBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SbbFlagsBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sbb", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SbbImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SbbImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "sbbi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SbbImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SbbImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "sbbi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SbbFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SbbFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "sbbi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SbbFlagsImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SbbFlagsImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "sbbi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class And : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        And(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "and", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AndBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        AndBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "and", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AndFlags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        AndFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "and", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AndFlagsBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        AndFlagsBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "and", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AndImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        AndImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "andi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AndImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        AndImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "andi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AndFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        AndFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "andi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class AndFlagsImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        AndFlagsImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "andi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Sub : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Sub(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sub", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SubBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SubBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sub", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SubFlags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SubFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sub", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SubFlagsBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SubFlagsBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sub", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SubImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SubImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "subi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SubImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SubImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "subi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SubFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SubFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "subi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SubFlagsImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SubFlagsImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "subi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Xor : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Xor(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "xor", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class XorBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        XorBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "xor", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class XorFlags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        XorFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "xor", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class XorFlagsBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        XorFlagsBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "xor", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class XorImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        XorImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "xori", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class XorImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        XorImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "xori", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class XorFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        XorFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "xori", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class XorFlagsImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        XorFlagsImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "xori", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mul1s : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        Mul1s(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "mul1s", inst_mnem, set_flags,
                    IntMultOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Prodlow) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodlow]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Prodhi) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodhi]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mul1sFlags : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[4];

      public:
        template <typename ...Args>
        Mul1sFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "mul1s", inst_mnem, set_flags,
                    IntMultOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Prodlow) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodlow]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Prodlow) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodlow]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Prodhi) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodhi]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Prodhi) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodhi]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mul1sImm : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        Mul1sImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "mul1si", inst_mnem, set_flags,
                    IntMultOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Prodlow) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodlow]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Prodhi) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodhi]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mul1sFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[4];

      public:
        template <typename ...Args>
        Mul1sFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "mul1si", inst_mnem, set_flags,
                    IntMultOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Prodlow) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodlow]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Prodlow) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodlow]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Prodhi) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodhi]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Prodhi) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodhi]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mul1u : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        Mul1u(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "mul1u", inst_mnem, set_flags,
                    IntMultOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Prodlow) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodlow]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Prodhi) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodhi]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mul1uFlags : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[4];

      public:
        template <typename ...Args>
        Mul1uFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "mul1u", inst_mnem, set_flags,
                    IntMultOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Prodlow) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodlow]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Prodhi) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodhi]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Prodhi) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodhi]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mul1uImm : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        Mul1uImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "mul1ui", inst_mnem, set_flags,
                    IntMultOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Prodlow) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodlow]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Prodhi) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodhi]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mul1uFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[4];

      public:
        template <typename ...Args>
        Mul1uFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "mul1ui", inst_mnem, set_flags,
                    IntMultOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Prodlow) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodlow]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Prodhi) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodhi]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Prodhi) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodhi]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mulel : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mulel(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "mulel", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Prodlow) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodlow]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MulelBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        MulelBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "mulel", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Prodlow) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodlow]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Muleh : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Muleh(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "muleh", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Prodhi) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodhi]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MulehBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        MulehBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "muleh", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Prodhi) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Prodhi]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Div1 : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        Div1(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "div1", inst_mnem, set_flags,
                    IntDivOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Quotient) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Quotient]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Remainder) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Remainder]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Divisor) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Divisor]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Div1Imm : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        Div1Imm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "div1i", inst_mnem, set_flags,
                    IntDivOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Quotient) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Quotient]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Remainder) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Remainder]);
	_numTypedDestRegs[intRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Divisor) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Divisor]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Div2 : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        Div2(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "div2", inst_mnem, set_flags,
                    IntDivOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Quotient) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Quotient]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Quotient) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Quotient]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Remainder) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Remainder]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Remainder) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Remainder]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Divisor) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Divisor]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Div2Big : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        Div2Big(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "div2", inst_mnem, set_flags,
                    IntDivOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Quotient) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Quotient]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Quotient) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Quotient]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Remainder) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Remainder]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Remainder) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Remainder]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Divisor) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Divisor]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Div2Flags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[4];

      public:
        template <typename ...Args>
        Div2Flags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "div2", inst_mnem, set_flags,
                    IntDivOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Quotient) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Quotient]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Quotient) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Quotient]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Remainder) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Remainder]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Remainder) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Remainder]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Divisor) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Divisor]);
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Div2FlagsBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[4];

      public:
        template <typename ...Args>
        Div2FlagsBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "div2", inst_mnem, set_flags,
                    IntDivOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Quotient) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Quotient]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Quotient) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Quotient]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Remainder) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Remainder]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Remainder) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Remainder]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Divisor) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Divisor]);
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Div2Imm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        Div2Imm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "div2i", inst_mnem, set_flags,
                    IntDivOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Quotient) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Quotient]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Quotient) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Quotient]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Remainder) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Remainder]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Remainder) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Remainder]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Divisor) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Divisor]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Div2ImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        Div2ImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "div2i", inst_mnem, set_flags,
                    IntDivOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Quotient) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Quotient]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Quotient) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Quotient]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Remainder) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Remainder]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Remainder) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Remainder]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Divisor) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Divisor]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Div2FlagsImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[4];

      public:
        template <typename ...Args>
        Div2FlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "div2i", inst_mnem, set_flags,
                    IntDivOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Quotient) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Quotient]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Quotient) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Quotient]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Remainder) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Remainder]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Remainder) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Remainder]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Divisor) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Divisor]);
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Div2FlagsImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[4];

      public:
        template <typename ...Args>
        Div2FlagsImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "div2i", inst_mnem, set_flags,
                    IntDivOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Quotient) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Quotient]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Quotient) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Quotient]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Remainder) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Remainder]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Remainder) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Remainder]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Divisor) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Divisor]);
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Divq : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Divq(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "divq", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Quotient) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Quotient]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class DivqBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        DivqBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "divq", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Quotient) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Quotient]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Divr : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Divr(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "divr", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Remainder) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Remainder]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class DivrBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        DivrBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "divr", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Remainder) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Remainder]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mov : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mov(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "mov", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MovFlags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        MovFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "mov", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Zaps]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Df]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ecf]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ezf]);
	flags[IsInteger] = true;;
            flags[IsCondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MovImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        MovImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "movi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MovFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        MovFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "movi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Zaps]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Df]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ecf]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ezf]);
	flags[IsInteger] = true;;
            flags[IsCondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Sll : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Sll(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sll", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SllBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SllBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sll", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SllFlags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SllFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sll", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SllFlagsBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SllFlagsBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sll", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SllImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SllImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "slli", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SllImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SllImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "slli", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SllFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SllFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "slli", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SllFlagsImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SllFlagsImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "slli", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Srl : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Srl(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "srl", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SrlBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SrlBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "srl", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SrlFlags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SrlFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "srl", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SrlFlagsBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SrlFlagsBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "srl", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SrlImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SrlImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "srli", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SrlImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SrlImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "srli", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SrlFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SrlFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "srli", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SrlFlagsImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SrlFlagsImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "srli", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Sra : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Sra(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sra", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SraBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SraBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sra", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SraFlags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SraFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sra", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SraFlagsBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SraFlagsBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sra", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SraImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SraImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "srai", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SraImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SraImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "srai", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SraFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SraFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "srai", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SraFlagsImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SraFlagsImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "srai", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Ror : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Ror(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "ror", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RorFlags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        RorFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "ror", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RorImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        RorImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "rori", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RorFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        RorFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "rori", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Rcr : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Rcr(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "rcr", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RcrFlags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[10]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        RcrFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "rcr", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RcrImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        RcrImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "rcri", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RcrFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        RcrFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "rcri", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Rol : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Rol(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "rol", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RolFlags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        RolFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "rol", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RolImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        RolImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "roli", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RolFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        RolFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "roli", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Rcl : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Rcl(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "rcl", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RclFlags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[10]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        RclFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "rcl", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RclImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        RclImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "rcli", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RclFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        RclFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "rcli", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Sld : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Sld(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sld", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Doublebits) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Doublebits]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SldBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SldBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sld", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Doublebits) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Doublebits]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SldFlags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[10]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SldFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sld", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Doublebits) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Doublebits]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SldFlagsBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[10]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SldFlagsBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sld", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Doublebits) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Doublebits]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SldImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SldImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "sldi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Doublebits) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Doublebits]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SldImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SldImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "sldi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Doublebits) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Doublebits]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SldFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SldFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "sldi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Doublebits) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Doublebits]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SldFlagsImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SldFlagsImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "sldi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Doublebits) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Doublebits]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Srd : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Srd(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "srd", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Doublebits) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Doublebits]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SrdBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SrdBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "srd", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Doublebits) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Doublebits]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SrdFlags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[10]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SrdFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "srd", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Doublebits) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Doublebits]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SrdFlagsBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[10]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SrdFlagsBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "srd", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Doublebits) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Doublebits]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SrdImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SrdImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "srdi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Doublebits) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Doublebits]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SrdImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SrdImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "srdi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Doublebits) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Doublebits]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SrdFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SrdFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "srdi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Doublebits) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Doublebits]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SrdFlagsImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[9]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        SrdFlagsImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "srdi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((X86ISA::int_reg::Doublebits) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Doublebits]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::DFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Df] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mdb : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mdb(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "mdb", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Doublebits) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Doublebits]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MdbImm : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        MdbImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "mdbi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((X86ISA::int_reg::Doublebits) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[X86ISA::int_reg::Doublebits]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Wrip : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

      public:
        template <typename ...Args>
        Wrip(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "wrip", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::CsEffBase]);
	flags[IsControl] = true;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class WripFlags : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[8]; RegId destRegIdxArr[0];

      public:
        template <typename ...Args>
        WripFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "wrip", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Zaps]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Df]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ecf]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ezf]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::CsEffBase]);
	flags[IsControl] = true;
	flags[IsInteger] = true;;
            flags[IsCondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class WripImm : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[0];

      public:
        template <typename ...Args>
        WripImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "wripi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::CsEffBase]);
	flags[IsControl] = true;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;

        std::unique_ptr<PCStateBase> branchTarget(
                const PCStateBase &branchPC) const override;

        /// Explicitly import the otherwise hidden branchTarget
        using StaticInst::branchTarget;
    };

    class WripFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[0];

      public:
        template <typename ...Args>
        WripFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "wripi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Zaps]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Df]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ecf]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ezf]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::CsEffBase]);
	flags[IsControl] = true;
	flags[IsInteger] = true;;
            flags[IsCondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;

        std::unique_ptr<PCStateBase> branchTarget(
                const PCStateBase &branchPC) const override;

        /// Explicitly import the otherwise hidden branchTarget
        using StaticInst::branchTarget;
    };

    class Wruflags : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[5];

      public:
        template <typename ...Args>
        Wruflags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "wruflags", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Zaps]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Df]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Ecf]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Ezf]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class WruflagsImm : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[5];

      public:
        template <typename ...Args>
        WruflagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "wruflagsi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Zaps]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Df]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Ecf]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Ezf]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Wrflags : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        Wrflags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "wrflags", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Zaps]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Df]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Ecf]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Ezf]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[X86ISA::misc_reg::Rflags]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSerializing] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class WrflagsImm : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[6];

      public:
        template <typename ...Args>
        WrflagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "wrflagsi", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Zaps]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Df]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Ecf]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Ezf]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setDestRegIdx(_numDestRegs++, miscRegClass[X86ISA::misc_reg::Rflags]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSerializing] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Rdip : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Rdip(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "rdip", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::CsEffBase]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Ruflags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Ruflags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "ruflags", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Zaps]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Df]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ecf]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ezf]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Rflags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Rflags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "rflags", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Zaps]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Df]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ecf]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ezf]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::Rflags]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Ruflag : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        Ruflag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::Imm8Op>(mach_inst, "ruflag", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Zaps]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Df]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ecf]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ezf]);
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Ezf]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RuflagBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        RuflagBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::Imm8Op>(mach_inst, "ruflag", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Zaps]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Df]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ecf]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ezf]);
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Ezf]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Rflag : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        Rflag(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::Imm8Op>(mach_inst, "rflag", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Zaps]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Df]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ecf]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ezf]);
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Ezf]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::Rflags]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RflagBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        RflagBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::Imm8Op>(mach_inst, "rflag", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Zaps]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Df]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ecf]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ezf]);
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Ezf]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::Rflags]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Sext : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Sext(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sext", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SextBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SextBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sext", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SextFlags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[7]; RegId destRegIdxArr[5];

      public:
        template <typename ...Args>
        SextFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sext", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SextFlagsBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[5];

      public:
        template <typename ...Args>
        SextFlagsBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "sext", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SextImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SextImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "sexti", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SextImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        SextImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "sexti", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SextFlagsImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[5];

      public:
        template <typename ...Args>
        SextFlagsImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "sexti", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class SextFlagsImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[5];

      public:
        template <typename ...Args>
        SextFlagsImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "sexti", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CfofMask) != X86ISA::CfofMask && (ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CfofMask) != 0) ? ccRegClass[X86ISA::cc_reg::Cfof] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::ECFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ecf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Zext : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Zext(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "zext", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class ZextBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        ZextBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "zext", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class ZextImm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        ZextImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "zexti", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class ZextImmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        ZextImmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::Imm8Op>(mach_inst, "zexti", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Rddr : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::DbgSrc1Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Rddr(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::DbgSrc1Op>(mach_inst, "rddr", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::dr(src1)]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::Cr4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::Dr7]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RddrBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::DbgSrc1Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        RddrBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::DbgSrc1Op>(mach_inst, "rddr", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::dr(src1)]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::Cr4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::Dr7]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Wrdr : public X86ISA::RegOpT<X86ISA::DbgDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Wrdr(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::DbgDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "wrdr", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, miscRegClass[X86ISA::misc_reg::dr(dest)]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::Cr4]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::Dr7]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSerializing] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Rdcr : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::CrSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Rdcr(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::CrSrc1Op>(mach_inst, "rdcr", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::cr(src1)]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RdcrBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::CrSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        RdcrBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::CrSrc1Op>(mach_inst, "rdcr", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::cr(src1)]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Wrcr : public X86ISA::RegOpT<X86ISA::CrDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Wrcr(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::CrDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "wrcr", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, miscRegClass[X86ISA::misc_reg::cr(dest)]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::Efer]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::Cr4]);
	flags[((dest == 0) ? IsSquashAfter : IsSerializeAfter)] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializing] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Wrbase : public X86ISA::RegOpT<X86ISA::SegDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Wrbase(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::SegDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "wrbase", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, miscRegClass[X86ISA::misc_reg::segBase(dest)]);
	flags[((dest == X86ISA::segment_idx::Cs) ? IsSquashAfter : IsSerializeAfter)] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializing] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Wrlimit : public X86ISA::RegOpT<X86ISA::SegDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Wrlimit(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::SegDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "wrlimit", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, miscRegClass[X86ISA::misc_reg::segLimit(dest)]);
	flags[((dest == X86ISA::segment_idx::Cs) ? IsSquashAfter : IsSerializeAfter)] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializing] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Wrsel : public X86ISA::RegOpT<X86ISA::SegDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Wrsel(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::SegDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "wrsel", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, miscRegClass[X86ISA::misc_reg::segSel(dest)]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSerializing] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class WrAttr : public X86ISA::RegOpT<X86ISA::SegDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        WrAttr(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::SegDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "wrattr", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, miscRegClass[X86ISA::misc_reg::segAttr(dest)]);
	flags[((dest == X86ISA::segment_idx::Cs) ? IsSquashAfter : IsSerializeAfter)] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializing] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Rdbase : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::SegSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Rdbase(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::SegSrc1Op>(mach_inst, "rdbase", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segBase(src1)]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RdbaseBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::SegSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        RdbaseBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::SegSrc1Op>(mach_inst, "rdbase", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segBase(src1)]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Rdlimit : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::SegSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Rdlimit(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::SegSrc1Op>(mach_inst, "rdlimit", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segLimit(src1)]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RdlimitBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::SegSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        RdlimitBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::SegSrc1Op>(mach_inst, "rdlimit", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segLimit(src1)]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RdAttr : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::SegSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        RdAttr(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::SegSrc1Op>(mach_inst, "rdattr", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segAttr(src1)]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RdAttrBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::SegSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        RdAttrBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::SegSrc1Op>(mach_inst, "rdattr", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segAttr(src1)]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Rdsel : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::SegSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Rdsel(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::SegSrc1Op>(mach_inst, "rdsel", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segSel(src1)]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class RdselBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::SegSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        RdselBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::SegSrc1Op>(mach_inst, "rdsel", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segSel(src1)]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Rdval : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::MiscSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Rdval(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::MiscSrc1Op>(mach_inst, "rdval", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[src1]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Wrval : public X86ISA::RegOpT<X86ISA::MiscDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Wrval(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::MiscDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "wrval", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, miscRegClass[dest]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSerializing] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Chks : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

      public:
        template <typename ...Args>
        Chks(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op, X86ISA::Imm8Op>(mach_inst, "chks", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::M5Reg]);
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class ChksFlags : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        ChksFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op, X86ISA::Imm8Op>(mach_inst, "chks", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ((ext & X86ISA::CcFlagMask) != X86ISA::CcFlagMask && (ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::CcFlagMask) != 0) ? ccRegClass[X86ISA::cc_reg::Zaps] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, (false) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	setDestRegIdx(_numDestRegs++, ((ext & X86ISA::EZFBit) != 0) ? ccRegClass[X86ISA::cc_reg::Ezf] : RegId());
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::M5Reg]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Wrdh : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Wrdh(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "wrdh", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Wrtsc : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Wrtsc(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "wrtsc", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, miscRegClass[X86ISA::misc_reg::Tsc]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSerializing] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Rdtsc : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Rdtsc(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "rdtsc", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::Tsc]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Rdm5reg : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Rdm5reg(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "rdm5reg", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::M5Reg]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Wrdl : public X86ISA::RegOpT<X86ISA::SegDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[6]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        Wrdl(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::SegDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "wrdl", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src2) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segBase(dest)]);
	setDestRegIdx(_numDestRegs++, miscRegClass[X86ISA::misc_reg::segBase(dest)]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segLimit(dest)]);
	setDestRegIdx(_numDestRegs++, miscRegClass[X86ISA::misc_reg::segLimit(dest)]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segAttr(dest)]);
	setDestRegIdx(_numDestRegs++, miscRegClass[X86ISA::misc_reg::segAttr(dest)]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::M5Reg]);
	flags[((dest == X86ISA::segment_idx::Cs) ? IsSquashAfter : IsSerializeAfter)] = true;
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializing] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Wrxftw : public X86ISA::RegOpT<X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Wrxftw(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedSrc1Op>(mach_inst, "wrxftw", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setDestRegIdx(_numDestRegs++, miscRegClass[X86ISA::misc_reg::Ftw]);
	flags[IsInteger] = true;
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSerializing] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Rdxftw : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Rdxftw(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op>(mach_inst, "rdxftw", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::Ftw]);
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Popcnt : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Popcnt(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "popcnt", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
            flags[IsUncondControl] = flags[IsControl];;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class PopcntFlags : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[3];

      public:
        template <typename ...Args>
        PopcntFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint16_t _ext,
                Args... args) :
            X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::FoldedSrc1Op, X86ISA::FoldedSrc2Op>(mach_inst, "popcnt", inst_mnem, set_flags,
                    IntAluOp, { args... }, data_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Zaps]);
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Zaps]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsInteger] = true;;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Limm : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::Imm64Op>
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[1];

      public:
        template <typename Dest>
        Limm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, Dest _dest,
                uint64_t _imm, uint8_t data_size) :
        X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::Imm64Op>(mach_inst, "limm", inst_mnem, set_flags,
                IntAluOp, { _dest, _imm }, data_size, 0)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class LimmBig : public X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::Imm64Op>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[1];

      public:
        template <typename Dest>
        LimmBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, Dest _dest,
                uint64_t _imm, uint8_t data_size) :
        X86ISA::RegOpT<X86ISA::FoldedDestOp, X86ISA::Imm64Op>(mach_inst, "limm", inst_mnem, set_flags,
                IntAluOp, { _dest, _imm }, data_size, 0)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
    }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Lfpimm : public X86ISA::RegOpT<X86ISA::FloatDestOp, X86ISA::Imm64Op>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[1];

      public:
        template <typename Dest>
        Lfpimm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, Dest _dest,
                uint64_t _imm, uint8_t data_size) :
        X86ISA::RegOpT<X86ISA::FloatDestOp, X86ISA::Imm64Op>(mach_inst, "lfpimm", inst_mnem, set_flags,
                FloatAddOp, { _dest, _imm }, data_size, 0)
    {
        
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
        
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
    }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Ld : public X86ISA::LdStOp
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Ld(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags, Args ...args) :
            X86ISA::LdStOp(mach_inst, "ld", inst_mnem, set_flags,
                    args..., data_size, address_size, mem_flags, MemReadOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((index) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ((base) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, ((data) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[data]);
	setDestRegIdx(_numDestRegs++, ((data) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[data]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segEffBase(segment)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        }


        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class LdBig : public X86ISA::LdStOp
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        LdBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags, Args ...args) :
            X86ISA::LdStOp(mach_inst, "ld", inst_mnem, set_flags,
                    args..., data_size, address_size, mem_flags, MemReadOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((index) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ((base) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, ((data) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[data]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segEffBase(segment)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        }


        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class Ldst : public X86ISA::LdStOp
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Ldst(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags, Args ...args) :
            X86ISA::LdStOp(mach_inst, "ldst", inst_mnem, set_flags,
                    args..., data_size, address_size, mem_flags, MemReadOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((index) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ((base) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, ((data) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[data]);
	setDestRegIdx(_numDestRegs++, ((data) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[data]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segEffBase(segment)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        }


        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class LdstBig : public X86ISA::LdStOp
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        LdstBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags, Args ...args) :
            X86ISA::LdStOp(mach_inst, "ldst", inst_mnem, set_flags,
                    args..., data_size, address_size, mem_flags, MemReadOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((index) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ((base) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, ((data) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[data]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segEffBase(segment)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        }


        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class Ldstl : public X86ISA::LdStOp
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Ldstl(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags, Args ...args) :
            X86ISA::LdStOp(mach_inst, "ldstl", inst_mnem, set_flags,
                    args..., data_size, address_size, mem_flags, MemReadOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((index) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ((base) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, ((data) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[data]);
	setDestRegIdx(_numDestRegs++, ((data) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[data]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segEffBase(segment)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        }


        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class LdstlBig : public X86ISA::LdStOp
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        LdstlBig(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags, Args ...args) :
            X86ISA::LdStOp(mach_inst, "ldstl", inst_mnem, set_flags,
                    args..., data_size, address_size, mem_flags, MemReadOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((index) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ((base) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, ((data) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[data]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segEffBase(segment)]);
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        }


        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class Ldfp : public X86ISA::LdStFpOp
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Ldfp(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags, Args ...args) :
            X86ISA::LdStFpOp(mach_inst, "ldfp", inst_mnem, set_flags,
                    args..., data_size, address_size, mem_flags, FloatMemReadOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((index) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ((base) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, floatRegClass[data]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segEffBase(segment)]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        }


        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class Ldfp87 : public X86ISA::LdStFpOp
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Ldfp87(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags, Args ...args) :
            X86ISA::LdStFpOp(mach_inst, "ldfp87", inst_mnem, set_flags,
                    args..., data_size, address_size, mem_flags, FloatMemReadOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((index) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ((base) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, floatRegClass[data]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segEffBase(segment)]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        }


        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class Ldifp87 : public X86ISA::LdStFpOp
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Ldifp87(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags, Args ...args) :
            X86ISA::LdStFpOp(mach_inst, "ldifp87", inst_mnem, set_flags,
                    args..., data_size, address_size, mem_flags, FloatMemReadOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((index) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ((base) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[base]);
	setDestRegIdx(_numDestRegs++, floatRegClass[data]);
	_numTypedDestRegs[floatRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segEffBase(segment)]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsLoad] = true;;
        }


        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class LdSplit : public X86ISA::LdStSplitOp
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        LdSplit(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags,
                GpRegIndex data_low, GpRegIndex data_hi,
                uint8_t _scale, GpRegIndex _index, GpRegIndex _base,
                uint64_t _disp, SegRegIndex _segment,
                uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class LdSplitl : public X86ISA::LdStSplitOp
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[2];

      public:
        LdSplitl(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags,
                GpRegIndex data_low, GpRegIndex data_hi,
                uint8_t _scale, GpRegIndex _index, GpRegIndex _base,
                uint64_t _disp, SegRegIndex _segment,
                uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class St : public X86ISA::LdStOp
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        template <typename ...Args>
        St(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags, Args ...args) :
            X86ISA::LdStOp(mach_inst, "st", inst_mnem, set_flags,
                    args..., data_size, address_size, mem_flags, MemWriteOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((index) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ((base) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, ((data) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[data]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segEffBase(segment)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        }


        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class Stis : public X86ISA::LdStOp
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        template <typename ...Args>
        Stis(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags, Args ...args) :
            X86ISA::LdStOp(mach_inst, "stis", inst_mnem, set_flags,
                    args..., data_size, address_size, mem_flags, MemWriteOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((index) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ((base) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, ((data) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[data]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segEffBase(segment)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        }


        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class Stul : public X86ISA::LdStOp
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        template <typename ...Args>
        Stul(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags, Args ...args) :
            X86ISA::LdStOp(mach_inst, "stul", inst_mnem, set_flags,
                    args..., data_size, address_size, mem_flags, MemWriteOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((index) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ((base) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, ((data) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[data]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segEffBase(segment)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        }


        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class Stfp : public X86ISA::LdStFpOp
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        template <typename ...Args>
        Stfp(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags, Args ...args) :
            X86ISA::LdStFpOp(mach_inst, "stfp", inst_mnem, set_flags,
                    args..., data_size, address_size, mem_flags, FloatMemWriteOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((index) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ((base) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[data]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segEffBase(segment)]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        }


        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class Stfp87 : public X86ISA::LdStFpOp
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[0];

      public:
        template <typename ...Args>
        Stfp87(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags, Args ...args) :
            X86ISA::LdStFpOp(mach_inst, "stfp87", inst_mnem, set_flags,
                    args..., data_size, address_size, mem_flags, FloatMemWriteOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((index) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ((base) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[data]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segEffBase(segment)]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        }


        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class Cda : public X86ISA::MemNoDataOp
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

      public:
        template <typename ...Args>
        Cda(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags, Args ...args) :
            X86ISA::MemNoDataOp(mach_inst, "cda", inst_mnem, set_flags,
                    args..., data_size, address_size, mem_flags, MemWriteOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((index) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ((base) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segEffBase(segment)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        }


        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class Clflushopt : public X86ISA::MemNoDataOp
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

      public:
        template <typename ...Args>
        Clflushopt(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags, Args ...args) :
            X86ISA::MemNoDataOp(mach_inst, "clflushopt", inst_mnem, set_flags,
                    args..., data_size, address_size, mem_flags, MemWriteOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((index) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ((base) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segEffBase(segment)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        }


        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class Clwb : public X86ISA::MemNoDataOp
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

      public:
        template <typename ...Args>
        Clwb(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags, Args ...args) :
            X86ISA::MemNoDataOp(mach_inst, "clwb", inst_mnem, set_flags,
                    args..., data_size, address_size, mem_flags, MemWriteOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((index) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ((base) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segEffBase(segment)]);
	flags[IsInteger] = true;
	flags[IsStore] = true;;
        }


        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class StSplit : public X86ISA::LdStSplitOp
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      public:
        StSplit(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags,
                GpRegIndex data_low, GpRegIndex data_hi,
                uint8_t _scale, GpRegIndex _index, GpRegIndex _base,
                uint64_t _disp, SegRegIndex _segment,
                uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class StSplitul : public X86ISA::LdStSplitOp
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      public:
        StSplitul(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags,
                GpRegIndex data_low, GpRegIndex data_hi,
                uint8_t _scale, GpRegIndex _index, GpRegIndex _base,
                uint64_t _disp, SegRegIndex _segment,
                uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

    class Lea : public X86ISA::LdStOp
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Lea(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags, Args ...args) :
            X86ISA::LdStOp(mach_inst, "lea", inst_mnem, set_flags,
                    args..., data_size, address_size, mem_flags, IntAluOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((index) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ((base) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, ((data) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[data]);
	setDestRegIdx(_numDestRegs++, ((data) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[data]);
	_numTypedDestRegs[intRegClass.type()]++;
	flags[IsInteger] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Tia : public X86ISA::MemNoDataOp
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[0];

      public:
        template <typename ...Args>
        Tia(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t data_size, uint8_t address_size,
                Request::FlagsType mem_flags, Args ...args) :
            X86ISA::MemNoDataOp(mach_inst, "tia", inst_mnem, set_flags,
                    args..., data_size, address_size, mem_flags, IntAluOp)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((index) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[index]);
	setSrcRegIdx(_numSrcRegs++, ((base) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[base]);
	setSrcRegIdx(_numSrcRegs++, miscRegClass[X86ISA::misc_reg::segEffBase(segment)]);
	flags[IsInteger] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mov2int : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::IntDestOp, X86ISA::FloatSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mov2int(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::IntDestOp, X86ISA::FloatSrc1Op, X86ISA::Imm8Op>(mach_inst, "mov2int", inst_mnem, set_flags,
                    SimdMiscOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mov2fp : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::IntSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mov2fp(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::IntSrc1Op, X86ISA::Imm8Op>(mach_inst, "mov2fp", inst_mnem, set_flags,
                    SimdMiscOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((src1) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Movsign : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::IntDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Movsign(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::IntDestOp, X86ISA::FloatSrc1Op>(mach_inst, "movsign", inst_mnem, set_flags,
                    SimdMiscOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	setDestRegIdx(_numDestRegs++, ((dest) == gem5::X86ISA::int_reg::T0) ? RegId() : intRegClass[dest]);
	_numTypedDestRegs[intRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	flags[IsFloating] = true;
	flags[IsInteger] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Maskmov : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Maskmov(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "maskmov", inst_mnem, set_flags,
                    SimdMiscOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class shuffle : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        shuffle(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "shuffle", inst_mnem, set_flags,
                    SimdMiscOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Unpack : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Unpack(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "unpack", inst_mnem, set_flags,
                    SimdMiscOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Pack : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Pack(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "pack", inst_mnem, set_flags,
                    SimdMiscOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mxor : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mxor(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "mxor", inst_mnem, set_flags,
                    SimdAluOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mor : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mor(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "mor", inst_mnem, set_flags,
                    SimdAluOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mand : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mand(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "mand", inst_mnem, set_flags,
                    SimdAluOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mandn : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mandn(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "mandn", inst_mnem, set_flags,
                    SimdAluOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mminf : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mminf(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "mminf", inst_mnem, set_flags,
                    SimdFloatCmpOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mmaxf : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mmaxf(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "mmaxf", inst_mnem, set_flags,
                    SimdFloatCmpOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mmini : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mmini(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "mmini", inst_mnem, set_flags,
                    SimdCmpOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mmaxi : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mmaxi(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "mmaxi", inst_mnem, set_flags,
                    SimdCmpOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Msqrt : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Msqrt(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>(mach_inst, "msqrt", inst_mnem, set_flags,
                    SimdFloatSqrtOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mrcp : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mrcp(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>(mach_inst, "mrcp", inst_mnem, set_flags,
                    SimdFloatAluOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Maddf : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Maddf(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "maddf", inst_mnem, set_flags,
                    SimdFloatAddOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Msubf : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Msubf(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "msubf", inst_mnem, set_flags,
                    SimdFloatAddOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mmulf : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mmulf(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "mmulf", inst_mnem, set_flags,
                    SimdFloatMultOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mdivf : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mdivf(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "mdivf", inst_mnem, set_flags,
                    SimdFloatDivOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Maddi : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Maddi(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "maddi", inst_mnem, set_flags,
                    SimdAddOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Msubi : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Msubi(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "msubi", inst_mnem, set_flags,
                    SimdAddOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mmuli : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mmuli(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "mmuli", inst_mnem, set_flags,
                    SimdMultOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mavg : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mavg(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "mavg", inst_mnem, set_flags,
                    SimdAddOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Msad : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Msad(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "msad", inst_mnem, set_flags,
                    SimdAddOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Msrl : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Msrl(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "msrl", inst_mnem, set_flags,
                    SimdShiftOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MsrlImm : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        MsrlImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::Imm8Op>(mach_inst, "msrli", inst_mnem, set_flags,
                    SimdShiftOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Msra : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Msra(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "msra", inst_mnem, set_flags,
                    SimdShiftOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MsraImm : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        MsraImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::Imm8Op>(mach_inst, "msrai", inst_mnem, set_flags,
                    SimdShiftOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Msll : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Msll(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "msll", inst_mnem, set_flags,
                    SimdShiftOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MsllImm : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::Imm8Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        MsllImm(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::Imm8Op>(mach_inst, "mslli", inst_mnem, set_flags,
                    SimdShiftOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvtf2i : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Cvtf2i(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>(mach_inst, "cvtf2i", inst_mnem, set_flags,
                    SimdFloatCvtOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvti2f : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Cvti2f(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>(mach_inst, "cvti2f", inst_mnem, set_flags,
                    SimdFloatCvtOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Cvtf2f : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Cvtf2f(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op>(mach_inst, "cvtf2f", inst_mnem, set_flags,
                    SimdFloatCvtOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mcmpi2r : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mcmpi2r(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "mcmpi2r", inst_mnem, set_flags,
                    SimdCvtOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mcmpf2r : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[3]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Mcmpf2r(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatDestOp, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "mcmpf2r", inst_mnem, set_flags,
                    SimdFloatCvtOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[dest]);
	setDestRegIdx(_numDestRegs++, floatRegClass[dest]);
	_numTypedDestRegs[floatRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mcmpf2rf : public X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>
    {
      private:
        RegId srcRegIdxArr[4]; RegId destRegIdxArr[2];

      public:
        template <typename ...Args>
        Mcmpf2rf(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase, X86ISA::FloatSrc1Op, X86ISA::FloatSrc2Op>(mach_inst, "mcmpf2rf", inst_mnem, set_flags,
                    SimdFloatCvtOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src1]);
	setSrcRegIdx(_numSrcRegs++, floatRegClass[src2]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Zaps]);
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Zaps]);
	_numTypedDestRegs[ccRegClass.type()]++;
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setDestRegIdx(_numDestRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	_numTypedDestRegs[ccRegClass.type()]++;
	flags[IsFloating] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Emms : public X86ISA::InstOperands<X86ISA::MediaOpBase>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[1];

      public:
        template <typename ...Args>
        Emms(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t src_size, uint8_t dest_size,
                uint16_t _ext, Args... args) :
            X86ISA::InstOperands<X86ISA::MediaOpBase>(mach_inst, "emms", inst_mnem, set_flags,
                    FloatMiscOp, { args... }, src_size, dest_size, _ext)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setDestRegIdx(_numDestRegs++, miscRegClass[X86ISA::misc_reg::Ftw]);
	flags[IsNonSpeculative] = true;
	flags[IsSerializeAfter] = true;
	flags[IsSerializing] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class BrFlags : public X86ISA::InstOperands<X86ISA::MicroCondBase, X86ISA::UpcOp>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      public:
        BrFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint16_t _target, uint8_t _cc) :
            X86ISA::InstOperands<X86ISA::MicroCondBase, X86ISA::UpcOp>(mach_inst, "br", inst_mnem, set_flags,
                    IntAluOp, { _target }, _cc)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Zaps]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Df]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ecf]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ezf]);
	flags[IsCondControl] = true;
	flags[IsControl] = true;
	flags[IsDirectControl] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;

        std::unique_ptr<PCStateBase>
        branchTarget(const PCStateBase &branch_pc) const override
        {
            PCStateBase *pcs = branch_pc.clone();
            DPRINTF(X86, "Br branchTarget PC info: %s, Target: %d\n",
                    *pcs, (int16_t)target);
            auto &xpc = pcs->as<PCState>();
            xpc.nupc(target);
            xpc.uAdvance();
            return std::unique_ptr<PCStateBase>{pcs};
        }

        /// Explicitly import the otherwise hidden branchTarget
        using StaticInst::branchTarget;
    };

    class EretFlags : public X86ISA::InstOperands<X86ISA::MicroCondBase>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      public:
        EretFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t _cc) :
            X86ISA::InstOperands<X86ISA::MicroCondBase>(mach_inst, "eret", inst_mnem, set_flags,
                    IntAluOp, {}, _cc)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Zaps]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Cfof]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Df]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ecf]);
	setSrcRegIdx(_numSrcRegs++, ccRegClass[X86ISA::cc_reg::Ezf]);
	flags[IsCondControl] = true;
	flags[IsDirectControl] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Br : public X86ISA::InstOperands<X86ISA::MicroCondBase, X86ISA::UpcOp>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        Br(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint16_t _target, uint8_t _cc) :
            X86ISA::InstOperands<X86ISA::MicroCondBase, X86ISA::UpcOp>(mach_inst, "br", inst_mnem, set_flags,
                    IntAluOp, { _target }, _cc)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            
	flags[IsControl] = true;;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;

        std::unique_ptr<PCStateBase>
        branchTarget(const PCStateBase &branch_pc) const override
        {
            PCStateBase *pcs = branch_pc.clone();
            DPRINTF(X86, "Br branchTarget PC info: %s, Target: %d\n",
                    *pcs, (int16_t)target);
            auto &xpc = pcs->as<PCState>();
            xpc.nupc(target);
            xpc.uAdvance();
            return std::unique_ptr<PCStateBase>{pcs};
        }

        /// Explicitly import the otherwise hidden branchTarget
        using StaticInst::branchTarget;
    };

    class Eret : public X86ISA::InstOperands<X86ISA::MicroCondBase>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        Eret(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, uint8_t _cc) :
            X86ISA::InstOperands<X86ISA::MicroCondBase>(mach_inst, "eret", inst_mnem, set_flags,
                    IntAluOp, {}, _cc)
        {
            
    setRegIdxArrays(
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::srcRegIdxArr),
        reinterpret_cast<RegIdArrayPtr>(
            &std::remove_pointer_t<decltype(this)>::destRegIdxArr));
            ;
            ;
        }

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroFaultFlags : public X86ISA::InstOperands<X86ISA::MicroCondBase, X86ISA::FaultOp>
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      public:
        MicroFaultFlags(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, Fault _fault, uint8_t _cc);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class MicroFault : public X86ISA::InstOperands<X86ISA::MicroCondBase, X86ISA::FaultOp>
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        MicroFault(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags, Fault _fault, uint8_t _cc);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    class Mfence : public X86MicroopBase
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        Mfence(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags);

        Fault
        execute(ExecContext *, trace::InstRecord *) const override
        {
            return NoFault;
        }
    };

    class Sfence : public X86MicroopBase
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        Sfence(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags);

        Fault
        execute(ExecContext *, trace::InstRecord *) const override
        {
            return NoFault;
        }
    };

    class Lfence : public X86MicroopBase
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        Lfence(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags);

        Fault
        execute(ExecContext *, trace::InstRecord *) const override
        {
            return NoFault;
        }
    };

    class Serialize : public X86MicroopBase
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        Serialize(ExtMachInst mach_inst, const char *inst_mnem,
                uint64_t set_flags);

        Fault
        execute(ExecContext *, trace::InstRecord *) const override
        {
            return NoFault;
        }
    };

    class MicroDebugFlags : public X86ISA::MicroDebug
    {
      private:
        RegId srcRegIdxArr[5]; RegId destRegIdxArr[0];

      protected:
        uint8_t cc;

      public:
        MicroDebugFlags(ExtMachInst mach_inst, const char *mnem,
                const char *inst_mnem, uint64_t set_flags,
                GenericISA::M5DebugFault *_fault, uint8_t _cc);

        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

    // Base class for combinationally generated macroops
    class Macroop : public X86ISA::MacroopBase
    {
      public:
        Macroop(const char *mnem, ExtMachInst _machInst,
                uint32_t _numMicroops, X86ISA::EmulEnv _env)
                    : MacroopBase(mnem, _machInst, _numMicroops, _env)
        {}

        Fault
        execute(ExecContext *, trace::InstRecord *) const override
        {
            panic("Tried to execute macroop directly!");
        }
    };
GEM5_DEPRECATED_NAMESPACE(RomLabels, rom_labels);
namespace rom_labels
{
const static uint64_t label_longModeInterrupt = 0;
const static uint64_t label_longModeInterrupt_globalDescriptor = 10;
const static uint64_t label_longModeInterrupt_processDescriptor = 11;
const static uint64_t label_longModeInterrupt_istStackSwitch = 28;
const static uint64_t label_longModeInterrupt_cplStackSwitch = 30;
const static uint64_t label_longModeInterrupt_stackSwitched = 31;
const static uint64_t label_longModeSoftInterrupt = 61;
const static uint64_t label_longModeSoftInterrupt_globalDescriptor = 71;
const static uint64_t label_longModeSoftInterrupt_processDescriptor = 72;
const static uint64_t label_longModeSoftInterrupt_istStackSwitch = 89;
const static uint64_t label_longModeSoftInterrupt_cplStackSwitch = 91;
const static uint64_t label_longModeSoftInterrupt_stackSwitched = 92;
const static uint64_t label_longModeInterruptWithError = 122;
const static uint64_t label_longModeInterruptWithError_globalDescriptor = 132;
const static uint64_t label_longModeInterruptWithError_processDescriptor = 133;
const static uint64_t label_longModeInterruptWithError_istStackSwitch = 150;
const static uint64_t label_longModeInterruptWithError_cplStackSwitch = 152;
const static uint64_t label_longModeInterruptWithError_stackSwitched = 153;
const static uint64_t label_legacyModeInterrupt = 184;
const static uint64_t label_initIntHalt = 186;
const static uint64_t label_realModeInterrupt = 192;
const static uint64_t label_jmpFarWork = 211;
const static uint64_t label_farJmpGlobalDescriptor = 218;
const static uint64_t label_farJmpProcessDescriptor = 219;
const static uint64_t label_farJmpSystemDescriptor = 226;
const static MicroPC extern_label_longModeInterrupt = 0;
const static MicroPC extern_label_longModeSoftInterrupt = 61;
const static MicroPC extern_label_longModeInterruptWithError = 122;
const static MicroPC extern_label_legacyModeInterrupt = 184;
const static MicroPC extern_label_initIntHalt = 186;
const static MicroPC extern_label_realModeInterrupt = 192;
const static MicroPC extern_label_jmpFarWork = 211;
}

// Inst::UD2([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ud2".
         */
        class UD2 : public Macroop
        {
          private:
            
          public:
            // Constructor.
            UD2(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PUSH(['sEv'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "push".
         */
        class PUSH_S : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUSH_S(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::POP_REAL(['sEv'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pop".
         */
        class POP_REAL_S : public Macroop
        {
          private:
            
          public:
            // Constructor.
            POP_REAL_S(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::pop_ES(([], {}))

// MultiInst::ADD((['OPCODE_OP_BOTTOM3', ['Gb'], ['Gv'], [], [], [], []], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "add".
         */
        class ADD_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADD_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "add".
         */
        class ADD_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADD_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "add".
         */
        class ADD_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADD_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "add".
         */
        class ADD_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADD_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "add".
         */
        class ADD_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADD_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "add".
         */
        class ADD_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADD_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::PUSH(['sCv'],{})

// M5InternalError::error((['"Saw a one byte opcode whose value was 0x0F!"'], {}))

// MultiInst::OR((['OPCODE_OP_BOTTOM3', ['Gb'], ['Gv'], [], [], [], []], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "or".
         */
        class OR_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            OR_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "or".
         */
        class OR_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            OR_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "or".
         */
        class OR_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            OR_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "or".
         */
        class OR_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            OR_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "or".
         */
        class OR_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            OR_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "or".
         */
        class OR_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            OR_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::PUSH(['sSv'],{})

// Inst::UD2([],{})

// Inst::POP_REAL(['sSv'],{})

// WarnUnimpl::pop_SS(([], {}))

// MultiInst::ADC((['OPCODE_OP_BOTTOM3', ['Gb'], ['Gv'], [], [], [], []], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "adc".
         */
        class ADC_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADC_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "adc".
         */
        class ADC_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADC_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "adc".
         */
        class ADC_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADC_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "adc".
         */
        class ADC_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADC_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "adc".
         */
        class ADC_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADC_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "adc".
         */
        class ADC_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADC_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::PUSH(['sDv'],{})

// Inst::UD2([],{})

// Inst::POP_REAL(['sDv'],{})

// WarnUnimpl::pop_DS(([], {}))

// MultiInst::SBB((['OPCODE_OP_BOTTOM3', ['Gb'], ['Gv'], [], [], [], []], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sbb".
         */
        class SBB_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SBB_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sbb".
         */
        class SBB_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SBB_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sbb".
         */
        class SBB_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SBB_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sbb".
         */
        class SBB_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SBB_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sbb".
         */
        class SBB_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SBB_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sbb".
         */
        class SBB_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SBB_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// M5InternalError::error((['"Tried to execute the ES segment override prefix!"'], {}))

// Inst::UD2([],{})

// WarnUnimpl::daa(([], {}))

// MultiInst::AND((['OPCODE_OP_BOTTOM3', ['Gb'], ['Gv'], [], [], [], []], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "and".
         */
        class AND_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            AND_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "and".
         */
        class AND_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            AND_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "and".
         */
        class AND_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            AND_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "and".
         */
        class AND_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            AND_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "and".
         */
        class AND_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            AND_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "and".
         */
        class AND_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            AND_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// M5InternalError::error((['"Tried to execute the CS segment override prefix!"'], {}))

// Inst::UD2([],{})

// WarnUnimpl::das(([], {}))

// MultiInst::SUB((['OPCODE_OP_BOTTOM3', ['Gb'], ['Gv'], [], [], [], []], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sub".
         */
        class SUB_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUB_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sub".
         */
        class SUB_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUB_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sub".
         */
        class SUB_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUB_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sub".
         */
        class SUB_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUB_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sub".
         */
        class SUB_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUB_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sub".
         */
        class SUB_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUB_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// M5InternalError::error((['"Tried to execute the SS segment override prefix!"'], {}))

// Inst::UD2([],{})

// WarnUnimpl::aaa(([], {}))

// MultiInst::XOR((['OPCODE_OP_BOTTOM3', ['Gb'], ['Gv'], [], [], [], []], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xor".
         */
        class XOR_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XOR_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xor".
         */
        class XOR_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XOR_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xor".
         */
        class XOR_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XOR_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xor".
         */
        class XOR_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XOR_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xor".
         */
        class XOR_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XOR_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xor".
         */
        class XOR_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XOR_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// M5InternalError::error((['"Tried to execute the DS segment override prefix!"'], {}))

// Inst::UD2([],{})

// WarnUnimpl::aas(([], {}))

// MultiInst::CMP((['OPCODE_OP_BOTTOM3', ['Gb'], ['Gv'], [], [], [], []], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmp".
         */
        class CMP_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMP_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmp".
         */
        class CMP_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMP_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmp".
         */
        class CMP_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMP_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmp".
         */
        class CMP_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMP_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmp".
         */
        class CMP_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMP_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmp".
         */
        class CMP_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMP_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// M5InternalError::error((['"Tried to execute an REX prefix!"'], {}))

// Inst::INC(['Bv'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "inc".
         */
        class INC_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            INC_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// M5InternalError::error((['"Tried to execute an REX prefix!"'], {}))

// Inst::DEC(['Bv'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "dec".
         */
        class DEC_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            DEC_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PUSH(['Bv'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "push".
         */
        class PUSH_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUSH_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::POP(['Bv'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pop".
         */
        class POP_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            POP_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::PUSHA([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pusha".
         */
        class PUSHA : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUSHA(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::POPA([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "popa".
         */
        class POPA : public Macroop
        {
          private:
            
          public:
            // Constructor.
            POPA(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::BOUND(['Gv', 'Mv'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bound".
         */
        class BOUND_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BOUND_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bound".
         */
        class BOUND_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BOUND_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVSXD(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movsxd".
         */
        class MOVSXD_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVSXD_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movsxd".
         */
        class MOVSXD_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVSXD_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movsxd".
         */
        class MOVSXD_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVSXD_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::arpl_Ew_Gw(([], {}))

// M5InternalError::error((['"Tried to execute the FS segment override prefix!"'], {}))

// M5InternalError::error((['"Tried to execute the GS segment override prefix!"'], {}))

// M5InternalError::error((['"Tried to execute the operand size override prefix!"'], {}))

// M5InternalError::error((['"Tried to execute the DS address size override prefix!"'], {}))

// Unknown::unknown(([], {}))

// Inst::PUSH(['Iz'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "push".
         */
        class PUSH_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUSH_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::IMUL(['Gv', 'Ev', 'Iz'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "imul".
         */
        class IMUL_R_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            IMUL_R_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "imul".
         */
        class IMUL_R_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            IMUL_R_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "imul".
         */
        class IMUL_R_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            IMUL_R_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PUSH(['Ib'],{})

// Inst::IMUL(['Gv', 'Ev', 'Ib'],{})

// StringInst::INS_VIRT((['Yb', 'rD'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ins".
         */
        class INS_VIRT_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            INS_VIRT_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ins".
         */
        class INS_VIRT_E_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            INS_VIRT_E_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// StringInst::INS((['Yb', 'rD'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ins".
         */
        class INS_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            INS_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ins".
         */
        class INS_E_M_R : public Macroop
        {
          private:
            const static uint64_t label_topOfLoop = 8;
const static uint64_t label_end = 13;

          public:
            // Constructor.
            INS_E_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// StringInst::INS_VIRT((['Yz', 'rD'], {}))

// StringInst::INS((['Yz', 'rD'], {}))

// StringInst::OUTS_VIRT((['rD', 'Xb'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "outs".
         */
        class OUTS_VIRT_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            OUTS_VIRT_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "outs".
         */
        class OUTS_VIRT_E_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            OUTS_VIRT_E_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// StringInst::OUTS((['rD', 'Xb'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "outs".
         */
        class OUTS_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            OUTS_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "outs".
         */
        class OUTS_E_R_M : public Macroop
        {
          private:
            const static uint64_t label_topOfLoop = 8;
const static uint64_t label_end = 13;

          public:
            // Constructor.
            OUTS_E_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// StringInst::OUTS_VIRT((['rD', 'Xz'], {}))

// StringInst::OUTS((['rD', 'Xz'], {}))

// Unknown::unknown(([], {}))

// Inst::JO(['Jb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jo".
         */
        class JO_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JO_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JNO(['Jb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jno".
         */
        class JNO_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JNO_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JB(['Jb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jb".
         */
        class JB_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JB_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JNB(['Jb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jnb".
         */
        class JNB_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JNB_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JZ(['Jb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jz".
         */
        class JZ_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JZ_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JNZ(['Jb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jnz".
         */
        class JNZ_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JNZ_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JBE(['Jb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jbe".
         */
        class JBE_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JBE_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JNBE(['Jb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jnbe".
         */
        class JNBE_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JNBE_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::JS(['Jb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "js".
         */
        class JS_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JS_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JNS(['Jb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jns".
         */
        class JNS_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JNS_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JP(['Jb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jp".
         */
        class JP_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JP_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JNP(['Jb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jnp".
         */
        class JNP_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JNP_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JL(['Jb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jl".
         */
        class JL_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JL_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JNL(['Jb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jnl".
         */
        class JNL_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JNL_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JLE(['Jb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jle".
         */
        class JLE_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JLE_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JNLE(['Jb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jnle".
         */
        class JNLE_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JNLE_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::ADD(['Eb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "add".
         */
        class ADD_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADD_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "add".
         */
        class ADD_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADD_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::OR(['Eb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "or".
         */
        class OR_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            OR_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "or".
         */
        class OR_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            OR_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::ADC(['Eb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "adc".
         */
        class ADC_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADC_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "adc".
         */
        class ADC_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADC_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SBB(['Eb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sbb".
         */
        class SBB_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SBB_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sbb".
         */
        class SBB_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SBB_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::AND(['Eb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "and".
         */
        class AND_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            AND_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "and".
         */
        class AND_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            AND_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SUB(['Eb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sub".
         */
        class SUB_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUB_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sub".
         */
        class SUB_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUB_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::XOR(['Eb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xor".
         */
        class XOR_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XOR_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xor".
         */
        class XOR_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XOR_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CMP(['Eb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmp".
         */
        class CMP_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMP_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmp".
         */
        class CMP_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMP_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::ADD(['Ev', 'Iz'],{})

// Inst::OR(['Ev', 'Iz'],{})

// Inst::ADC(['Ev', 'Iz'],{})

// Inst::SBB(['Ev', 'Iz'],{})

// Inst::AND(['Ev', 'Iz'],{})

// Inst::SUB(['Ev', 'Iz'],{})

// Inst::XOR(['Ev', 'Iz'],{})

// Inst::CMP(['Ev', 'Iz'],{})

// Unknown::unknown(([], {}))

// Inst::UD2([],{})

// Inst::ADD(['Eb', 'Ib'],{})

// Inst::OR(['Eb', 'Ib'],{})

// Inst::ADC(['Eb', 'Ib'],{})

// Inst::SBB(['Eb', 'Ib'],{})

// Inst::AND(['Eb', 'Ib'],{})

// Inst::SUB(['Eb', 'Ib'],{})

// Inst::XOR(['Eb', 'Ib'],{})

// Inst::CMP(['Eb', 'Ib'],{})

// Unknown::unknown(([], {}))

// Inst::ADD(['Ev', 'Ib'],{})

// Inst::OR(['Ev', 'Ib'],{})

// Inst::ADC(['Ev', 'Ib'],{})

// Inst::SBB(['Ev', 'Ib'],{})

// Inst::AND(['Ev', 'Ib'],{})

// Inst::SUB(['Ev', 'Ib'],{})

// Inst::XOR(['Ev', 'Ib'],{})

// Inst::CMP(['Ev', 'Ib'],{})

// Unknown::unknown(([], {}))

// Inst::TEST(['Eb', 'Gb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "test".
         */
        class TEST_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            TEST_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "test".
         */
        class TEST_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            TEST_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "test".
         */
        class TEST_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            TEST_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::TEST(['Ev', 'Gv'],{})

// Inst::XCHG(['Eb', 'Gb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xchg".
         */
        class XCHG_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XCHG_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xchg".
         */
        class XCHG_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XCHG_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xchg".
         */
        class XCHG_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XCHG_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::XCHG(['Ev', 'Gv'],{})

// Unknown::unknown(([], {}))

// Inst::MOV(['Eb', 'Gb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOV_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOV_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOV_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOV(['Ev', 'Gv'],{})

// Inst::MOV(['Gb', 'Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOV_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOV_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOV(['Gv', 'Ev'],{})

// Inst::MOV(['Ev', 'Sv'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_R_S : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOV_R_S(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_M_S : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOV_M_S(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_P_S : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOV_P_S(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::LEA(['Gv', 'M'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lea".
         */
        class LEA_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LEA_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lea".
         */
        class LEA_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LEA_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::MOV_REAL(['Sv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_REAL_S_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOV_REAL_S_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_REAL_S_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOV_REAL_S_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_REAL_S_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOV_REAL_S_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::MOVSS(['Sv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movss".
         */
        class MOVSS_S_R : public Macroop
        {
          private:
            const static uint64_t label_globalDescriptor = 7;
const static uint64_t label_processDescriptor = 8;

          public:
            // Constructor.
            MOVSS_S_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movss".
         */
        class MOVSS_S_M : public Macroop
        {
          private:
            const static uint64_t label_globalDescriptor = 8;
const static uint64_t label_processDescriptor = 9;

          public:
            // Constructor.
            MOVSS_S_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movss".
         */
        class MOVSS_S_P : public Macroop
        {
          private:
            const static uint64_t label_globalDescriptor = 9;
const static uint64_t label_processDescriptor = 10;

          public:
            // Constructor.
            MOVSS_S_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOV(['Sv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_S_R : public Macroop
        {
          private:
            const static uint64_t label_globalDescriptor = 7;
const static uint64_t label_processDescriptor = 8;

          public:
            // Constructor.
            MOV_S_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_S_M : public Macroop
        {
          private:
            const static uint64_t label_globalDescriptor = 8;
const static uint64_t label_processDescriptor = 9;

          public:
            // Constructor.
            MOV_S_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_S_P : public Macroop
        {
          private:
            const static uint64_t label_globalDescriptor = 9;
const static uint64_t label_processDescriptor = 10;

          public:
            // Constructor.
            MOV_S_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::POP(['Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pop".
         */
        class POP_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            POP_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pop".
         */
        class POP_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            POP_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Unknown::unknown(([], {}))

// NopInst::NOP(([], {}))

    /**
     * Static instruction class for "NOP".
     */
    class NOP : public NopInst
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        // Constructor.
        NOP(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

// Inst::XCHG(['Bv', 'rAv'],{})

// Inst::CDQE(['rAv'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cdqe".
         */
        class CDQE_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CDQE_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CQO(['rAv', 'rDv'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cqo".
         */
        class CQO_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CQO_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::CALL_FAR_REAL(['Iz'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "call".
         */
        class CALL_FAR_REAL_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CALL_FAR_REAL_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::call_far_Ap(([], {}))

// WarnUnimpl::fwait(([], {}))

// Inst::PUSHF_VIRT([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pushf".
         */
        class PUSHF_VIRT : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUSHF_VIRT(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PUSHF([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pushf".
         */
        class PUSHF : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUSHF(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::POPF_VIRT([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "popf".
         */
        class POPF_VIRT : public Macroop
        {
          private:
            
          public:
            // Constructor.
            POPF_VIRT(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::POPF([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "popf".
         */
        class POPF : public Macroop
        {
          private:
            
          public:
            // Constructor.
            POPF(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SAHF([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sahf".
         */
        class SAHF : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SAHF(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::LAHF([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lahf".
         */
        class LAHF : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LAHF(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::MOV(['rAb', 'Ob'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_R_MI : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOV_R_MI(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOV(['rAv', 'Ov'],{})

// Inst::MOV(['Ob', 'rAb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_MI_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOV_MI_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOV(['Ov', 'rAv'],{})

// StringInst::MOVS((['Yb', 'Xb'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movs".
         */
        class MOVS_M_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVS_M_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movs".
         */
        class MOVS_E_M_M : public Macroop
        {
          private:
            const static uint64_t label_topOfLoop = 6;
const static uint64_t label_end = 12;

          public:
            // Constructor.
            MOVS_E_M_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// StringInst::MOVS((['Yv', 'Xv'], {}))

// StringTestInst::CMPS((['Yb', 'Xb'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmps".
         */
        class CMPS_M_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMPS_M_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmps".
         */
        class CMPS_E_M_M : public Macroop
        {
          private:
            const static uint64_t label_topOfLoop = 6;
const static uint64_t label_end = 13;

          public:
            // Constructor.
            CMPS_E_M_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmps".
         */
        class CMPS_N_M_M : public Macroop
        {
          private:
            const static uint64_t label_topOfLoop = 6;
const static uint64_t label_end = 13;

          public:
            // Constructor.
            CMPS_N_M_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// StringTestInst::CMPS((['Yv', 'Xv'], {}))

// Unknown::unknown(([], {}))

// Inst::TEST(['rAb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "test".
         */
        class TEST_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            TEST_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::TEST(['rAv', 'Iz'],{})

// StringInst::STOS((['Yb'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "stos".
         */
        class STOS_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            STOS_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "stos".
         */
        class STOS_E_M : public Macroop
        {
          private:
            const static uint64_t label_topOfLoop = 6;
const static uint64_t label_end = 10;

          public:
            // Constructor.
            STOS_E_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// StringInst::STOS((['Yv'], {}))

// StringInst::LODS((['Xb'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lods".
         */
        class LODS_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LODS_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lods".
         */
        class LODS_E_M : public Macroop
        {
          private:
            const static uint64_t label_topOfLoop = 6;
const static uint64_t label_end = 10;

          public:
            // Constructor.
            LODS_E_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// StringInst::LODS((['Xv'], {}))

// StringTestInst::SCAS((['Yb'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "scas".
         */
        class SCAS_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SCAS_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "scas".
         */
        class SCAS_E_M : public Macroop
        {
          private:
            const static uint64_t label_topOfLoop = 6;
const static uint64_t label_end = 11;

          public:
            // Constructor.
            SCAS_E_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "scas".
         */
        class SCAS_N_M : public Macroop
        {
          private:
            const static uint64_t label_topOfLoop = 6;
const static uint64_t label_end = 11;

          public:
            // Constructor.
            SCAS_N_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// StringTestInst::SCAS((['Yv'], {}))

// Unknown::unknown(([], {}))

// Inst::MOV(['Bb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOV_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOV(['Bv', 'Iv'],{})

// Inst::ROL(['Eb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rol".
         */
        class ROL_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ROL_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rol".
         */
        class ROL_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ROL_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rol".
         */
        class ROL_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ROL_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::ROR(['Eb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ror".
         */
        class ROR_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ROR_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ror".
         */
        class ROR_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ROR_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ror".
         */
        class ROR_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ROR_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::RCL(['Eb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcl".
         */
        class RCL_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCL_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcl".
         */
        class RCL_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCL_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcl".
         */
        class RCL_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCL_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::RCR(['Eb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcr".
         */
        class RCR_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCR_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcr".
         */
        class RCR_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCR_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcr".
         */
        class RCR_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCR_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SAL(['Eb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sal".
         */
        class SAL_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SAL_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sal".
         */
        class SAL_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SAL_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sal".
         */
        class SAL_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SAL_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SHR(['Eb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shr".
         */
        class SHR_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHR_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shr".
         */
        class SHR_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHR_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shr".
         */
        class SHR_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHR_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SAL(['Eb', 'Ib'],{})

// Inst::SAR(['Eb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sar".
         */
        class SAR_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SAR_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sar".
         */
        class SAR_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SAR_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sar".
         */
        class SAR_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SAR_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::ROL(['Ev', 'Ib'],{})

// Inst::ROR(['Ev', 'Ib'],{})

// Inst::RCL(['Ev', 'Ib'],{})

// Inst::RCR(['Ev', 'Ib'],{})

// Inst::SAL(['Ev', 'Ib'],{})

// Inst::SHR(['Ev', 'Ib'],{})

// Inst::SAL(['Ev', 'Ib'],{})

// Inst::SAR(['Ev', 'Ib'],{})

// Unknown::unknown(([], {}))

// Inst::RET_NEAR(['Iw'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ret".
         */
        class RET_NEAR_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RET_NEAR_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::RET_NEAR([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ret".
         */
        class RET_NEAR : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RET_NEAR(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::LES_REAL(['Gz', 'Mz'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "les".
         */
        class LES_REAL_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LES_REAL_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "les".
         */
        class LES_REAL_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LES_REAL_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::les_Gz_Mp(([], {}))

// Inst::UD2([],{})

// Inst::LDS_REAL(['Gz', 'Mz'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lds".
         */
        class LDS_REAL_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LDS_REAL_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lds".
         */
        class LDS_REAL_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LDS_REAL_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::lds_Gz_Mp(([], {}))

// Inst::MOV(['Eb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOV_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOV_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::MOV(['Ev', 'Iz'],{})

// Inst::UD2([],{})

// Unknown::unknown(([], {}))

// Inst::ENTER((['Iw', 'Iw'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "enter".
         */
        class ENTER_I_I : public Macroop
        {
          private:
            const static uint64_t label_topOfLoop = 12;
const static uint64_t label_bottomOfLoop = 18;
const static uint64_t label_skipLoop = 20;

          public:
            // Constructor.
            ENTER_I_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::LEAVE(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "leave".
         */
        class LEAVE : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LEAVE(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::RET_FAR_REAL((['Iw'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ret".
         */
        class RET_FAR_REAL_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RET_FAR_REAL_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::ret_far_Iw([],{})

// Inst::RET_FAR_REAL(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ret".
         */
        class RET_FAR_REAL : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RET_FAR_REAL(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::RET_FAR(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ret".
         */
        class RET_FAR : public Macroop
        {
          private:
            const static uint64_t label_globalDescriptor = 12;
const static uint64_t label_processDescriptor = 13;

          public:
            // Constructor.
            RET_FAR(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::INT3_REAL(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "int3".
         */
        class INT3_REAL : public Macroop
        {
          private:
            
          public:
            // Constructor.
            INT3_REAL(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::INT3_VIRT(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "int3".
         */
        class INT3_VIRT : public Macroop
        {
          private:
            
          public:
            // Constructor.
            INT3_VIRT(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::INT3(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "int3".
         */
        class INT3 : public Macroop
        {
          private:
            
          public:
            // Constructor.
            INT3(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// SyscallInst::int80((['\n                                return std::make_shared<SESyscallFault>();\n                            '], {}))

    /**
     * Static instruction class for "int80".
     */
    class Int80 : public SyscallInst
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        // Constructor.
        Int80(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

// WarnUnimpl::inst_ib([],{})

// Inst::INT_LONG((['Ib'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "int".
         */
        class INT_LONG_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            INT_LONG_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::INT_REAL((['Ib'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "int".
         */
        class INT_REAL_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            INT_REAL_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::INT_VIRT((['Ib'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "int".
         */
        class INT_VIRT_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            INT_VIRT_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::INT_PROT((['Ib'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "int".
         */
        class INT_PROT_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            INT_PROT_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::inst_ib([],{})

// Inst::UD2(([], {}))

// WarnUnimpl::into([],{})

// Inst::IRET_REAL(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "iret".
         */
        class IRET_REAL : public Macroop
        {
          private:
            
          public:
            // Constructor.
            IRET_REAL(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::IRET_VIRT(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "iret".
         */
        class IRET_VIRT : public Macroop
        {
          private:
            
          public:
            // Constructor.
            IRET_VIRT(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::IRET_PROT(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "iret".
         */
        class IRET_PROT : public Macroop
        {
          private:
            const static uint64_t label_protToVirtFallThrough = 13;
const static uint64_t label_globalCSDescriptor = 21;
const static uint64_t label_processCSDescriptor = 22;
const static uint64_t label_doPopStackStuffAndCheckRIP = 34;
const static uint64_t label_doPopStackStuff = 38;
const static uint64_t label_globalSSDescriptor = 47;
const static uint64_t label_processSSDescriptor = 48;
const static uint64_t label_fallThroughPopStackStuff = 52;
const static uint64_t label_skipSegmentSquashing = 58;

          public:
            // Constructor.
            IRET_PROT(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::ROL_1(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rol".
         */
        class ROL_1_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ROL_1_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rol".
         */
        class ROL_1_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ROL_1_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rol".
         */
        class ROL_1_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ROL_1_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::ROR_1(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ror".
         */
        class ROR_1_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ROR_1_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ror".
         */
        class ROR_1_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ROR_1_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ror".
         */
        class ROR_1_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ROR_1_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::RCL_1(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcl".
         */
        class RCL_1_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCL_1_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcl".
         */
        class RCL_1_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCL_1_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcl".
         */
        class RCL_1_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCL_1_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::RCR_1(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcr".
         */
        class RCR_1_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCR_1_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcr".
         */
        class RCR_1_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCR_1_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcr".
         */
        class RCR_1_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCR_1_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SAL_1(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sal".
         */
        class SAL_1_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SAL_1_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sal".
         */
        class SAL_1_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SAL_1_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sal".
         */
        class SAL_1_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SAL_1_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SHR_1(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shr".
         */
        class SHR_1_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHR_1_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shr".
         */
        class SHR_1_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHR_1_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shr".
         */
        class SHR_1_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHR_1_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SAL_1(['Eb'],{})

// Inst::SAR_1(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sar".
         */
        class SAR_1_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SAR_1_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sar".
         */
        class SAR_1_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SAR_1_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sar".
         */
        class SAR_1_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SAR_1_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::ROL_1(['Ev'],{})

// Inst::ROR_1(['Ev'],{})

// Inst::RCL_1(['Ev'],{})

// Inst::RCR_1(['Ev'],{})

// Inst::SAL_1(['Ev'],{})

// Inst::SHR_1(['Ev'],{})

// Inst::SAL_1(['Ev'],{})

// Inst::SAR_1(['Ev'],{})

// Unknown::unknown(([], {}))

// Inst::ROL(['Eb', 'rCb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rol".
         */
        class ROL_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ROL_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rol".
         */
        class ROL_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ROL_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rol".
         */
        class ROL_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ROL_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::ROR(['Eb', 'rCb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ror".
         */
        class ROR_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ROR_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ror".
         */
        class ROR_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ROR_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ror".
         */
        class ROR_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ROR_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::RCL(['Eb', 'rCb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcl".
         */
        class RCL_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCL_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcl".
         */
        class RCL_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCL_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcl".
         */
        class RCL_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCL_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::RCR(['Eb', 'rCb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcr".
         */
        class RCR_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCR_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcr".
         */
        class RCR_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCR_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcr".
         */
        class RCR_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCR_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SAL(['Eb', 'rCb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sal".
         */
        class SAL_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SAL_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sal".
         */
        class SAL_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SAL_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sal".
         */
        class SAL_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SAL_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SHR(['Eb', 'rCb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shr".
         */
        class SHR_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHR_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shr".
         */
        class SHR_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHR_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shr".
         */
        class SHR_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHR_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SAL(['Eb', 'rCb'],{})

// Inst::SAR(['Eb', 'rCb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sar".
         */
        class SAR_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SAR_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sar".
         */
        class SAR_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SAR_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sar".
         */
        class SAR_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SAR_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::ROL(['Ev', 'rCv'],{})

// Inst::ROR(['Ev', 'rCv'],{})

// Inst::RCL(['Ev', 'rCv'],{})

// Inst::RCR(['Ev', 'rCv'],{})

// Inst::SAL(['Ev', 'rCv'],{})

// Inst::SHR(['Ev', 'rCv'],{})

// Inst::SAL(['Ev', 'rCv'],{})

// Inst::SAR(['Ev', 'rCv'],{})

// Unknown::unknown(([], {}))

// Inst::UD2([],{})

// WarnUnimpl::aam_Ib(([], {}))

// Inst::UD2([],{})

// WarnUnimpl::aad_Ib(([], {}))

// Inst::UD2([],{})

// Inst::SALC(['rAb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "salc".
         */
        class SALC_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SALC_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::XLAT([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xlat".
         */
        class XLAT : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XLAT(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::FADD1((['Ed'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fadd1".
         */
        class FADD1_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FADD1_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fadd1".
         */
        class FADD1_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FADD1_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fadd1".
         */
        class FADD1_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FADD1_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FMUL1((['Ed'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fmul1".
         */
        class FMUL1_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FMUL1_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fmul1".
         */
        class FMUL1_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FMUL1_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fmul1".
         */
        class FMUL1_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FMUL1_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::fcom([],{})

// WarnUnimpl::fcomp([],{})

// Inst::FSUB1((['Ed'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fsub1".
         */
        class FSUB1_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FSUB1_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fsub1".
         */
        class FSUB1_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FSUB1_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fsub1".
         */
        class FSUB1_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FSUB1_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::fsubr([],{})

// Inst::FDIV1((['Ed'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fdiv1".
         */
        class FDIV1_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FDIV1_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fdiv1".
         */
        class FDIV1_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FDIV1_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fdiv1".
         */
        class FDIV1_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FDIV1_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::fdivr([],{})

// Inst::UD2(([], {}))

// Inst::FLD((['Ed'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fld".
         */
        class FLD_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FLD_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fld".
         */
        class FLD_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FLD_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fld".
         */
        class FLD_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FLD_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FXCH((['Rq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fxch".
         */
        class FXCH_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FXCH_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2(([], {}))

// WarnUnimpl::fnop([],{})

// Inst::UD2(([], {}))

// Inst::FST((['Md'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fst".
         */
        class FST_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FST_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fst".
         */
        class FST_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FST_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FSTP((['Md'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fstp".
         */
        class FSTP_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FSTP_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fstp".
         */
        class FSTP_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FSTP_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FCHS(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fchs".
         */
        class FCHS : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FCHS(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FABS(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fabs".
         */
        class FABS : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FABS(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::ftst([],{})

// WarnUnimpl::fxam([],{})

// Inst::UD2(([], {}))

// Inst::FLDENV((['M'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fldenv".
         */
        class FLDENV_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FLDENV_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fldenv".
         */
        class FLDENV_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FLDENV_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FLD1(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fld1".
         */
        class FLD1 : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FLD1(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FLDL2T(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fldl2t".
         */
        class FLDL2T : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FLDL2T(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FLDL2E(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fldl2e".
         */
        class FLDL2E : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FLDL2E(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FLDPI(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fldpi".
         */
        class FLDPI : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FLDPI(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FLDLG2(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fldlg2".
         */
        class FLDLG2 : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FLDLG2(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FLDLN2(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fldln2".
         */
        class FLDLN2 : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FLDLN2(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FLDZ(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fldz".
         */
        class FLDZ : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FLDZ(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2(([], {}))

// Inst::FLDCW((['Mw'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fldcw".
         */
        class FLDCW_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FLDCW_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fldcw".
         */
        class FLDCW_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FLDCW_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::f2xm1([],{})

// Inst::FYL2X(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fyl2x".
         */
        class FYL2X : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FYL2X(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FPTAN(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fptan".
         */
        class FPTAN : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FPTAN(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::fpatan([],{})

// WarnUnimpl::fxtract([],{})

// Inst::FPREM1(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fprem1".
         */
        class FPREM1 : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FPREM1(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::fdecstp([],{})

// WarnUnimpl::fincstp([],{})

// Inst::UD2(([], {}))

// Inst::FNSTENV((['M'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fnstenv".
         */
        class FNSTENV_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FNSTENV_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fnstenv".
         */
        class FNSTENV_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FNSTENV_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FPREM(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fprem".
         */
        class FPREM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FPREM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::fyl2xp1([],{})

// WarnUnimpl::fsqrt([],{})

// Inst::FSINCOS(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fsincos".
         */
        class FSINCOS : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FSINCOS(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::frndint([],{})

// WarnUnimpl::fscale([],{})

// Inst::FSIN(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fsin".
         */
        class FSIN : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FSIN(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FCOS(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fcos".
         */
        class FCOS : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FCOS(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2(([], {}))

// Inst::FNSTCW((['Mw'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fnstcw".
         */
        class FNSTCW_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FNSTCW_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fnstcw".
         */
        class FNSTCW_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FNSTCW_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2(([], {}))

// WarnUnimpl::fcmovb([],{})

// WarnUnimpl::fiadd([],{})

// WarnUnimpl::fcmove([],{})

// WarnUnimpl::fimul([],{})

// WarnUnimpl::fcmovbe([],{})

// WarnUnimpl::ficom([],{})

// WarnUnimpl::fcmovu([],{})

// WarnUnimpl::ficomp([],{})

// Inst::UD2(([], {}))

// WarnUnimpl::fisub([],{})

// WarnUnimpl::fucompp([],{})

// Inst::UD2(([], {}))

// WarnUnimpl::fisubr([],{})

// Inst::UD2(([], {}))

// WarnUnimpl::fidiv([],{})

// Inst::UD2(([], {}))

// WarnUnimpl::fidivr([],{})

// Inst::UD2(([], {}))

// WarnUnimpl::fcmovnb([],{})

// Inst::FILD((['Md'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fild".
         */
        class FILD_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FILD_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fild".
         */
        class FILD_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FILD_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::fcmovne([],{})

// WarnUnimpl::fisttp([],{})

// WarnUnimpl::fcmovnbe([],{})

// WarnUnimpl::fist([],{})

// WarnUnimpl::fcmovnu([],{})

// Inst::FISTP((['Md'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fistp".
         */
        class FISTP_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FISTP_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fistp".
         */
        class FISTP_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FISTP_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::fnclex([],{})

// WarnUnimpl::fninit([],{})

// Inst::UD2(([], {}))

// Inst::UD2(([], {}))

// Inst::FUCOMI((['Rq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fucomi".
         */
        class FUCOMI_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FUCOMI_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FLD80((['M'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fld80".
         */
        class FLD80_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FLD80_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fld80".
         */
        class FLD80_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FLD80_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FCOMI((['Rq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fcomi".
         */
        class FCOMI_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FCOMI_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2(([], {}))

// Inst::FST80P((['M'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fst80p".
         */
        class FST80P_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FST80P_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fst80p".
         */
        class FST80P_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FST80P_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2(([], {}))

// Inst::FADD2((['Eq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fadd2".
         */
        class FADD2_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FADD2_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fadd2".
         */
        class FADD2_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FADD2_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fadd2".
         */
        class FADD2_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FADD2_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FMUL2((['Eq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fmul2".
         */
        class FMUL2_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FMUL2_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fmul2".
         */
        class FMUL2_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FMUL2_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fmul2".
         */
        class FMUL2_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FMUL2_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2(([], {}))

// WarnUnimpl::fcom([],{})

// Inst::UD2(([], {}))

// WarnUnimpl::fcomp([],{})

// WarnUnimpl::fsubr([],{})

// Inst::FSUB2((['Mq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fsub2".
         */
        class FSUB2_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FSUB2_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fsub2".
         */
        class FSUB2_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FSUB2_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FSUB2((['Eq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fsub2".
         */
        class FSUB2_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FSUB2_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::fsubr([],{})

// WarnUnimpl::fdivr([],{})

// Inst::FDIV2((['Mq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fdiv2".
         */
        class FDIV2_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FDIV2_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fdiv2".
         */
        class FDIV2_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FDIV2_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FDIV2((['Eq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fdiv2".
         */
        class FDIV2_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FDIV2_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::fdivr([],{})

// Inst::UD2(([], {}))

// WarnUnimpl::ffree([],{})

// Inst::FLD((['Mq'], {}))

// Inst::UD2(([], {}))

// WarnUnimpl::fisttp([],{})

// Inst::FST((['Eq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fst".
         */
        class FST_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FST_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FST((['Mq'], {}))

// Inst::FSTP((['Eq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fstp".
         */
        class FSTP_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FSTP_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FSTP((['Mq'], {}))

// WarnUnimpl::fucom([],{})

// WarnUnimpl::frstor([],{})

// WarnUnimpl::fucomp([],{})

// Inst::UD2(([], {}))

// Inst::UD2(([], {}))

// WarnUnimpl::fnsave([],{})

// Inst::UD2(([], {}))

// Inst::FNSTSW((['Mw'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fnstsw".
         */
        class FNSTSW_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FNSTSW_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fnstsw".
         */
        class FNSTSW_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FNSTSW_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2(([], {}))

// Inst::FADDP((['Eq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "faddp".
         */
        class FADDP_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FADDP_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "faddp".
         */
        class FADDP_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FADDP_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "faddp".
         */
        class FADDP_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FADDP_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::fiadd([],{})

// Inst::FMULP((['Eq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fmulp".
         */
        class FMULP_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FMULP_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fmulp".
         */
        class FMULP_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FMULP_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fmulp".
         */
        class FMULP_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FMULP_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::fimul([],{})

// Inst::UD2(([], {}))

// WarnUnimpl::ficom([],{})

// WarnUnimpl::fcompp([],{})

// Inst::UD2(([], {}))

// WarnUnimpl::ficomp([],{})

// Inst::FSUBRP((['Rq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fsubrp".
         */
        class FSUBRP_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FSUBRP_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::fisub([],{})

// Inst::FSUBP((['Eq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fsubp".
         */
        class FSUBP_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FSUBP_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fsubp".
         */
        class FSUBP_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FSUBP_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fsubp".
         */
        class FSUBP_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FSUBP_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::fisubr([],{})

// WarnUnimpl::fdivrp([],{})

// WarnUnimpl::fidiv([],{})

// Inst::FDIVP((['Eq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fdivp".
         */
        class FDIVP_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FDIVP_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fdivp".
         */
        class FDIVP_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FDIVP_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fdivp".
         */
        class FDIVP_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FDIVP_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::fidivr([],{})

// Inst::UD2(([], {}))

// WarnUnimpl::ffreep([],{})

// Inst::FILD((['Mw'], {}))

// Inst::UD2(([], {}))

// WarnUnimpl::fisttp([],{})

// Inst::UD2(([], {}))

// WarnUnimpl::fist([],{})

// Inst::UD2(([], {}))

// Inst::FISTP((['Mw'], {}))

// Inst::FNSTSW((['rAw'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fnstsw".
         */
        class FNSTSW_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FNSTSW_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2(([], {}))

// WarnUnimpl::fbld([],{})

// Inst::FUCOMIP((['Rq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fucomip".
         */
        class FUCOMIP_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FUCOMIP_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FILD((['Mq'], {}))

// WarnUnimpl::fcomip([],{})

// WarnUnimpl::fbstp([],{})

// Inst::UD2(([], {}))

// Inst::FISTP((['Mq'], {}))

// Inst::UD2(([], {}))

// Inst::UD2(([], {}))

// Inst::LOOPNE(['Jb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "loopne".
         */
        class LOOPNE_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LOOPNE_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::LOOPE(['Jb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "loope".
         */
        class LOOPE_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LOOPE_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::LOOP(['Jb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "loop".
         */
        class LOOP_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LOOP_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JRCXZ(['Jb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jrcxz".
         */
        class JRCXZ_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JRCXZ_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::IN_VIRT(['rAb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "in".
         */
        class IN_VIRT_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            IN_VIRT_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::IN(['rAb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "in".
         */
        class IN_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            IN_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::IN_VIRT(['rAv', 'Iv'],{})

// Inst::IN(['rAv', 'Iv'],{})

// Inst::OUT_VIRT(['Ib', 'rAb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "out".
         */
        class OUT_VIRT_I_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            OUT_VIRT_I_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::OUT(['Ib', 'rAb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "out".
         */
        class OUT_I_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            OUT_I_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::OUT_VIRT(['Iv', 'rAv'],{})

// Inst::OUT(['Iv', 'rAv'],{})

// Unknown::unknown(([], {}))

// Inst::CALL_NEAR(['Jz'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "call".
         */
        class CALL_NEAR_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CALL_NEAR_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JMP(['Jz'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jmp".
         */
        class JMP_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JMP_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::JMP_FAR(['Iz'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jmp".
         */
        class JMP_FAR_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JMP_FAR_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JMP_FAR(['Iz'],{})

// Inst::JMP_FAR_REAL(['Iz'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jmp".
         */
        class JMP_FAR_REAL_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JMP_FAR_REAL_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JMP_FAR_REAL(['Iz'],{})

// Unknown::unknown(([], {}))

// Inst::JMP(['Jb'],{})

// Inst::IN_VIRT(['rAb', 'rD'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "in".
         */
        class IN_VIRT_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            IN_VIRT_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::IN(['rAb', 'rD'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "in".
         */
        class IN_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            IN_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::IN_VIRT(['rAv', 'rD'],{})

// Inst::IN(['rAv', 'rD'],{})

// Inst::OUT_VIRT(['rD', 'rAb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "out".
         */
        class OUT_VIRT_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            OUT_VIRT_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::OUT(['rD', 'rAb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "out".
         */
        class OUT_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            OUT_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::OUT_VIRT(['rD', 'rAv'],{})

// Inst::OUT(['rD', 'rAv'],{})

// Unknown::unknown(([], {}))

// M5InternalError::error((['"Tried to execute the lock prefix!"'], {}))

// WarnUnimpl::int1(([], {}))

// M5InternalError::error((['"Tried to execute the repne prefix!"'], {}))

// M5InternalError::error((['"Tried to execute the rep/repe prefix!"'], {}))

// Cpl0Inst::HLT(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "hlt".
         */
        class HLT : public Macroop
        {
          private:
            
          public:
            // Constructor.
            HLT(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CMC([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmc".
         */
        class CMC : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMC(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::TEST(['Eb', 'Iz'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "test".
         */
        class TEST_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            TEST_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "test".
         */
        class TEST_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            TEST_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::TEST(['Eb', 'Iz'],{})

// Inst::NOT(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "not".
         */
        class NOT_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            NOT_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "not".
         */
        class NOT_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            NOT_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "not".
         */
        class NOT_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            NOT_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::NEG(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "neg".
         */
        class NEG_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            NEG_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "neg".
         */
        class NEG_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            NEG_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "neg".
         */
        class NEG_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            NEG_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MUL_B(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mul".
         */
        class MUL_B_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MUL_B_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mul".
         */
        class MUL_B_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MUL_B_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mul".
         */
        class MUL_B_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MUL_B_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::IMUL_B(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "imul".
         */
        class IMUL_B_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            IMUL_B_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "imul".
         */
        class IMUL_B_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            IMUL_B_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "imul".
         */
        class IMUL_B_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            IMUL_B_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::DIV_B(['Ew'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "div".
         */
        class DIV_B_R : public Macroop
        {
          private:
            const static uint64_t label_divLoopTop = 3;

          public:
            // Constructor.
            DIV_B_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "div".
         */
        class DIV_B_M : public Macroop
        {
          private:
            const static uint64_t label_divLoopTop = 4;

          public:
            // Constructor.
            DIV_B_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "div".
         */
        class DIV_B_P : public Macroop
        {
          private:
            const static uint64_t label_divLoopTop = 5;

          public:
            // Constructor.
            DIV_B_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::IDIV_B(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "idiv".
         */
        class IDIV_B_R : public Macroop
        {
          private:
            const static uint64_t label_divLoopTop = 13;

          public:
            // Constructor.
            IDIV_B_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "idiv".
         */
        class IDIV_B_M : public Macroop
        {
          private:
            const static uint64_t label_divLoopTop = 14;

          public:
            // Constructor.
            IDIV_B_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "idiv".
         */
        class IDIV_B_P : public Macroop
        {
          private:
            const static uint64_t label_divLoopTop = 15;

          public:
            // Constructor.
            IDIV_B_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::TEST(['Ev', 'Iz'],{})

// Inst::TEST(['Ev', 'Iz'],{})

// Inst::NOT(['Ev'],{})

// Inst::NEG(['Ev'],{})

// Inst::MUL(['Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mul".
         */
        class MUL_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MUL_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mul".
         */
        class MUL_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MUL_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mul".
         */
        class MUL_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MUL_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::IMUL(['Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "imul".
         */
        class IMUL_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            IMUL_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "imul".
         */
        class IMUL_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            IMUL_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "imul".
         */
        class IMUL_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            IMUL_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::DIV(['Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "div".
         */
        class DIV_R : public Macroop
        {
          private:
            const static uint64_t label_divLoopTop = 3;

          public:
            // Constructor.
            DIV_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "div".
         */
        class DIV_M : public Macroop
        {
          private:
            const static uint64_t label_divLoopTop = 4;

          public:
            // Constructor.
            DIV_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "div".
         */
        class DIV_P : public Macroop
        {
          private:
            const static uint64_t label_divLoopTop = 5;

          public:
            // Constructor.
            DIV_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::IDIV(['Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "idiv".
         */
        class IDIV_R : public Macroop
        {
          private:
            const static uint64_t label_divLoopTop = 13;

          public:
            // Constructor.
            IDIV_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "idiv".
         */
        class IDIV_M : public Macroop
        {
          private:
            const static uint64_t label_divLoopTop = 14;

          public:
            // Constructor.
            IDIV_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "idiv".
         */
        class IDIV_P : public Macroop
        {
          private:
            const static uint64_t label_divLoopTop = 15;

          public:
            // Constructor.
            IDIV_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Inst::CLC([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "clc".
         */
        class CLC : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CLC(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::STC([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "stc".
         */
        class STC : public Macroop
        {
          private:
            
          public:
            // Constructor.
            STC(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CLI_VIRT([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cli".
         */
        class CLI_VIRT : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CLI_VIRT(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CLI_REAL([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cli".
         */
        class CLI_REAL : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CLI_REAL(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CLI([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cli".
         */
        class CLI : public Macroop
        {
          private:
            const static uint64_t label_maskIf = 16;
const static uint64_t label_maskWithT2 = 17;

          public:
            // Constructor.
            CLI(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::STI_VIRT([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sti".
         */
        class STI_VIRT : public Macroop
        {
          private:
            
          public:
            // Constructor.
            STI_VIRT(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::STI_REAL([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sti".
         */
        class STI_REAL : public Macroop
        {
          private:
            
          public:
            // Constructor.
            STI_REAL(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::STI([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sti".
         */
        class STI : public Macroop
        {
          private:
            const static uint64_t label_setIf = 18;
const static uint64_t label_setBitInT2 = 19;

          public:
            // Constructor.
            STI(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CLD([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cld".
         */
        class CLD : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CLD(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::STD([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "std".
         */
        class STD : public Macroop
        {
          private:
            
          public:
            // Constructor.
            STD(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::INC(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "inc".
         */
        class INC_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            INC_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "inc".
         */
        class INC_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            INC_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::DEC(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "dec".
         */
        class DEC_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            DEC_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "dec".
         */
        class DEC_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            DEC_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::INC(['Ev'],{})

// Inst::DEC(['Ev'],{})

// Inst::CALL_NEAR(['Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "call".
         */
        class CALL_NEAR_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CALL_NEAR_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "call".
         */
        class CALL_NEAR_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CALL_NEAR_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "call".
         */
        class CALL_NEAR_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CALL_NEAR_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CALL_FAR_REAL(['Mz'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "call".
         */
        class CALL_FAR_REAL_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CALL_FAR_REAL_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "call".
         */
        class CALL_FAR_REAL_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CALL_FAR_REAL_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::call_far_Mp(([], {}))

// Inst::JMP(['Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jmp".
         */
        class JMP_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JMP_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jmp".
         */
        class JMP_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JMP_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jmp".
         */
        class JMP_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JMP_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JMP_FAR(['Mz'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jmp".
         */
        class JMP_FAR_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JMP_FAR_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jmp".
         */
        class JMP_FAR_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JMP_FAR_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JMP_FAR(['Mz'],{})

// Inst::JMP_FAR(['Mz'],{})

// Inst::JMP_FAR_REAL(['Mz'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jmp".
         */
        class JMP_FAR_REAL_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JMP_FAR_REAL_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "jmp".
         */
        class JMP_FAR_REAL_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            JMP_FAR_REAL_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::JMP_FAR_REAL(['Mz'],{})

// Unknown::unknown(([], {}))

// Inst::PUSH(['Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "push".
         */
        class PUSH_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUSH_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "push".
         */
        class PUSH_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUSH_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// FailUnimpl::oneByteOps(([], {}))

// WarnUnimpl::sldt_Mw_or_Rv([],{})

// WarnUnimpl::str_Mw_or_Rv([],{})

// Cpl0Inst::LLDT_64((['Ew'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lldt".
         */
        class LLDT_64_R : public Macroop
        {
          private:
            const static uint64_t label_end = 10;

          public:
            // Constructor.
            LLDT_64_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lldt".
         */
        class LLDT_64_M : public Macroop
        {
          private:
            const static uint64_t label_end = 11;

          public:
            // Constructor.
            LLDT_64_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lldt".
         */
        class LLDT_64_P : public Macroop
        {
          private:
            const static uint64_t label_end = 12;

          public:
            // Constructor.
            LLDT_64_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Cpl0Inst::LLDT((['Ew'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lldt".
         */
        class LLDT_R : public Macroop
        {
          private:
            const static uint64_t label_end = 7;

          public:
            // Constructor.
            LLDT_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lldt".
         */
        class LLDT_M : public Macroop
        {
          private:
            const static uint64_t label_end = 8;

          public:
            // Constructor.
            LLDT_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lldt".
         */
        class LLDT_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LLDT_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Cpl0Inst::LTR_64((['Ew'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ltr".
         */
        class LTR_64_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LTR_64_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ltr".
         */
        class LTR_64_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LTR_64_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ltr".
         */
        class LTR_64_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LTR_64_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Cpl0Inst::LTR((['Ew'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ltr".
         */
        class LTR_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LTR_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ltr".
         */
        class LTR_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LTR_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ltr".
         */
        class LTR_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LTR_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::verr_Mw_or_Rv([],{})

// WarnUnimpl::verw_Mw_or_Rv([],{})

// Inst::UD2(([], {}))

// WarnUnimpl::vmcall([],{})

// WarnUnimpl::vmlaunch([],{})

// WarnUnimpl::vmresume([],{})

// WarnUnimpl::vmxoff([],{})

// Inst::UD2(([], {}))

// WarnUnimpl::sgdt_Ms([],{})

// MonitorInst::monitor((['\n                           xc->armMonitor(Rax);\n                        '], {}))

    /**
     * Static instruction class for "monitor".
     */
    class Monitor : public MonitorInst
    {
      private:
        RegId srcRegIdxArr[1]; RegId destRegIdxArr[0];

      public:
        // Constructor.
        Monitor(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

// MwaitInst::mwait((['\n                           uint64_t m = 0;          //mem\n                           unsigned s = 0x8;        //size\n                           unsigned f = 0;          //flags\n                           readMemAtomic(xc, traceData,\n                                         xc->getAddrMonitor()->vAddr,\n                                         m, s, f);\n                           xc->mwaitAtomic(xc->tcBase());\n                           MicroHalt hltObj(machInst, mnemonic, 0x0);\n                           hltObj.execute(xc, traceData);\n                        '], {}))

    class Mwait : public MwaitInst
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        // Constructor.
        Mwait(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
        Fault initiateAcc(ExecContext *, trace::InstRecord *) const override;
        Fault completeAcc(PacketPtr, ExecContext *,
                          trace::InstRecord *) const override;
    };

// Inst::UD2(([], {}))

// WarnUnimpl::sidt_Ms([],{})

// WarnUnimpl::xgetbv([],{})

// WarnUnimpl::xsetbv([],{})

// Unknown::unknown(([], {}))

// Cpl0Inst::LGDT((['M'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lgdt".
         */
        class LGDT_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LGDT_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lgdt".
         */
        class LGDT_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LGDT_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Cpl0Inst::LGDT_16((['M'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lgdt".
         */
        class LGDT_16_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LGDT_16_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lgdt".
         */
        class LGDT_16_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LGDT_16_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Cpl0Inst::LGDT((['M'], {}))

// WarnUnimpl::vmrun([],{})

// WarnUnimpl::vmmcall([],{})

// WarnUnimpl::vmload([],{})

// WarnUnimpl::vmsave([],{})

// WarnUnimpl::stgi([],{})

// WarnUnimpl::clgi([],{})

// WarnUnimpl::skinit([],{})

// WarnUnimpl::invlpga([],{})

// Unknown::unknown(([], {}))

// Cpl0Inst::LIDT((['M'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lidt".
         */
        class LIDT_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LIDT_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lidt".
         */
        class LIDT_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LIDT_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Cpl0Inst::LIDT_16((['M'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lidt".
         */
        class LIDT_16_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LIDT_16_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lidt".
         */
        class LIDT_16_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LIDT_16_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Cpl0Inst::LIDT((['M'], {}))

// Inst::SMSW((['Rv'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "smsw".
         */
        class SMSW_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SMSW_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SMSW((['Mw'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "smsw".
         */
        class SMSW_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SMSW_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "smsw".
         */
        class SMSW_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SMSW_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// BasicOperate::SERIALIZE((['/*Nothing*/', 'IsSerializeAfter'], {}))

    /**
     * Static instruction class for "SERIALIZE".
     */
    class SERIALIZE : public X86ISA::X86StaticInst
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        // Constructor.
        SERIALIZE(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Inst::LMSW((['Ew'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lmsw".
         */
        class LMSW_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LMSW_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lmsw".
         */
        class LMSW_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LMSW_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lmsw".
         */
        class LMSW_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LMSW_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Cpl0Inst::SWAPGS(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "swapgs".
         */
        class SWAPGS : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SWAPGS(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::RDTSCP(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rdtscp".
         */
        class RDTSCP : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RDTSCP(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2(([], {}))

// Cpl0Inst::INVLPG((['M'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "invlpg".
         */
        class INVLPG_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            INVLPG_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "invlpg".
         */
        class INVLPG_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            INVLPG_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// WarnUnimpl::lar_Gv_Ew([],{})

// WarnUnimpl::lsl_Gv_Ew([],{})

// BasicOperate::gem5Op((['\n                uint64_t result;\n                bool recognized = pseudo_inst::pseudoInst<X86PseudoInstABI>(\n                        xc->tcBase(), IMMEDIATE, result);\n                Rax = result;\n                if (!recognized)\n                    fault = std::make_shared<InvalidOpcode>();\n            ', 'IsNonSpeculative'], {}))

    /**
     * Static instruction class for "gem5Op".
     */
    class Gem5Op : public X86ISA::X86StaticInst
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[1];

      public:
        // Constructor.
        Gem5Op(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

// SyscallInst::syscall((['\n                    return std::make_shared<SESyscallFault>();\n                '], {}))

    /**
     * Static instruction class for "syscall".
     */
    class Syscall : public SyscallInst
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        // Constructor.
        Syscall(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

// Inst::SYSCALL_64(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "syscall".
         */
        class SYSCALL_64 : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SYSCALL_64(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SYSCALL_COMPAT(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "syscall".
         */
        class SYSCALL_COMPAT : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SYSCALL_COMPAT(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::SYSCALL_LEGACY(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "syscall".
         */
        class SYSCALL_LEGACY : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SYSCALL_LEGACY(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Cpl0Inst::CLTS(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "clts".
         */
        class CLTS : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CLTS(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Cpl0Inst::SYSRET_TO_64(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sysret".
         */
        class SYSRET_TO_64 : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SYSRET_TO_64(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Cpl0Inst::SYSRET_TO_COMPAT(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sysret".
         */
        class SYSRET_TO_COMPAT : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SYSRET_TO_COMPAT(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Cpl0Inst::SYSRET_NON_64(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sysret".
         */
        class SYSRET_NON_64 : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SYSRET_NON_64(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// WarnUnimpl::invd([],{})

// WarnUnimpl::wbinvd([],{})

// Inst::UD2(([], {}))

// Inst::UD2(([], {}))

// Inst::UD2(([], {}))

// Inst::PREFETCH((['Mb'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "prefetch".
         */
        class PREFETCH_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PREFETCH_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "prefetch".
         */
        class PREFETCH_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PREFETCH_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// FailUnimpl::femms(([], {}))

// WarnUnimpl::pi2fw_Pq_Qq([],{})

// WarnUnimpl::pi2fd_Pq_Qq([],{})

// WarnUnimpl::pf2iw_Pq_Qq([],{})

// WarnUnimpl::pf2id_Pq_Qq([],{})

// WarnUnimpl::pfnacc_Pq_Qq([],{})

// WarnUnimpl::pfpnacc_Pq_Qq([],{})

// WarnUnimpl::pfcmpge_Pq_Qq([],{})

// WarnUnimpl::pfmin_Pq_Qq([],{})

// WarnUnimpl::pfrcp_Pq_Qq([],{})

// WarnUnimpl::pfrsqrt_Pq_Qq([],{})

// Inst::PFSUB((['Pq', 'Qq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pfsub".
         */
        class PFSUB_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PFSUB_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pfsub".
         */
        class PFSUB_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PFSUB_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pfsub".
         */
        class PFSUB_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PFSUB_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::pfadd_Pq_Qq([],{})

// WarnUnimpl::pfcmpgt_Pq_Qq([],{})

// WarnUnimpl::pfmax_Pq_Qq([],{})

// WarnUnimpl::pfrcpit1_Pq_Qq([],{})

// WarnUnimpl::pfrsqit1_Pq_Qq([],{})

// Inst::PFSUBR((['Pq', 'Qq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pfsubr".
         */
        class PFSUBR_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PFSUBR_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pfsubr".
         */
        class PFSUBR_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PFSUBR_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pfsubr".
         */
        class PFSUBR_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PFSUBR_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::pfacc_Pq_Qq([],{})

// WarnUnimpl::pfcmpeq_Pq_Qq([],{})

// Inst::PFMUL((['Pq', 'Qq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pfmul".
         */
        class PFMUL_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PFMUL_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pfmul".
         */
        class PFMUL_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PFMUL_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pfmul".
         */
        class PFMUL_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PFMUL_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::pfrcpit2_Pq_Qq([],{})

// Inst::PMULHRW((['Pq', 'Qq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmulhrw".
         */
        class PMULHRW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULHRW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmulhrw".
         */
        class PMULHRW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULHRW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmulhrw".
         */
        class PMULHRW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULHRW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::pswapd_Pq_Qq([],{})

// WarnUnimpl::pavgusb_Pq_Qq([],{})

// Inst::UD2(([], {}))

// Unknown::unknown(([], {}))

// Inst::MOVUPS(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movups".
         */
        class MOVUPS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVUPS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movups".
         */
        class MOVUPS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVUPS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movups".
         */
        class MOVUPS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVUPS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVUPS(['Wo', 'Vo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movups".
         */
        class MOVUPS_M_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVUPS_M_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movups".
         */
        class MOVUPS_P_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVUPS_P_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVHLPS(['Vps', 'VRq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movhlps".
         */
        class MOVHLPS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVHLPS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVLPS(['Vps', 'Mq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movlps".
         */
        class MOVLPS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVLPS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movlps".
         */
        class MOVLPS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVLPS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVLPS(['Mq', 'Vps'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movlps".
         */
        class MOVLPS_M_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVLPS_M_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movlps".
         */
        class MOVLPS_P_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVLPS_P_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UNPCKLPS(['Vps', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "unpcklps".
         */
        class UNPCKLPS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            UNPCKLPS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "unpcklps".
         */
        class UNPCKLPS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            UNPCKLPS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "unpcklps".
         */
        class UNPCKLPS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            UNPCKLPS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UNPCKHPS(['Vps', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "unpckhps".
         */
        class UNPCKHPS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            UNPCKHPS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "unpckhps".
         */
        class UNPCKHPS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            UNPCKHPS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "unpckhps".
         */
        class UNPCKHPS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            UNPCKHPS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVLHPS(['Vps', 'VRq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movlhps".
         */
        class MOVLHPS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVLHPS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVHPS(['Vps', 'Mq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movhps".
         */
        class MOVHPS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVHPS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movhps".
         */
        class MOVHPS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVHPS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVHPS(['Mq', 'Vq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movhps".
         */
        class MOVHPS_M_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVHPS_M_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movhps".
         */
        class MOVHPS_P_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVHPS_P_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::MOVSS(['Vd', 'Wd'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movss".
         */
        class MOVSS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVSS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movss".
         */
        class MOVSS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVSS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movss".
         */
        class MOVSS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVSS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVSS(['Wd', 'Vd'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movss".
         */
        class MOVSS_M_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVSS_M_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movss".
         */
        class MOVSS_P_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVSS_P_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::movsldup_Vo_Wo(([], {}))

// WarnUnimpl::movshdup_Vo_Wo(([], {}))

// Inst::UD2([],{})

// Inst::MOVUPD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movupd".
         */
        class MOVUPD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVUPD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movupd".
         */
        class MOVUPD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVUPD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movupd".
         */
        class MOVUPD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVUPD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVUPD(['Wo', 'Vo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movupd".
         */
        class MOVUPD_M_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVUPD_M_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movupd".
         */
        class MOVUPD_P_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVUPD_P_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVLPD(['Vq', 'Mq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movlpd".
         */
        class MOVLPD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVLPD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movlpd".
         */
        class MOVLPD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVLPD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVLPD(['Mq', 'Vq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movlpd".
         */
        class MOVLPD_M_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVLPD_M_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movlpd".
         */
        class MOVLPD_P_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVLPD_P_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UNPCKLPD(['Vo', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "unpcklpd".
         */
        class UNPCKLPD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            UNPCKLPD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "unpcklpd".
         */
        class UNPCKLPD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            UNPCKLPD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "unpcklpd".
         */
        class UNPCKLPD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            UNPCKLPD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UNPCKHPD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "unpckhpd".
         */
        class UNPCKHPD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            UNPCKHPD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "unpckhpd".
         */
        class UNPCKHPD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            UNPCKHPD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "unpckhpd".
         */
        class UNPCKHPD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            UNPCKHPD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVHPD(['Vq', 'Mq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movhpd".
         */
        class MOVHPD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVHPD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movhpd".
         */
        class MOVHPD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVHPD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVHPD(['Mq', 'Vq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movhpd".
         */
        class MOVHPD_M_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVHPD_M_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movhpd".
         */
        class MOVHPD_P_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVHPD_P_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::MOVSD(['Vq', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movsd".
         */
        class MOVSD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVSD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movsd".
         */
        class MOVSD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVSD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movsd".
         */
        class MOVSD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVSD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVSD(['Wq', 'Vq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movsd".
         */
        class MOVSD_M_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVSD_M_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movsd".
         */
        class MOVSD_P_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVSD_P_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVDDUP(['Vo', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movddup".
         */
        class MOVDDUP_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVDDUP_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movddup".
         */
        class MOVDDUP_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVDDUP_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movddup".
         */
        class MOVDDUP_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVDDUP_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::UD2([],{})

// WarnUnimpl::prefetch_nta(([], {}))

// Inst::PREFETCH_T0(['Mb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "prefetch".
         */
        class PREFETCH_T0_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PREFETCH_T0_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "prefetch".
         */
        class PREFETCH_T0_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PREFETCH_T0_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::prefetch_t1(([], {}))

// WarnUnimpl::prefetch_t2(([], {}))

// Inst::HINT_NOP([],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "hint".
         */
        class HINT_NOP : public Macroop
        {
          private:
            
          public:
            // Constructor.
            HINT_NOP(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::HINT_NOP([],{})

// Inst::HINT_NOP([],{})

// Inst::HINT_NOP([],{})

// Inst::HINT_NOP([],{})

// Inst::HINT_NOP([],{})

// Inst::HINT_NOP([],{})

// Inst::HINT_NOP([],{})

// Unknown::unknown(([], {}))

// Cpl0CondInst::MOV((['misc_reg::isValid(misc_reg::cr(MODRM_REG))', 'Rd', 'Cd'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_R_C : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOV_R_C(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Cpl0CondInst::MOV((['MODRM_REG < 8', 'Rd', 'Dd'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_R_D : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOV_R_D(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Cpl0CondInst::MOV((['misc_reg::isValid(misc_reg::cr(MODRM_REG))', 'Cd', 'Rd'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_C_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOV_C_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Cpl0CondInst::MOV((['MODRM_REG < 8', 'Dd', 'Rd'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mov".
         */
        class MOV_D_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOV_D_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Cpl0CondInst::MOV((['misc_reg::isValid(misc_reg::cr(MODRM_REG))', 'Rd', 'Cd'], {}))

// Cpl0CondInst::MOV((['misc_reg::isValid(misc_reg::cr(MODRM_REG))', 'Cd', 'Rd'], {}))

// Unknown::unknown(([], {}))

// Inst::UD2([],{})

// Inst::MOVAPS(['Vq', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movaps".
         */
        class MOVAPS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVAPS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movaps".
         */
        class MOVAPS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVAPS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movaps".
         */
        class MOVAPS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVAPS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVAPS(['Wq', 'Vq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movaps".
         */
        class MOVAPS_M_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVAPS_M_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movaps".
         */
        class MOVAPS_P_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVAPS_P_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CVTPI2PS(['Vq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtpi2ps".
         */
        class CVTPI2PS_XMM_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPI2PS_XMM_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtpi2ps".
         */
        class CVTPI2PS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPI2PS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtpi2ps".
         */
        class CVTPI2PS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPI2PS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVNTPS(['Mq', 'Vq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movntps".
         */
        class MOVNTPS_M_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVNTPS_M_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movntps".
         */
        class MOVNTPS_P_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVNTPS_P_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CVTTPS2PI(['Pq', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvttps2pi".
         */
        class CVTTPS2PI_MMX_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTTPS2PI_MMX_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvttps2pi".
         */
        class CVTTPS2PI_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTTPS2PI_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvttps2pi".
         */
        class CVTTPS2PI_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTTPS2PI_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CVTPS2PI(['Pq', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtps2pi".
         */
        class CVTPS2PI_MMX_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPS2PI_MMX_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtps2pi".
         */
        class CVTPS2PI_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPS2PI_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtps2pi".
         */
        class CVTPS2PI_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPS2PI_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UCOMISS(['Vd', 'Wd'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ucomiss".
         */
        class UCOMISS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            UCOMISS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ucomiss".
         */
        class UCOMISS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            UCOMISS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ucomiss".
         */
        class UCOMISS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            UCOMISS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::COMISS(['Vd', 'Wd'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "comiss".
         */
        class COMISS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            COMISS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "comiss".
         */
        class COMISS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            COMISS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "comiss".
         */
        class COMISS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            COMISS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::CVTSI2SS(['Vd', 'Ed'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtsi2ss".
         */
        class CVTSI2SS_XMM_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTSI2SS_XMM_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtsi2ss".
         */
        class CVTSI2SS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTSI2SS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtsi2ss".
         */
        class CVTSI2SS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTSI2SS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CVTTSS2SI(['Gd', 'Wd'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvttss2si".
         */
        class CVTTSS2SI_R_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTTSS2SI_R_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvttss2si".
         */
        class CVTTSS2SI_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTTSS2SI_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvttss2si".
         */
        class CVTTSS2SI_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTTSS2SI_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CVTSS2SI(['Gd', 'Wd'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtss2si".
         */
        class CVTSS2SI_R_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTSS2SI_R_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtss2si".
         */
        class CVTSS2SI_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTSS2SI_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtss2si".
         */
        class CVTSS2SI_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTSS2SI_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::MOVAPD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movapd".
         */
        class MOVAPD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVAPD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movapd".
         */
        class MOVAPD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVAPD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movapd".
         */
        class MOVAPD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVAPD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVAPD(['Wo', 'Vo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movapd".
         */
        class MOVAPD_M_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVAPD_M_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movapd".
         */
        class MOVAPD_P_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVAPD_P_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CVTPI2PD(['Vo', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtpi2pd".
         */
        class CVTPI2PD_XMM_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPI2PD_XMM_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtpi2pd".
         */
        class CVTPI2PD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPI2PD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtpi2pd".
         */
        class CVTPI2PD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPI2PD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVNTPD(['Mq', 'Vq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movntpd".
         */
        class MOVNTPD_M_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVNTPD_M_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movntpd".
         */
        class MOVNTPD_P_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVNTPD_P_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CVTTPD2PI(['Pq', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvttpd2pi".
         */
        class CVTTPD2PI_MMX_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTTPD2PI_MMX_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvttpd2pi".
         */
        class CVTTPD2PI_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTTPD2PI_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvttpd2pi".
         */
        class CVTTPD2PI_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTTPD2PI_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CVTPD2PI(['Pq', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtpd2pi".
         */
        class CVTPD2PI_MMX_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPD2PI_MMX_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtpd2pi".
         */
        class CVTPD2PI_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPD2PI_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtpd2pi".
         */
        class CVTPD2PI_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPD2PI_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UCOMISD(['Vq', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ucomisd".
         */
        class UCOMISD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            UCOMISD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ucomisd".
         */
        class UCOMISD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            UCOMISD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ucomisd".
         */
        class UCOMISD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            UCOMISD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::COMISD(['Vq', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "comisd".
         */
        class COMISD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            COMISD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "comisd".
         */
        class COMISD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            COMISD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "comisd".
         */
        class COMISD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            COMISD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::CVTSI2SD(['Vdp', 'Edp'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtsi2sd".
         */
        class CVTSI2SD_XMM_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTSI2SD_XMM_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtsi2sd".
         */
        class CVTSI2SD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTSI2SD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtsi2sd".
         */
        class CVTSI2SD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTSI2SD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CVTTSD2SI(['Gdp', 'Wdp'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvttsd2si".
         */
        class CVTTSD2SI_R_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTTSD2SI_R_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvttsd2si".
         */
        class CVTTSD2SI_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTTSD2SI_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvttsd2si".
         */
        class CVTTSD2SI_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTTSD2SI_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CVTSD2SI(['Gd', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtsd2si".
         */
        class CVTSD2SI_R_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTSD2SI_R_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtsd2si".
         */
        class CVTSD2SI_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTSD2SI_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtsd2si".
         */
        class CVTSD2SI_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTSD2SI_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::UD2([],{})

// Cpl0Inst::WRMSR(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "wrmsr".
         */
        class WRMSR : public Macroop
        {
          private:
            
          public:
            // Constructor.
            WRMSR(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::RDTSC(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rdtsc".
         */
        class RDTSC : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RDTSC(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Cpl0Inst::RDMSR(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rdmsr".
         */
        class RDMSR : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RDMSR(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::rdpmc([],{})

// SyscallInst::sysenter((['\n                    return std::make_shared<SESyscallFault>();\n                '], {}))

    /**
     * Static instruction class for "sysenter".
     */
    class Sysenter : public SyscallInst
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        // Constructor.
        Sysenter(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

// WarnUnimpl::sysenter([],{})

// WarnUnimpl::sysexit([],{})

// Inst::UD2(([], {}))

// WarnUnimpl::getsec([],{})

// Unknown::unknown(([], {}))

// M5InternalError::error((['"Three byte opcode shouldn\'t be handled by "\n                      "two_byte_opcodes.isa!"'], {}))

// M5InternalError::error((['"Three byte opcode shouldn\'t be handled by "\n                      "two_byte_opcodes.isa!"'], {}))

// WarnUnimpl::UD2([],{})

// WarnUnimpl::UD2([],{})

// Unknown::unknown(([], {}))

// Inst::CMOVO(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovo".
         */
        class CMOVO_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVO_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovo".
         */
        class CMOVO_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVO_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovo".
         */
        class CMOVO_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVO_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CMOVNO(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovno".
         */
        class CMOVNO_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNO_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovno".
         */
        class CMOVNO_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNO_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovno".
         */
        class CMOVNO_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNO_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CMOVB(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovb".
         */
        class CMOVB_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVB_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovb".
         */
        class CMOVB_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVB_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovb".
         */
        class CMOVB_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVB_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CMOVNB(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovnb".
         */
        class CMOVNB_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNB_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovnb".
         */
        class CMOVNB_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNB_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovnb".
         */
        class CMOVNB_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNB_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CMOVZ(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovz".
         */
        class CMOVZ_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVZ_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovz".
         */
        class CMOVZ_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVZ_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovz".
         */
        class CMOVZ_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVZ_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CMOVNZ(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovnz".
         */
        class CMOVNZ_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNZ_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovnz".
         */
        class CMOVNZ_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNZ_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovnz".
         */
        class CMOVNZ_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNZ_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CMOVBE(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovbe".
         */
        class CMOVBE_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVBE_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovbe".
         */
        class CMOVBE_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVBE_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovbe".
         */
        class CMOVBE_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVBE_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CMOVNBE(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovnbe".
         */
        class CMOVNBE_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNBE_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovnbe".
         */
        class CMOVNBE_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNBE_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovnbe".
         */
        class CMOVNBE_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNBE_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::CMOVS(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovs".
         */
        class CMOVS_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVS_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovs".
         */
        class CMOVS_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVS_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovs".
         */
        class CMOVS_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVS_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CMOVNS(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovns".
         */
        class CMOVNS_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNS_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovns".
         */
        class CMOVNS_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNS_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovns".
         */
        class CMOVNS_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNS_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CMOVP(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovp".
         */
        class CMOVP_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVP_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovp".
         */
        class CMOVP_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVP_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovp".
         */
        class CMOVP_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVP_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CMOVNP(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovnp".
         */
        class CMOVNP_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNP_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovnp".
         */
        class CMOVNP_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNP_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovnp".
         */
        class CMOVNP_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNP_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CMOVL(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovl".
         */
        class CMOVL_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVL_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovl".
         */
        class CMOVL_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVL_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovl".
         */
        class CMOVL_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVL_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CMOVNL(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovnl".
         */
        class CMOVNL_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNL_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovnl".
         */
        class CMOVNL_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNL_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovnl".
         */
        class CMOVNL_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNL_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CMOVLE(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovle".
         */
        class CMOVLE_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVLE_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovle".
         */
        class CMOVLE_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVLE_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovle".
         */
        class CMOVLE_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVLE_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CMOVNLE(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovnle".
         */
        class CMOVNLE_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNLE_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovnle".
         */
        class CMOVNLE_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNLE_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmovnle".
         */
        class CMOVNLE_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMOVNLE_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::MOVMSKPS(['Gd', 'VRo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movmskps".
         */
        class MOVMSKPS_R_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVMSKPS_R_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SQRTPS(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sqrtps".
         */
        class SQRTPS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SQRTPS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sqrtps".
         */
        class SQRTPS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SQRTPS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sqrtps".
         */
        class SQRTPS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SQRTPS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::rqsrtps_Vo_Wo(([], {}))

// Inst::RCPPS(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcpps".
         */
        class RCPPS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCPPS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcpps".
         */
        class RCPPS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCPPS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcpps".
         */
        class RCPPS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCPPS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::ANDPS(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "andps".
         */
        class ANDPS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ANDPS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "andps".
         */
        class ANDPS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ANDPS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "andps".
         */
        class ANDPS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ANDPS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::ANDNPS(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "andnps".
         */
        class ANDNPS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ANDNPS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "andnps".
         */
        class ANDNPS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ANDNPS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "andnps".
         */
        class ANDNPS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ANDNPS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::ORPS(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "orps".
         */
        class ORPS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ORPS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "orps".
         */
        class ORPS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ORPS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "orps".
         */
        class ORPS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ORPS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::XORPS(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xorps".
         */
        class XORPS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XORPS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xorps".
         */
        class XORPS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XORPS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xorps".
         */
        class XORPS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XORPS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::SQRTSS(['Vd', 'Wd'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sqrtss".
         */
        class SQRTSS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SQRTSS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sqrtss".
         */
        class SQRTSS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SQRTSS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sqrtss".
         */
        class SQRTSS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SQRTSS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::rsqrtss_Vd_Wd(([], {}))

// Inst::RCPSS(['Vd', 'Wd'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcpss".
         */
        class RCPSS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCPSS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcpss".
         */
        class RCPSS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCPSS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "rcpss".
         */
        class RCPSS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            RCPSS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::MOVMSKPD(['Gd', 'VRo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movmskpd".
         */
        class MOVMSKPD_R_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVMSKPD_R_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SQRTPD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sqrtpd".
         */
        class SQRTPD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SQRTPD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sqrtpd".
         */
        class SQRTPD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SQRTPD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sqrtpd".
         */
        class SQRTPD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SQRTPD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::ANDPD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "andpd".
         */
        class ANDPD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ANDPD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "andpd".
         */
        class ANDPD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ANDPD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "andpd".
         */
        class ANDPD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ANDPD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::ANDNPD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "andnpd".
         */
        class ANDNPD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ANDNPD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "andnpd".
         */
        class ANDNPD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ANDNPD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "andnpd".
         */
        class ANDNPD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ANDNPD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::ORPD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "orpd".
         */
        class ORPD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ORPD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "orpd".
         */
        class ORPD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ORPD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "orpd".
         */
        class ORPD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ORPD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::XORPD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xorpd".
         */
        class XORPD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XORPD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xorpd".
         */
        class XORPD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XORPD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xorpd".
         */
        class XORPD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XORPD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::SQRTSD(['Vq', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sqrtsd".
         */
        class SQRTSD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SQRTSD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sqrtsd".
         */
        class SQRTSD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SQRTSD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sqrtsd".
         */
        class SQRTSD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SQRTSD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::UD2([],{})

// Inst::ADDPS(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "addps".
         */
        class ADDPS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADDPS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "addps".
         */
        class ADDPS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADDPS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "addps".
         */
        class ADDPS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADDPS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MULPS(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mulps".
         */
        class MULPS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MULPS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mulps".
         */
        class MULPS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MULPS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mulps".
         */
        class MULPS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MULPS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CVTPS2PD(['Vo', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtps2pd".
         */
        class CVTPS2PD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPS2PD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtps2pd".
         */
        class CVTPS2PD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPS2PD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtps2pd".
         */
        class CVTPS2PD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPS2PD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CVTDQ2PS(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtdq2ps".
         */
        class CVTDQ2PS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTDQ2PS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtdq2ps".
         */
        class CVTDQ2PS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTDQ2PS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtdq2ps".
         */
        class CVTDQ2PS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTDQ2PS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SUBPS(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "subps".
         */
        class SUBPS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUBPS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "subps".
         */
        class SUBPS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUBPS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "subps".
         */
        class SUBPS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUBPS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MINPS(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "minps".
         */
        class MINPS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MINPS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "minps".
         */
        class MINPS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MINPS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "minps".
         */
        class MINPS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MINPS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::DIVPS(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "divps".
         */
        class DIVPS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            DIVPS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "divps".
         */
        class DIVPS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            DIVPS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "divps".
         */
        class DIVPS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            DIVPS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MAXPS(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "maxps".
         */
        class MAXPS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MAXPS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "maxps".
         */
        class MAXPS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MAXPS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "maxps".
         */
        class MAXPS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MAXPS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::ADDSS(['Vd', 'Wd'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "addss".
         */
        class ADDSS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADDSS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "addss".
         */
        class ADDSS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADDSS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "addss".
         */
        class ADDSS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADDSS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MULSS(['Vd', 'Wd'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mulss".
         */
        class MULSS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MULSS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mulss".
         */
        class MULSS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MULSS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mulss".
         */
        class MULSS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MULSS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CVTSS2SD(['Vq', 'Wd'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtss2sd".
         */
        class CVTSS2SD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTSS2SD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtss2sd".
         */
        class CVTSS2SD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTSS2SD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtss2sd".
         */
        class CVTSS2SD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTSS2SD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CVTTPS2DQ(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvttps2dq".
         */
        class CVTTPS2DQ_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTTPS2DQ_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvttps2dq".
         */
        class CVTTPS2DQ_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTTPS2DQ_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvttps2dq".
         */
        class CVTTPS2DQ_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTTPS2DQ_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SUBSS(['Vd', 'Wd'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "subss".
         */
        class SUBSS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUBSS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "subss".
         */
        class SUBSS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUBSS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "subss".
         */
        class SUBSS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUBSS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MINSS(['Vd', 'Wd'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "minss".
         */
        class MINSS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MINSS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "minss".
         */
        class MINSS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MINSS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "minss".
         */
        class MINSS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MINSS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::DIVSS(['Vd', 'Wd'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "divss".
         */
        class DIVSS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            DIVSS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "divss".
         */
        class DIVSS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            DIVSS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "divss".
         */
        class DIVSS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            DIVSS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MAXSS(['Vd', 'Wd'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "maxss".
         */
        class MAXSS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MAXSS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "maxss".
         */
        class MAXSS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MAXSS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "maxss".
         */
        class MAXSS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MAXSS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::ADDPD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "addpd".
         */
        class ADDPD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADDPD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "addpd".
         */
        class ADDPD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADDPD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "addpd".
         */
        class ADDPD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADDPD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MULPD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mulpd".
         */
        class MULPD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MULPD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mulpd".
         */
        class MULPD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MULPD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mulpd".
         */
        class MULPD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MULPD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CVTPD2PS(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtpd2ps".
         */
        class CVTPD2PS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPD2PS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtpd2ps".
         */
        class CVTPD2PS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPD2PS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtpd2ps".
         */
        class CVTPD2PS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPD2PS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CVTPS2DQ(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtps2dq".
         */
        class CVTPS2DQ_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPS2DQ_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtps2dq".
         */
        class CVTPS2DQ_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPS2DQ_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtps2dq".
         */
        class CVTPS2DQ_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPS2DQ_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SUBPD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "subpd".
         */
        class SUBPD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUBPD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "subpd".
         */
        class SUBPD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUBPD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "subpd".
         */
        class SUBPD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUBPD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MINPD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "minpd".
         */
        class MINPD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MINPD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "minpd".
         */
        class MINPD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MINPD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "minpd".
         */
        class MINPD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MINPD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::DIVPD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "divpd".
         */
        class DIVPD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            DIVPD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "divpd".
         */
        class DIVPD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            DIVPD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "divpd".
         */
        class DIVPD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            DIVPD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MAXPD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "maxpd".
         */
        class MAXPD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MAXPD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "maxpd".
         */
        class MAXPD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MAXPD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "maxpd".
         */
        class MAXPD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MAXPD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::ADDSD(['Vq', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "addsd".
         */
        class ADDSD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADDSD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "addsd".
         */
        class ADDSD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADDSD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "addsd".
         */
        class ADDSD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADDSD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MULSD(['Vq', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mulsd".
         */
        class MULSD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MULSD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mulsd".
         */
        class MULSD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MULSD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "mulsd".
         */
        class MULSD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MULSD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CVTSD2SS(['Vd', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtsd2ss".
         */
        class CVTSD2SS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTSD2SS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtsd2ss".
         */
        class CVTSD2SS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTSD2SS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtsd2ss".
         */
        class CVTSD2SS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTSD2SS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SUBSD(['Vq', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "subsd".
         */
        class SUBSD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUBSD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "subsd".
         */
        class SUBSD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUBSD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "subsd".
         */
        class SUBSD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUBSD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MINSD(['Vq', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "minsd".
         */
        class MINSD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MINSD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "minsd".
         */
        class MINSD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MINSD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "minsd".
         */
        class MINSD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MINSD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::DIVSD(['Vq', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "divsd".
         */
        class DIVSD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            DIVSD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "divsd".
         */
        class DIVSD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            DIVSD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "divsd".
         */
        class DIVSD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            DIVSD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MAXSD(['Vq', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "maxsd".
         */
        class MAXSD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MAXSD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "maxsd".
         */
        class MAXSD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MAXSD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "maxsd".
         */
        class MAXSD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MAXSD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::UD2([],{})

// Inst::PUNPCKLBW(['Pq', 'Qd'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpcklbw".
         */
        class PUNPCKLBW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLBW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpcklbw".
         */
        class PUNPCKLBW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLBW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpcklbw".
         */
        class PUNPCKLBW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLBW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PUNPCKLWD(['Pq', 'Qd'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpcklwd".
         */
        class PUNPCKLWD_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLWD_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpcklwd".
         */
        class PUNPCKLWD_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLWD_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpcklwd".
         */
        class PUNPCKLWD_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLWD_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PUNPCKLDQ(['Pq', 'Qd'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckldq".
         */
        class PUNPCKLDQ_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLDQ_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckldq".
         */
        class PUNPCKLDQ_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLDQ_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckldq".
         */
        class PUNPCKLDQ_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLDQ_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PACKSSWB(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "packsswb".
         */
        class PACKSSWB_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PACKSSWB_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "packsswb".
         */
        class PACKSSWB_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PACKSSWB_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "packsswb".
         */
        class PACKSSWB_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PACKSSWB_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PCMPGTB(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpgtb".
         */
        class PCMPGTB_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPGTB_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpgtb".
         */
        class PCMPGTB_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPGTB_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpgtb".
         */
        class PCMPGTB_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPGTB_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PCMPGTW(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpgtw".
         */
        class PCMPGTW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPGTW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpgtw".
         */
        class PCMPGTW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPGTW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpgtw".
         */
        class PCMPGTW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPGTW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PCMPGTD(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpgtd".
         */
        class PCMPGTD_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPGTD_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpgtd".
         */
        class PCMPGTD_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPGTD_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpgtd".
         */
        class PCMPGTD_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPGTD_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PACKUSWB(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "packuswb".
         */
        class PACKUSWB_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PACKUSWB_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "packuswb".
         */
        class PACKUSWB_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PACKUSWB_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "packuswb".
         */
        class PACKUSWB_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PACKUSWB_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::PUNPCKLBW(['Vo', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpcklbw".
         */
        class PUNPCKLBW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLBW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpcklbw".
         */
        class PUNPCKLBW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLBW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpcklbw".
         */
        class PUNPCKLBW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLBW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PUNPCKLWD(['Vo', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpcklwd".
         */
        class PUNPCKLWD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLWD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpcklwd".
         */
        class PUNPCKLWD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLWD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpcklwd".
         */
        class PUNPCKLWD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLWD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PUNPCKLDQ(['Vo', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckldq".
         */
        class PUNPCKLDQ_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLDQ_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckldq".
         */
        class PUNPCKLDQ_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLDQ_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckldq".
         */
        class PUNPCKLDQ_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLDQ_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PACKSSWB(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "packsswb".
         */
        class PACKSSWB_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PACKSSWB_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "packsswb".
         */
        class PACKSSWB_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PACKSSWB_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "packsswb".
         */
        class PACKSSWB_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PACKSSWB_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PCMPGTB(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpgtb".
         */
        class PCMPGTB_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPGTB_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpgtb".
         */
        class PCMPGTB_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPGTB_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpgtb".
         */
        class PCMPGTB_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPGTB_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PCMPGTW(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpgtw".
         */
        class PCMPGTW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPGTW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpgtw".
         */
        class PCMPGTW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPGTW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpgtw".
         */
        class PCMPGTW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPGTW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PCMPGTD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpgtd".
         */
        class PCMPGTD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPGTD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpgtd".
         */
        class PCMPGTD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPGTD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpgtd".
         */
        class PCMPGTD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPGTD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PACKUSWB(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "packuswb".
         */
        class PACKUSWB_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PACKUSWB_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "packuswb".
         */
        class PACKUSWB_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PACKUSWB_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "packuswb".
         */
        class PACKUSWB_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PACKUSWB_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::UD2([],{})

// Inst::PUNPCKHBW(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhbw".
         */
        class PUNPCKHBW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHBW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhbw".
         */
        class PUNPCKHBW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHBW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhbw".
         */
        class PUNPCKHBW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHBW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PUNPCKHWD(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhwd".
         */
        class PUNPCKHWD_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHWD_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhwd".
         */
        class PUNPCKHWD_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHWD_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhwd".
         */
        class PUNPCKHWD_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHWD_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PUNPCKHDQ(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhdq".
         */
        class PUNPCKHDQ_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHDQ_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhdq".
         */
        class PUNPCKHDQ_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHDQ_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhdq".
         */
        class PUNPCKHDQ_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHDQ_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PACKSSDW(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "packssdw".
         */
        class PACKSSDW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PACKSSDW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "packssdw".
         */
        class PACKSSDW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PACKSSDW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "packssdw".
         */
        class PACKSSDW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PACKSSDW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVD(['Pq', 'Edp'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movd".
         */
        class MOVD_MMX_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVD_MMX_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movd".
         */
        class MOVD_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVD_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movd".
         */
        class MOVD_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVD_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVQ(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movq".
         */
        class MOVQ_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVQ_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movq".
         */
        class MOVQ_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVQ_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movq".
         */
        class MOVQ_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVQ_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::MOVDQU(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movdqu".
         */
        class MOVDQU_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVDQU_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movdqu".
         */
        class MOVDQU_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVDQU_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movdqu".
         */
        class MOVDQU_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVDQU_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::PUNPCKHBW(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhbw".
         */
        class PUNPCKHBW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHBW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhbw".
         */
        class PUNPCKHBW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHBW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhbw".
         */
        class PUNPCKHBW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHBW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PUNPCKHWD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhwd".
         */
        class PUNPCKHWD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHWD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhwd".
         */
        class PUNPCKHWD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHWD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhwd".
         */
        class PUNPCKHWD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHWD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PUNPCKHDQ(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhdq".
         */
        class PUNPCKHDQ_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHDQ_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhdq".
         */
        class PUNPCKHDQ_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHDQ_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhdq".
         */
        class PUNPCKHDQ_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHDQ_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PACKSSDW(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "packssdw".
         */
        class PACKSSDW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PACKSSDW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "packssdw".
         */
        class PACKSSDW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PACKSSDW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "packssdw".
         */
        class PACKSSDW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PACKSSDW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PUNPCKLQDQ(['Vo', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpcklqdq".
         */
        class PUNPCKLQDQ_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLQDQ_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpcklqdq".
         */
        class PUNPCKLQDQ_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLQDQ_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpcklqdq".
         */
        class PUNPCKLQDQ_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKLQDQ_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PUNPCKHQDQ(['Vo', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhqdq".
         */
        class PUNPCKHQDQ_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHQDQ_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhqdq".
         */
        class PUNPCKHQDQ_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHQDQ_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "punpckhqdq".
         */
        class PUNPCKHQDQ_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PUNPCKHQDQ_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVD(['Vo', 'Edp'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movd".
         */
        class MOVD_XMM_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVD_XMM_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movd".
         */
        class MOVD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movd".
         */
        class MOVD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVDQA(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movdqa".
         */
        class MOVDQA_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVDQA_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movdqa".
         */
        class MOVDQA_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVDQA_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movdqa".
         */
        class MOVDQA_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVDQA_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::UD2([],{})

// Inst::PSHUFW(['Pq', 'Qq', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pshufw".
         */
        class PSHUFW_MMX_MMX_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSHUFW_MMX_MMX_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pshufw".
         */
        class PSHUFW_MMX_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSHUFW_MMX_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pshufw".
         */
        class PSHUFW_MMX_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSHUFW_MMX_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSRLW(['PRq', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrlw".
         */
        class PSRLW_MMX_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLW_MMX_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSRAW(['PRq', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psraw".
         */
        class PSRAW_MMX_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRAW_MMX_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSLLW(['PRq', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psllw".
         */
        class PSLLW_MMX_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLW_MMX_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::PSRLD(['PRq', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrld".
         */
        class PSRLD_MMX_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLD_MMX_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSRAD(['PRq', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrad".
         */
        class PSRAD_MMX_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRAD_MMX_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSLLD(['PRq', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pslld".
         */
        class PSLLD_MMX_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLD_MMX_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::PSRLQ(['PRq', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrlq".
         */
        class PSRLQ_MMX_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLQ_MMX_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSLLQ(['PRq', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psllq".
         */
        class PSLLQ_MMX_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLQ_MMX_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2(([], {}))

// Inst::PCMPEQB((['Pq', 'Qq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpeqb".
         */
        class PCMPEQB_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPEQB_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpeqb".
         */
        class PCMPEQB_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPEQB_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpeqb".
         */
        class PCMPEQB_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPEQB_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PCMPEQW((['Pq', 'Qq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpeqw".
         */
        class PCMPEQW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPEQW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpeqw".
         */
        class PCMPEQW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPEQW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpeqw".
         */
        class PCMPEQW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPEQW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PCMPEQD((['Pq', 'Qq'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpeqd".
         */
        class PCMPEQD_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPEQD_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpeqd".
         */
        class PCMPEQD_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPEQD_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpeqd".
         */
        class PCMPEQD_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPEQD_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::EMMS(([], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "emms".
         */
        class EMMS : public Macroop
        {
          private:
            
          public:
            // Constructor.
            EMMS(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::PSHUFHW(['Vo', 'Wo', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pshufhw".
         */
        class PSHUFHW_XMM_XMM_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSHUFHW_XMM_XMM_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pshufhw".
         */
        class PSHUFHW_XMM_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSHUFHW_XMM_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pshufhw".
         */
        class PSHUFHW_XMM_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSHUFHW_XMM_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::PSHUFD(['Vo', 'Wo', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pshufd".
         */
        class PSHUFD_XMM_XMM_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSHUFD_XMM_XMM_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pshufd".
         */
        class PSHUFD_XMM_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSHUFD_XMM_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pshufd".
         */
        class PSHUFD_XMM_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSHUFD_XMM_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSRLW(['VRo', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrlw".
         */
        class PSRLW_XMM_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLW_XMM_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSRAW(['VRo', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psraw".
         */
        class PSRAW_XMM_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRAW_XMM_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSLLW(['VRo', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psllw".
         */
        class PSLLW_XMM_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLW_XMM_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::PSRLD(['VRo', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrld".
         */
        class PSRLD_XMM_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLD_XMM_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSRAD(['VRo', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrad".
         */
        class PSRAD_XMM_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRAD_XMM_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSLLD(['VRo', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pslld".
         */
        class PSLLD_XMM_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLD_XMM_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::PSRLQ(['VRo', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrlq".
         */
        class PSRLQ_XMM_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLQ_XMM_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSRLDQ(['VRo', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrldq".
         */
        class PSRLDQ_XMM_I : public Macroop
        {
          private:
            const static uint64_t label_psrldq_less_16 = 9;
const static uint64_t label_psrldq_less_8 = 12;
const static uint64_t label_psrldq_end = 16;

          public:
            // Constructor.
            PSRLDQ_XMM_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSLLQ(['VRo', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psllq".
         */
        class PSLLQ_XMM_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLQ_XMM_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSLLDQ(['VRo', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pslldq".
         */
        class PSLLDQ_XMM_I : public Macroop
        {
          private:
            const static uint64_t label_pslldq_less_16 = 9;
const static uint64_t label_pslldq_less_8 = 12;
const static uint64_t label_pslldq_end = 16;

          public:
            // Constructor.
            PSLLDQ_XMM_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::PCMPEQB(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpeqb".
         */
        class PCMPEQB_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPEQB_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpeqb".
         */
        class PCMPEQB_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPEQB_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpeqb".
         */
        class PCMPEQB_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPEQB_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PCMPEQW(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpeqw".
         */
        class PCMPEQW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPEQW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpeqw".
         */
        class PCMPEQW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPEQW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpeqw".
         */
        class PCMPEQW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPEQW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PCMPEQD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpeqd".
         */
        class PCMPEQD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPEQD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpeqd".
         */
        class PCMPEQD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPEQD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pcmpeqd".
         */
        class PCMPEQD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PCMPEQD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::PSHUFLW(['Vo', 'Wo', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pshuflw".
         */
        class PSHUFLW_XMM_XMM_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSHUFLW_XMM_XMM_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pshuflw".
         */
        class PSHUFLW_XMM_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSHUFLW_XMM_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pshuflw".
         */
        class PSHUFLW_XMM_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSHUFLW_XMM_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::UD2([],{})

// WarnUnimpl::vmread_Edp_Gdp(([], {}))

// WarnUnimpl::vmwrite_Gdp_Edp(([], {}))

// Inst::MOVD(['Edp', 'Pdp'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movd".
         */
        class MOVD_R_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVD_R_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movd".
         */
        class MOVD_M_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVD_M_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movd".
         */
        class MOVD_P_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVD_P_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVQ(['Qq', 'Pq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movq".
         */
        class MOVQ_M_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVQ_M_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movq".
         */
        class MOVQ_P_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVQ_P_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::MOVQ(['Vq', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movq".
         */
        class MOVQ_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVQ_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movq".
         */
        class MOVQ_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVQ_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movq".
         */
        class MOVQ_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVQ_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVDQU(['Wo', 'Vo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movdqu".
         */
        class MOVDQU_M_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVDQU_M_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movdqu".
         */
        class MOVDQU_P_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVDQU_P_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::HADDPD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "haddpd".
         */
        class HADDPD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            HADDPD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "haddpd".
         */
        class HADDPD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            HADDPD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "haddpd".
         */
        class HADDPD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            HADDPD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::HSUBPD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "hsubpd".
         */
        class HSUBPD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            HSUBPD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "hsubpd".
         */
        class HSUBPD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            HSUBPD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "hsubpd".
         */
        class HSUBPD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            HSUBPD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVD(['Edp', 'Vd'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movd".
         */
        class MOVD_R_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVD_R_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movd".
         */
        class MOVD_M_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVD_M_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movd".
         */
        class MOVD_P_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVD_P_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVDQA(['Wo', 'Vo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movdqa".
         */
        class MOVDQA_M_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVDQA_M_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movdqa".
         */
        class MOVDQA_P_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVDQA_P_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::HADDPS(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "haddps".
         */
        class HADDPS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            HADDPS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "haddps".
         */
        class HADDPS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            HADDPS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "haddps".
         */
        class HADDPS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            HADDPS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::HSUBPS(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "hsubps".
         */
        class HSUBPS_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            HSUBPS_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "hsubps".
         */
        class HSUBPS_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            HSUBPS_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "hsubps".
         */
        class HSUBPS_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            HSUBPS_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::UD2([],{})

// Inst::JO(['Jz'],{})

// Inst::JNO(['Jz'],{})

// Inst::JB(['Jz'],{})

// Inst::JNB(['Jz'],{})

// Inst::JZ(['Jz'],{})

// Inst::JNZ(['Jz'],{})

// Inst::JBE(['Jz'],{})

// Inst::JNBE(['Jz'],{})

// Unknown::unknown(([], {}))

// Inst::JS(['Jz'],{})

// Inst::JNS(['Jz'],{})

// Inst::JP(['Jz'],{})

// Inst::JNP(['Jz'],{})

// Inst::JL(['Jz'],{})

// Inst::JNL(['Jz'],{})

// Inst::JLE(['Jz'],{})

// Inst::JNLE(['Jz'],{})

// Unknown::unknown(([], {}))

// Inst::SETO(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "seto".
         */
        class SETO_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETO_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "seto".
         */
        class SETO_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETO_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "seto".
         */
        class SETO_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETO_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SETNO(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setno".
         */
        class SETNO_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNO_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setno".
         */
        class SETNO_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNO_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setno".
         */
        class SETNO_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNO_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SETB(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setb".
         */
        class SETB_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETB_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setb".
         */
        class SETB_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETB_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setb".
         */
        class SETB_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETB_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SETNB(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setnb".
         */
        class SETNB_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNB_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setnb".
         */
        class SETNB_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNB_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setnb".
         */
        class SETNB_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNB_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SETZ(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setz".
         */
        class SETZ_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETZ_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setz".
         */
        class SETZ_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETZ_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setz".
         */
        class SETZ_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETZ_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SETNZ(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setnz".
         */
        class SETNZ_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNZ_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setnz".
         */
        class SETNZ_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNZ_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setnz".
         */
        class SETNZ_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNZ_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SETBE(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setbe".
         */
        class SETBE_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETBE_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setbe".
         */
        class SETBE_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETBE_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setbe".
         */
        class SETBE_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETBE_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SETNBE(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setnbe".
         */
        class SETNBE_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNBE_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setnbe".
         */
        class SETNBE_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNBE_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setnbe".
         */
        class SETNBE_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNBE_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::SETS(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sets".
         */
        class SETS_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETS_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sets".
         */
        class SETS_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETS_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sets".
         */
        class SETS_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETS_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SETNS(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setns".
         */
        class SETNS_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNS_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setns".
         */
        class SETNS_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNS_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setns".
         */
        class SETNS_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNS_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SETP(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setp".
         */
        class SETP_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETP_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setp".
         */
        class SETP_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETP_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setp".
         */
        class SETP_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETP_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SETNP(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setnp".
         */
        class SETNP_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNP_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setnp".
         */
        class SETNP_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNP_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setnp".
         */
        class SETNP_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNP_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SETL(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setl".
         */
        class SETL_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETL_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setl".
         */
        class SETL_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETL_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setl".
         */
        class SETL_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETL_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SETNL(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setnl".
         */
        class SETNL_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNL_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setnl".
         */
        class SETNL_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNL_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setnl".
         */
        class SETNL_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNL_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SETLE(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setle".
         */
        class SETLE_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETLE_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setle".
         */
        class SETLE_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETLE_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setle".
         */
        class SETLE_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETLE_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SETNLE(['Eb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setnle".
         */
        class SETNLE_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNLE_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setnle".
         */
        class SETNLE_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNLE_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "setnle".
         */
        class SETNLE_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SETNLE_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::PUSH((['sFv'], {}))

// Inst::POP_REAL((['sFv'], {}))

// WarnUnimpl::pop_fs([],{})

// CPUIDInst::CPUID((["\n                CpuidResult result;\n                bool success = doCpuid(xc->tcBase(), bits(Rax, 31, 0),\n                    bits(Rcx, 31, 0), result);\n                if (success) {\n                    Rax = result.rax;\n                    Rbx = result.rbx;\n                    Rcx = result.rcx;\n                    Rdx = result.rdx;\n                } else {\n                    // It isn't defined what to do in this case. We used to\n                    // leave R[abcd]x unmodified, but setting them all to 0\n                    // seems a little safer and more predictable.\n                    Rax = 0;\n                    Rbx = 0;\n                    Rcx = 0;\n                    Rdx = 0;\n                }\n                "], {}))

    /**
     * Static instruction class for "CPUID".
     */
    class CPUID : public CPUIDInst
    {
      private:
        RegId srcRegIdxArr[2]; RegId destRegIdxArr[4];

      public:
        // Constructor.
        CPUID(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

// Inst::BT((['Ev', 'Gv'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bt".
         */
        class BT_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BT_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bt".
         */
        class BT_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BT_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bt".
         */
        class BT_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BT_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SHLD((['Ev', 'Gv', 'Ib'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shld".
         */
        class SHLD_R_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHLD_R_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shld".
         */
        class SHLD_M_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHLD_M_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shld".
         */
        class SHLD_P_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHLD_P_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SHLD((['Ev', 'Gv'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shld".
         */
        class SHLD_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHLD_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shld".
         */
        class SHLD_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHLD_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shld".
         */
        class SHLD_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHLD_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2(([], {}))

// Inst::PUSH((['sGv'], {}))

// Inst::POP_REAL((['sGv'], {}))

// WarnUnimpl::pop_gs([],{})

// WarnUnimpl::rsm_smm([],{})

// Inst::BTS((['Ev', 'Gv'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bts".
         */
        class BTS_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTS_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bts".
         */
        class BTS_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTS_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bts".
         */
        class BTS_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTS_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SHRD((['Ev', 'Gv', 'Ib'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shrd".
         */
        class SHRD_R_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHRD_R_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shrd".
         */
        class SHRD_M_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHRD_M_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shrd".
         */
        class SHRD_P_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHRD_P_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SHRD((['Ev', 'Gv'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shrd".
         */
        class SHRD_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHRD_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shrd".
         */
        class SHRD_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHRD_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shrd".
         */
        class SHRD_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHRD_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// BasicOperate::LFENCE((['/*Nothing*/', 'IsReadBarrier', 'IsSerializeAfter'], {}))

    /**
     * Static instruction class for "LFENCE".
     */
    class LFENCE : public X86ISA::X86StaticInst
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        // Constructor.
        LFENCE(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

// BasicOperate::MFENCE((['/*Nothing*/', 'IsReadBarrier', 'IsWriteBarrier'], {}))

    /**
     * Static instruction class for "MFENCE".
     */
    class MFENCE : public X86ISA::X86StaticInst
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        // Constructor.
        MFENCE(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

// BasicOperate::SFENCE((['/*Nothing*/', 'IsWriteBarrier'], {}))

    /**
     * Static instruction class for "SFENCE".
     */
    class SFENCE : public X86ISA::X86StaticInst
    {
      private:
        RegId srcRegIdxArr[0]; RegId destRegIdxArr[0];

      public:
        // Constructor.
        SFENCE(ExtMachInst machInst);
        Fault execute(ExecContext *, trace::InstRecord *) const override;
    };

// Inst::UD2(([], {}))

// Inst::FXSAVE((['M'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fxsave".
         */
        class FXSAVE_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FXSAVE_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fxsave".
         */
        class FXSAVE_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FXSAVE_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FXSAVE64((['M'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fxsave64".
         */
        class FXSAVE64_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FXSAVE64_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fxsave64".
         */
        class FXSAVE64_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FXSAVE64_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::fxsave([],{})

// Inst::FXRSTOR((['M'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fxrstor".
         */
        class FXRSTOR_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FXRSTOR_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fxrstor".
         */
        class FXRSTOR_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FXRSTOR_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::FXRSTOR64((['M'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fxrstor64".
         */
        class FXRSTOR64_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FXRSTOR64_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "fxrstor64".
         */
        class FXRSTOR64_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            FXRSTOR64_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::fxrstor([],{})

// Inst::LDMXCSR((['Md'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ldmxcsr".
         */
        class LDMXCSR_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LDMXCSR_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "ldmxcsr".
         */
        class LDMXCSR_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LDMXCSR_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::STMXCSR((['Md'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "stmxcsr".
         */
        class STMXCSR_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            STMXCSR_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "stmxcsr".
         */
        class STMXCSR_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            STMXCSR_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::xsave([],{})

// WarnUnimpl::xrstor([],{})

// Inst::UD2(([], {}))

// Inst::CLWB((['Mb'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "clwb".
         */
        class CLWB_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CLWB_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "clwb".
         */
        class CLWB_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CLWB_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2(([], {}))

// Inst::CLFLUSH((['Mb'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "clflush".
         */
        class CLFLUSH_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CLFLUSH_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "clflush".
         */
        class CLFLUSH_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CLFLUSH_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CLFLUSHOPT((['Mb'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "clflushopt".
         */
        class CLFLUSHOPT_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CLFLUSHOPT_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "clflushopt".
         */
        class CLFLUSHOPT_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CLFLUSHOPT_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CLFLUSH((['Mb'], {}))

// Unknown::unknown(([], {}))

// Inst::IMUL((['Gv', 'Ev'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "imul".
         */
        class IMUL_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            IMUL_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "imul".
         */
        class IMUL_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            IMUL_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "imul".
         */
        class IMUL_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            IMUL_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::CMPXCHG(['Eb', 'Gb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmpxchg".
         */
        class CMPXCHG_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMPXCHG_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmpxchg".
         */
        class CMPXCHG_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMPXCHG_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmpxchg".
         */
        class CMPXCHG_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMPXCHG_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CMPXCHG(['Ev', 'Gv'],{})

// Inst::LSS_REAL(['Gz', 'Mz'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lss".
         */
        class LSS_REAL_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LSS_REAL_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lss".
         */
        class LSS_REAL_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LSS_REAL_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::lss_Gz_Mp(([], {}))

// Inst::BTR(['Ev', 'Gv'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "btr".
         */
        class BTR_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTR_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "btr".
         */
        class BTR_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTR_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "btr".
         */
        class BTR_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTR_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::LFS_REAL(['Gz', 'Mz'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lfs".
         */
        class LFS_REAL_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LFS_REAL_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lfs".
         */
        class LFS_REAL_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LFS_REAL_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::lfs_Gz_Mp(([], {}))

// Inst::LGS_REAL(['Gz', 'Mz'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lgs".
         */
        class LGS_REAL_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LGS_REAL_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lgs".
         */
        class LGS_REAL_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LGS_REAL_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::lgs_Gz_Mp(([], {}))

// Inst::MOVZX_B(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movzx".
         */
        class MOVZX_B_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVZX_B_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movzx".
         */
        class MOVZX_B_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVZX_B_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movzx".
         */
        class MOVZX_B_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVZX_B_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVZX_W(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movzx".
         */
        class MOVZX_W_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVZX_W_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movzx".
         */
        class MOVZX_W_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVZX_W_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movzx".
         */
        class MOVZX_W_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVZX_W_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::POPCNT(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "popcnt".
         */
        class POPCNT_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            POPCNT_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "popcnt".
         */
        class POPCNT_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            POPCNT_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "popcnt".
         */
        class POPCNT_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            POPCNT_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::UD2([],{})

// Inst::BT(['Ev', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bt".
         */
        class BT_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BT_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bt".
         */
        class BT_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BT_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bt".
         */
        class BT_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BT_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::BTS(['Ev', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bts".
         */
        class BTS_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTS_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bts".
         */
        class BTS_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTS_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bts".
         */
        class BTS_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTS_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::BTR(['Ev', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "btr".
         */
        class BTR_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTR_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "btr".
         */
        class BTR_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTR_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "btr".
         */
        class BTR_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTR_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::BTC(['Ev', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "btc".
         */
        class BTC_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTC_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "btc".
         */
        class BTC_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTC_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "btc".
         */
        class BTC_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTC_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::BTC(['Ev', 'Gv'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "btc".
         */
        class BTC_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTC_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "btc".
         */
        class BTC_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTC_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "btc".
         */
        class BTC_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTC_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::BSF(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bsf".
         */
        class BSF_R_R : public Macroop
        {
          private:
            const static uint64_t label_end = 29;

          public:
            // Constructor.
            BSF_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bsf".
         */
        class BSF_R_M : public Macroop
        {
          private:
            const static uint64_t label_end = 31;

          public:
            // Constructor.
            BSF_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bsf".
         */
        class BSF_R_P : public Macroop
        {
          private:
            const static uint64_t label_end = 32;

          public:
            // Constructor.
            BSF_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::BSR(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bsr".
         */
        class BSR_R_R : public Macroop
        {
          private:
            const static uint64_t label_end = 27;

          public:
            // Constructor.
            BSR_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bsr".
         */
        class BSR_R_M : public Macroop
        {
          private:
            const static uint64_t label_end = 28;

          public:
            // Constructor.
            BSR_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bsr".
         */
        class BSR_R_P : public Macroop
        {
          private:
            const static uint64_t label_end = 29;

          public:
            // Constructor.
            BSR_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVSX_B(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movsx".
         */
        class MOVSX_B_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVSX_B_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movsx".
         */
        class MOVSX_B_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVSX_B_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movsx".
         */
        class MOVSX_B_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVSX_B_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVSX_W(['Gv', 'Ev'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movsx".
         */
        class MOVSX_W_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVSX_W_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movsx".
         */
        class MOVSX_W_R_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVSX_W_R_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movsx".
         */
        class MOVSX_W_R_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVSX_W_R_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::XADD(['Eb', 'Gb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xadd".
         */
        class XADD_R_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XADD_R_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xadd".
         */
        class XADD_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XADD_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xadd".
         */
        class XADD_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XADD_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::XADD(['Ev', 'Gv'],{})

// Inst::CMPXCHG8B(['Mdp'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmpxchg8b".
         */
        class CMPXCHG8B_M : public Macroop
        {
          private:
            const static uint64_t label_doneComparing = 5;

          public:
            // Constructor.
            CMPXCHG8B_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmpxchg8b".
         */
        class CMPXCHG8B_P : public Macroop
        {
          private:
            const static uint64_t label_doneComparing = 6;

          public:
            // Constructor.
            CMPXCHG8B_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::vmclear_Mq(([], {}))

// WarnUnimpl::vmxon_Mq(([], {}))

// WarnUnimpl::vmptrld_Mq(([], {}))

// Unknown::unknown(([], {}))

// WarnUnimpl::vmptrst_Mq(([], {}))

// Inst::UD2([],{})

// Inst::CMPPS(['Vo', 'Wo', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmpps".
         */
        class CMPPS_XMM_XMM_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMPPS_XMM_XMM_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmpps".
         */
        class CMPPS_XMM_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMPPS_XMM_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmpps".
         */
        class CMPPS_XMM_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMPPS_XMM_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVNTI(['Mdp', 'Gdp'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movnti".
         */
        class MOVNTI_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVNTI_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movnti".
         */
        class MOVNTI_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVNTI_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PINSRW(['Pq', 'Ew', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pinsrw".
         */
        class PINSRW_MMX_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PINSRW_MMX_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pinsrw".
         */
        class PINSRW_MMX_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PINSRW_MMX_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pinsrw".
         */
        class PINSRW_MMX_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PINSRW_MMX_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PEXTRW(['Gd', 'PRq', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pextrw".
         */
        class PEXTRW_R_MMX_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PEXTRW_R_MMX_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SHUFPS(['Vps', 'Wps', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shufps".
         */
        class SHUFPS_XMM_XMM_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHUFPS_XMM_XMM_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shufps".
         */
        class SHUFPS_XMM_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHUFPS_XMM_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shufps".
         */
        class SHUFPS_XMM_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHUFPS_XMM_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::CMPSS(['Vd', 'Wd', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmpss".
         */
        class CMPSS_XMM_XMM_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMPSS_XMM_XMM_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmpss".
         */
        class CMPSS_XMM_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMPSS_XMM_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmpss".
         */
        class CMPSS_XMM_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMPSS_XMM_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::CMPPD(['Vo', 'Wo', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmppd".
         */
        class CMPPD_XMM_XMM_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMPPD_XMM_XMM_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmppd".
         */
        class CMPPD_XMM_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMPPD_XMM_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmppd".
         */
        class CMPPD_XMM_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMPPD_XMM_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PINSRW(['Vdw', 'Ew', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pinsrw".
         */
        class PINSRW_XMM_R_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PINSRW_XMM_R_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pinsrw".
         */
        class PINSRW_XMM_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PINSRW_XMM_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pinsrw".
         */
        class PINSRW_XMM_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PINSRW_XMM_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PEXTRW(['Gd', 'VRdq', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pextrw".
         */
        class PEXTRW_R_XMM_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PEXTRW_R_XMM_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SHUFPD(['Vpd', 'Wpd', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shufpd".
         */
        class SHUFPD_XMM_XMM_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHUFPD_XMM_XMM_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shufpd".
         */
        class SHUFPD_XMM_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHUFPD_XMM_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "shufpd".
         */
        class SHUFPD_XMM_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SHUFPD_XMM_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::CMPSD(['Vq', 'Wq', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmpsd".
         */
        class CMPSD_XMM_XMM_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMPSD_XMM_XMM_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmpsd".
         */
        class CMPSD_XMM_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMPSD_XMM_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmpsd".
         */
        class CMPSD_XMM_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMPSD_XMM_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::UD2([],{})

// Inst::BSWAP_D(['Bd'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bswap".
         */
        class BSWAP_D_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BSWAP_D_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::BSWAP_Q(['Bq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bswap".
         */
        class BSWAP_Q_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BSWAP_Q_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::PSRLW(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrlw".
         */
        class PSRLW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrlw".
         */
        class PSRLW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrlw".
         */
        class PSRLW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSRLD(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrld".
         */
        class PSRLD_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLD_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrld".
         */
        class PSRLD_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLD_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrld".
         */
        class PSRLD_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLD_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSRLQ(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrlq".
         */
        class PSRLQ_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLQ_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrlq".
         */
        class PSRLQ_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLQ_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrlq".
         */
        class PSRLQ_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLQ_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PADDQ(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddq".
         */
        class PADDQ_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDQ_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddq".
         */
        class PADDQ_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDQ_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddq".
         */
        class PADDQ_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDQ_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PMULLW(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmullw".
         */
        class PMULLW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULLW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmullw".
         */
        class PMULLW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULLW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmullw".
         */
        class PMULLW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULLW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PMOVMSKB(['Gd', 'PRq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmovmskb".
         */
        class PMOVMSKB_R_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMOVMSKB_R_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::MOVQ2DQ(['Vo', 'PRq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movq2dq".
         */
        class MOVQ2DQ_XMM_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVQ2DQ_XMM_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::ADDSUBPD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "addsubpd".
         */
        class ADDSUBPD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADDSUBPD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "addsubpd".
         */
        class ADDSUBPD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADDSUBPD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "addsubpd".
         */
        class ADDSUBPD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADDSUBPD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSRLW(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrlw".
         */
        class PSRLW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrlw".
         */
        class PSRLW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrlw".
         */
        class PSRLW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSRLD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrld".
         */
        class PSRLD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrld".
         */
        class PSRLD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrld".
         */
        class PSRLD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSRLQ(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrlq".
         */
        class PSRLQ_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLQ_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrlq".
         */
        class PSRLQ_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLQ_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrlq".
         */
        class PSRLQ_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRLQ_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PADDQ(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddq".
         */
        class PADDQ_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDQ_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddq".
         */
        class PADDQ_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDQ_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddq".
         */
        class PADDQ_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDQ_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PMULLW(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmullw".
         */
        class PMULLW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULLW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmullw".
         */
        class PMULLW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULLW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmullw".
         */
        class PMULLW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULLW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVQ(['Wq', 'Vq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movq".
         */
        class MOVQ_M_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVQ_M_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movq".
         */
        class MOVQ_P_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVQ_P_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PMOVMSKB(['Gd', 'VRo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmovmskb".
         */
        class PMOVMSKB_R_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMOVMSKB_R_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// WarnUnimpl::addsubps_Vo_Wo(([], {}))

// Inst::MOVDQ2Q(['Pq', 'VRq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movdq2q".
         */
        class MOVDQ2Q_MMX_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVDQ2Q_MMX_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::UD2([],{})

// Inst::PSUBUSB(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubusb".
         */
        class PSUBUSB_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBUSB_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubusb".
         */
        class PSUBUSB_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBUSB_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubusb".
         */
        class PSUBUSB_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBUSB_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSUBUSW(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubusw".
         */
        class PSUBUSW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBUSW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubusw".
         */
        class PSUBUSW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBUSW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubusw".
         */
        class PSUBUSW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBUSW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PMINUB(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pminub".
         */
        class PMINUB_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMINUB_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pminub".
         */
        class PMINUB_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMINUB_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pminub".
         */
        class PMINUB_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMINUB_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PAND(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pand".
         */
        class PAND_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PAND_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pand".
         */
        class PAND_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PAND_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pand".
         */
        class PAND_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PAND_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PADDUSB(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddusb".
         */
        class PADDUSB_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDUSB_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddusb".
         */
        class PADDUSB_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDUSB_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddusb".
         */
        class PADDUSB_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDUSB_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PADDUSW(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddusw".
         */
        class PADDUSW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDUSW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddusw".
         */
        class PADDUSW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDUSW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddusw".
         */
        class PADDUSW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDUSW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PMAXUB(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmaxub".
         */
        class PMAXUB_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMAXUB_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmaxub".
         */
        class PMAXUB_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMAXUB_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmaxub".
         */
        class PMAXUB_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMAXUB_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PANDN(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pandn".
         */
        class PANDN_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PANDN_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pandn".
         */
        class PANDN_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PANDN_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pandn".
         */
        class PANDN_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PANDN_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::PSUBUSB(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubusb".
         */
        class PSUBUSB_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBUSB_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubusb".
         */
        class PSUBUSB_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBUSB_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubusb".
         */
        class PSUBUSB_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBUSB_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSUBUSW(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubusw".
         */
        class PSUBUSW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBUSW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubusw".
         */
        class PSUBUSW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBUSW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubusw".
         */
        class PSUBUSW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBUSW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PMINUB(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pminub".
         */
        class PMINUB_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMINUB_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pminub".
         */
        class PMINUB_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMINUB_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pminub".
         */
        class PMINUB_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMINUB_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PAND(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pand".
         */
        class PAND_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PAND_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pand".
         */
        class PAND_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PAND_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pand".
         */
        class PAND_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PAND_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PADDUSB(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddusb".
         */
        class PADDUSB_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDUSB_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddusb".
         */
        class PADDUSB_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDUSB_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddusb".
         */
        class PADDUSB_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDUSB_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PADDUSW(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddusw".
         */
        class PADDUSW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDUSW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddusw".
         */
        class PADDUSW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDUSW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddusw".
         */
        class PADDUSW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDUSW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PMAXUB(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmaxub".
         */
        class PMAXUB_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMAXUB_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmaxub".
         */
        class PMAXUB_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMAXUB_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmaxub".
         */
        class PMAXUB_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMAXUB_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PANDN(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pandn".
         */
        class PANDN_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PANDN_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pandn".
         */
        class PANDN_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PANDN_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pandn".
         */
        class PANDN_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PANDN_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::UD2([],{})

// Inst::PAVGB(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pavgb".
         */
        class PAVGB_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PAVGB_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pavgb".
         */
        class PAVGB_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PAVGB_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pavgb".
         */
        class PAVGB_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PAVGB_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSRAW(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psraw".
         */
        class PSRAW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRAW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psraw".
         */
        class PSRAW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRAW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psraw".
         */
        class PSRAW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRAW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSRAD(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrad".
         */
        class PSRAD_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRAD_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrad".
         */
        class PSRAD_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRAD_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrad".
         */
        class PSRAD_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRAD_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PAVGW(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pavgw".
         */
        class PAVGW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PAVGW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pavgw".
         */
        class PAVGW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PAVGW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pavgw".
         */
        class PAVGW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PAVGW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PMULHUW(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmulhuw".
         */
        class PMULHUW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULHUW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmulhuw".
         */
        class PMULHUW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULHUW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmulhuw".
         */
        class PMULHUW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULHUW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PMULHW(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmulhw".
         */
        class PMULHW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULHW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmulhw".
         */
        class PMULHW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULHW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmulhw".
         */
        class PMULHW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULHW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVNTQ(['Mq', 'Pq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movntq".
         */
        class MOVNTQ_M_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVNTQ_M_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movntq".
         */
        class MOVNTQ_P_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVNTQ_P_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::CVTDQ2PD(['Vo', 'Wq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtdq2pd".
         */
        class CVTDQ2PD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTDQ2PD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtdq2pd".
         */
        class CVTDQ2PD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTDQ2PD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtdq2pd".
         */
        class CVTDQ2PD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTDQ2PD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::PAVGB(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pavgb".
         */
        class PAVGB_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PAVGB_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pavgb".
         */
        class PAVGB_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PAVGB_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pavgb".
         */
        class PAVGB_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PAVGB_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSRAW(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psraw".
         */
        class PSRAW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRAW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psraw".
         */
        class PSRAW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRAW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psraw".
         */
        class PSRAW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRAW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSRAD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrad".
         */
        class PSRAD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRAD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrad".
         */
        class PSRAD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRAD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psrad".
         */
        class PSRAD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSRAD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PAVGW(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pavgw".
         */
        class PAVGW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PAVGW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pavgw".
         */
        class PAVGW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PAVGW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pavgw".
         */
        class PAVGW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PAVGW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PMULHUW(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmulhuw".
         */
        class PMULHUW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULHUW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmulhuw".
         */
        class PMULHUW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULHUW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmulhuw".
         */
        class PMULHUW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULHUW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PMULHW(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmulhw".
         */
        class PMULHW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULHW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmulhw".
         */
        class PMULHW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULHW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmulhw".
         */
        class PMULHW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULHW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CVTTPD2DQ(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvttpd2dq".
         */
        class CVTTPD2DQ_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTTPD2DQ_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvttpd2dq".
         */
        class CVTTPD2DQ_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTTPD2DQ_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvttpd2dq".
         */
        class CVTTPD2DQ_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTTPD2DQ_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MOVNTDQ(['Mq', 'Vq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movntdq".
         */
        class MOVNTDQ_M_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVNTDQ_M_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "movntdq".
         */
        class MOVNTDQ_P_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MOVNTDQ_P_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::CVTPD2DQ(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtpd2dq".
         */
        class CVTPD2DQ_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPD2DQ_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtpd2dq".
         */
        class CVTPD2DQ_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPD2DQ_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cvtpd2dq".
         */
        class CVTPD2DQ_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CVTPD2DQ_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::UD2([],{})

// Inst::PSUBSB(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubsb".
         */
        class PSUBSB_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBSB_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubsb".
         */
        class PSUBSB_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBSB_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubsb".
         */
        class PSUBSB_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBSB_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSUBSW(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubsw".
         */
        class PSUBSW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBSW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubsw".
         */
        class PSUBSW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBSW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubsw".
         */
        class PSUBSW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBSW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PMINSW(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pminsw".
         */
        class PMINSW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMINSW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pminsw".
         */
        class PMINSW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMINSW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pminsw".
         */
        class PMINSW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMINSW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::POR(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "por".
         */
        class POR_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            POR_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "por".
         */
        class POR_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            POR_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "por".
         */
        class POR_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            POR_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PADDSB(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddsb".
         */
        class PADDSB_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDSB_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddsb".
         */
        class PADDSB_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDSB_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddsb".
         */
        class PADDSB_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDSB_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PADDSW(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddsw".
         */
        class PADDSW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDSW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddsw".
         */
        class PADDSW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDSW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddsw".
         */
        class PADDSW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDSW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PMAXSW(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmaxsw".
         */
        class PMAXSW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMAXSW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmaxsw".
         */
        class PMAXSW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMAXSW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmaxsw".
         */
        class PMAXSW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMAXSW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PXOR(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pxor".
         */
        class PXOR_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PXOR_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pxor".
         */
        class PXOR_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PXOR_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pxor".
         */
        class PXOR_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PXOR_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::PSUBSB(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubsb".
         */
        class PSUBSB_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBSB_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubsb".
         */
        class PSUBSB_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBSB_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubsb".
         */
        class PSUBSB_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBSB_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSUBSW(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubsw".
         */
        class PSUBSW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBSW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubsw".
         */
        class PSUBSW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBSW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubsw".
         */
        class PSUBSW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBSW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PMINSW(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pminsw".
         */
        class PMINSW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMINSW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pminsw".
         */
        class PMINSW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMINSW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pminsw".
         */
        class PMINSW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMINSW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::POR(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "por".
         */
        class POR_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            POR_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "por".
         */
        class POR_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            POR_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "por".
         */
        class POR_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            POR_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PADDSB(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddsb".
         */
        class PADDSB_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDSB_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddsb".
         */
        class PADDSB_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDSB_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddsb".
         */
        class PADDSB_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDSB_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PADDSW(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddsw".
         */
        class PADDSW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDSW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddsw".
         */
        class PADDSW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDSW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddsw".
         */
        class PADDSW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDSW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PMAXSW(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmaxsw".
         */
        class PMAXSW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMAXSW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmaxsw".
         */
        class PMAXSW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMAXSW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmaxsw".
         */
        class PMAXSW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMAXSW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PXOR(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pxor".
         */
        class PXOR_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PXOR_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pxor".
         */
        class PXOR_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PXOR_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pxor".
         */
        class PXOR_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PXOR_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::UD2([],{})

// Inst::PSLLW(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psllw".
         */
        class PSLLW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psllw".
         */
        class PSLLW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psllw".
         */
        class PSLLW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSLLD(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pslld".
         */
        class PSLLD_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLD_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pslld".
         */
        class PSLLD_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLD_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pslld".
         */
        class PSLLD_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLD_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSLLQ(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psllq".
         */
        class PSLLQ_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLQ_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psllq".
         */
        class PSLLQ_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLQ_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psllq".
         */
        class PSLLQ_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLQ_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PMULUDQ(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmuludq".
         */
        class PMULUDQ_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULUDQ_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmuludq".
         */
        class PMULUDQ_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULUDQ_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmuludq".
         */
        class PMULUDQ_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULUDQ_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PMADDWD(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmaddwd".
         */
        class PMADDWD_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMADDWD_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmaddwd".
         */
        class PMADDWD_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMADDWD_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmaddwd".
         */
        class PMADDWD_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMADDWD_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSADBW(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psadbw".
         */
        class PSADBW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSADBW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psadbw".
         */
        class PSADBW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSADBW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psadbw".
         */
        class PSADBW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSADBW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MASKMOVQ(['Pq', 'PRq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "maskmovq".
         */
        class MASKMOVQ_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MASKMOVQ_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::PSLLW(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psllw".
         */
        class PSLLW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psllw".
         */
        class PSLLW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psllw".
         */
        class PSLLW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSLLD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pslld".
         */
        class PSLLD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pslld".
         */
        class PSLLD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pslld".
         */
        class PSLLD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSLLQ(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psllq".
         */
        class PSLLQ_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLQ_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psllq".
         */
        class PSLLQ_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLQ_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psllq".
         */
        class PSLLQ_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSLLQ_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PMULUDQ(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmuludq".
         */
        class PMULUDQ_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULUDQ_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmuludq".
         */
        class PMULUDQ_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULUDQ_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmuludq".
         */
        class PMULUDQ_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMULUDQ_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PMADDWD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmaddwd".
         */
        class PMADDWD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMADDWD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmaddwd".
         */
        class PMADDWD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMADDWD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pmaddwd".
         */
        class PMADDWD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PMADDWD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSADBW(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psadbw".
         */
        class PSADBW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSADBW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psadbw".
         */
        class PSADBW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSADBW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psadbw".
         */
        class PSADBW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSADBW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::MASKMOVDQU(['Vo', 'VRo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "maskmovdqu".
         */
        class MASKMOVDQU_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            MASKMOVDQU_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::LDDQU(['Vo', 'Mq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lddqu".
         */
        class LDDQU_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LDDQU_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "lddqu".
         */
        class LDDQU_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            LDDQU_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::UD2([],{})

// Inst::PSUBB(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubb".
         */
        class PSUBB_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBB_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubb".
         */
        class PSUBB_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBB_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubb".
         */
        class PSUBB_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBB_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSUBW(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubw".
         */
        class PSUBW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubw".
         */
        class PSUBW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubw".
         */
        class PSUBW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSUBD(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubd".
         */
        class PSUBD_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBD_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubd".
         */
        class PSUBD_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBD_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubd".
         */
        class PSUBD_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBD_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSUBQ(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubq".
         */
        class PSUBQ_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBQ_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubq".
         */
        class PSUBQ_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBQ_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubq".
         */
        class PSUBQ_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBQ_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PADDB(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddb".
         */
        class PADDB_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDB_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddb".
         */
        class PADDB_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDB_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddb".
         */
        class PADDB_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDB_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PADDW(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddw".
         */
        class PADDW_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDW_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddw".
         */
        class PADDW_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDW_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddw".
         */
        class PADDW_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDW_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PADDD(['Pq', 'Qq'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddd".
         */
        class PADDD_MMX_MMX : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDD_MMX_MMX(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddd".
         */
        class PADDD_MMX_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDD_MMX_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddd".
         */
        class PADDD_MMX_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDD_MMX_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Unknown::unknown(([], {}))

// Inst::PSUBB(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubb".
         */
        class PSUBB_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBB_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubb".
         */
        class PSUBB_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBB_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubb".
         */
        class PSUBB_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBB_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSUBW(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubw".
         */
        class PSUBW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubw".
         */
        class PSUBW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubw".
         */
        class PSUBW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSUBD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubd".
         */
        class PSUBD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubd".
         */
        class PSUBD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubd".
         */
        class PSUBD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PSUBQ(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubq".
         */
        class PSUBQ_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBQ_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubq".
         */
        class PSUBQ_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBQ_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "psubq".
         */
        class PSUBQ_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSUBQ_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PADDB(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddb".
         */
        class PADDB_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDB_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddb".
         */
        class PADDB_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDB_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddb".
         */
        class PADDB_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDB_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PADDW(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddw".
         */
        class PADDW_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDW_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddw".
         */
        class PADDW_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDW_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddw".
         */
        class PADDW_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDW_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::PADDD(['Vo', 'Wo'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddd".
         */
        class PADDD_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDD_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddd".
         */
        class PADDD_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDD_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "paddd".
         */
        class PADDD_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PADDD_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Unknown::unknown(([], {}))

// Inst::UD2([],{})

// FailUnimpl::twoByteOps(([], {}))

// Inst::PSHUFB((['Vo', 'Wo'], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pshufb".
         */
        class PSHUFB_XMM_XMM : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSHUFB_XMM_XMM(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pshufb".
         */
        class PSHUFB_XMM_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSHUFB_XMM_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "pshufb".
         */
        class PSHUFB_XMM_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            PSHUFB_XMM_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// WarnUnimpl::phaddw_Vdq_Wdq([],{})

// WarnUnimpl::phaddd_Vdq_Wdq([],{})

// WarnUnimpl::phaddsw_Vdq_Wdq([],{})

// WarnUnimpl::pmaddubsw_Vdq_Wdq([],{})

// WarnUnimpl::phsubw_Vdq_Wdq([],{})

// WarnUnimpl::phsubd_Vdq_Wdq([],{})

// WarnUnimpl::phsubsw_Vdq_Wdq([],{})

// WarnUnimpl::psignb_Vdq_Wdq([],{})

// WarnUnimpl::psignw_Vdq_Wdq([],{})

// WarnUnimpl::psignd_Vdq_Wdq([],{})

// WarnUnimpl::pmulhrsw_Vdq_Wdq([],{})

// WarnUnimpl::pblendvb_Vdq_Wdq([],{})

// WarnUnimpl::blendvps_Vdq_Wdq([],{})

// WarnUnimpl::blendvpd_Vdq_Wdq([],{})

// WarnUnimpl::ptest_Vdq_Wdq([],{})

// WarnUnimpl::pabsb_Vdq_Wdq([],{})

// WarnUnimpl::pabsw_Vdq_Wdq([],{})

// WarnUnimpl::pabsd_Vdq_Wdq([],{})

// WarnUnimpl::pmovsxbw_Vdq_Udq_or_Mq([],{})

// WarnUnimpl::pmovsxbd_Vdq_Udq_or_Md([],{})

// WarnUnimpl::pmovsxbq_Vdq_Udq_or_Mw([],{})

// WarnUnimpl::pmovsxwd_Vdq_Udq_or_Mq([],{})

// WarnUnimpl::pmovsxwq_Vdq_Udq_or_Md([],{})

// WarnUnimpl::pmovsxdq_Vdq_Udq_or_Mq([],{})

// WarnUnimpl::pmuldq_Vdq_Wdq([],{})

// WarnUnimpl::pcmpeqq_Vdq_Wdq([],{})

// WarnUnimpl::movntdqa_Vdq_Mdq([],{})

// WarnUnimpl::packusdw_Vdq_Wdq([],{})

// WarnUnimpl::pmovzxbw_Vdq_Udq_or_Mq([],{})

// WarnUnimpl::pmovzxbd_Vdq_Udq_or_Md([],{})

// WarnUnimpl::pmovzxbq_Vdq_Udq_or_Mw([],{})

// WarnUnimpl::pmovzxwd_Vdq_Udq_or_Mq([],{})

// WarnUnimpl::pmovzxwq_Vdq_Udq_or_Md([],{})

// WarnUnimpl::pmovzxdq_Vdq_Udq_or_Mq([],{})

// WarnUnimpl::pcmpgtq_Vdq_Wdq([],{})

// WarnUnimpl::pminsb_Vdq_Wdq([],{})

// WarnUnimpl::pminsd_Vdq_Wdq([],{})

// WarnUnimpl::pminuw_Vdq_Wdq([],{})

// WarnUnimpl::pminud_Vdq_Wdq([],{})

// WarnUnimpl::pmaxsb_Vdq_Wdq([],{})

// WarnUnimpl::pmaxsd_Vdq_Wdq([],{})

// WarnUnimpl::pmaxuw_Vdq_Wdq([],{})

// WarnUnimpl::pmaxud_Vdq_Wdq([],{})

// WarnUnimpl::pmulld_Vdq_Wdq([],{})

// WarnUnimpl::phminposuw_Vdq_Wdq([],{})

// Inst::UD2(([], {}))

// WarnUnimpl::crc32_Gd_Eb([],{})

// WarnUnimpl::crc32_Gd_Ev([],{})

// Inst::UD2(([], {}))

// WarnUnimpl::pshufb_Pq_Qq([],{})

// WarnUnimpl::phaddw_Pq_Qq([],{})

// WarnUnimpl::phaddd_Pq_Qq([],{})

// WarnUnimpl::phaddsw_Pq_Qq([],{})

// WarnUnimpl::pmaddubsw_Pq_Qq([],{})

// WarnUnimpl::phsubw_Pq_Qq([],{})

// WarnUnimpl::phsubd_Pq_Qq([],{})

// WarnUnimpl::phsubsw_Pq_Qq([],{})

// WarnUnimpl::psignb_Pq_Qq([],{})

// WarnUnimpl::psignw_Pq_Qq([],{})

// WarnUnimpl::psignd_Pq_Qq([],{})

// WarnUnimpl::pmulhrsw_Pq_Qq([],{})

// WarnUnimpl::pabsb_Pq_Qq([],{})

// WarnUnimpl::pabsw_Pq_Qq([],{})

// WarnUnimpl::pabsd_Pq_Qq([],{})

// Inst::UD2(([], {}))

// WarnUnimpl::roundps_Vdq_Wdq_Ib([],{})

// WarnUnimpl::roundpd_Vdq_Wdq_Ib([],{})

// WarnUnimpl::roundss_Vss_Wss_Ib([],{})

// WarnUnimpl::roundsd_Vsd_Wsd_Ib([],{})

// WarnUnimpl::blendps_Vdq_Wdq_Ib([],{})

// WarnUnimpl::blendpd_Vdq_Wdq_Ib([],{})

// WarnUnimpl::pblendw_Vdq_Wdq_Ib([],{})

// WarnUnimpl::palignr_Vdq_Wdq_Ib([],{})

// WarnUnimpl::pextrb_Rd_or_Mb_Vdq_Ib([],{})

// Inst::PEXTRW((['Rd', 'Vdq', 'Ib'], {}))

// WarnUnimpl::pextrw_Mw_Vdq_Ib([],{})

// WarnUnimpl::pextrd_pextrq_Ed_or_Eq_Vdq_Ib([],{})

// WarnUnimpl::extractps_Ed_Vdq_Ib([],{})

// WarnUnimpl::pinsrb_Vdq_Rd_or_Rq_or_Mb_Ib([],{})

// WarnUnimpl::insertps_Vdq_Udq_or_Md_Ib([],{})

// WarnUnimpl::pinsrd_pinsrq_Vdq_Ed_or_Eq_Ib([],{})

// WarnUnimpl::dpps_Vdq_Wdq_Ib([],{})

// WarnUnimpl::dppd_Vdq_Wdq_Ib([],{})

// WarnUnimpl::pcmpistrm_Vdq_Wdq_Ib([],{})

// WarnUnimpl::pcmpistri_Vdq_Wdq_Ib([],{})

// Inst::UD2(([], {}))

// WarnUnimpl::palignr_Pq_Qq_Ib([],{})

// Inst::UD2(([], {}))

// Unknown::unknown(([], {}))

// Inst::UD2([],{})

// MultiInst::ADD_LOCKED((['OPCODE_OP_BOTTOM3', ['Gb'], ['Gv']], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "add".
         */
        class ADD_LOCKED_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADD_LOCKED_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "add".
         */
        class ADD_LOCKED_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADD_LOCKED_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// MultiInst::OR_LOCKED((['OPCODE_OP_BOTTOM3', ['Gb'], ['Gv']], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "or".
         */
        class OR_LOCKED_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            OR_LOCKED_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "or".
         */
        class OR_LOCKED_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            OR_LOCKED_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// MultiInst::ADC_LOCKED((['OPCODE_OP_BOTTOM3', ['Gb'], ['Gv']], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "adc".
         */
        class ADC_LOCKED_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADC_LOCKED_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "adc".
         */
        class ADC_LOCKED_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADC_LOCKED_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// MultiInst::SBB_LOCKED((['OPCODE_OP_BOTTOM3', ['Gb'], ['Gv']], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sbb".
         */
        class SBB_LOCKED_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SBB_LOCKED_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sbb".
         */
        class SBB_LOCKED_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SBB_LOCKED_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// MultiInst::AND_LOCKED((['OPCODE_OP_BOTTOM3', ['Gb'], ['Gv']], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "and".
         */
        class AND_LOCKED_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            AND_LOCKED_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "and".
         */
        class AND_LOCKED_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            AND_LOCKED_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// MultiInst::SUB_LOCKED((['OPCODE_OP_BOTTOM3', ['Gb'], ['Gv']], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sub".
         */
        class SUB_LOCKED_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUB_LOCKED_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sub".
         */
        class SUB_LOCKED_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUB_LOCKED_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// MultiInst::XOR_LOCKED((['OPCODE_OP_BOTTOM3', ['Gb'], ['Gv']], {}))

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xor".
         */
        class XOR_LOCKED_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XOR_LOCKED_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xor".
         */
        class XOR_LOCKED_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XOR_LOCKED_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::ADD_LOCKED(['Mb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "add".
         */
        class ADD_LOCKED_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADD_LOCKED_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "add".
         */
        class ADD_LOCKED_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADD_LOCKED_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::OR_LOCKED(['Mb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "or".
         */
        class OR_LOCKED_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            OR_LOCKED_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "or".
         */
        class OR_LOCKED_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            OR_LOCKED_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::ADC_LOCKED(['Mb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "adc".
         */
        class ADC_LOCKED_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADC_LOCKED_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "adc".
         */
        class ADC_LOCKED_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            ADC_LOCKED_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SBB_LOCKED(['Mb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sbb".
         */
        class SBB_LOCKED_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SBB_LOCKED_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sbb".
         */
        class SBB_LOCKED_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SBB_LOCKED_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::AND_LOCKED(['Mb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "and".
         */
        class AND_LOCKED_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            AND_LOCKED_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "and".
         */
        class AND_LOCKED_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            AND_LOCKED_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::SUB_LOCKED(['Mb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sub".
         */
        class SUB_LOCKED_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUB_LOCKED_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "sub".
         */
        class SUB_LOCKED_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            SUB_LOCKED_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::XOR_LOCKED(['Mb', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xor".
         */
        class XOR_LOCKED_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XOR_LOCKED_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xor".
         */
        class XOR_LOCKED_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XOR_LOCKED_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::ADD_LOCKED(['Mv', 'Iz'],{})

// Inst::OR_LOCKED(['Mv', 'Iz'],{})

// Inst::ADC_LOCKED(['Mv', 'Iz'],{})

// Inst::SBB_LOCKED(['Mv', 'Iz'],{})

// Inst::AND_LOCKED(['Mv', 'Iz'],{})

// Inst::SUB_LOCKED(['Mv', 'Iz'],{})

// Inst::XOR_LOCKED(['Mv', 'Iz'],{})

// Unknown::unknown(([], {}))

// Inst::UD2([],{})

// Inst::ADD_LOCKED(['Mb', 'Ib'],{})

// Inst::OR_LOCKED(['Mb', 'Ib'],{})

// Inst::ADC_LOCKED(['Mb', 'Ib'],{})

// Inst::SBB_LOCKED(['Mb', 'Ib'],{})

// Inst::AND_LOCKED(['Mb', 'Ib'],{})

// Inst::SUB_LOCKED(['Mb', 'Ib'],{})

// Inst::XOR_LOCKED(['Mb', 'Ib'],{})

// Unknown::unknown(([], {}))

// Inst::ADD_LOCKED(['Mv', 'Ib'],{})

// Inst::OR_LOCKED(['Mv', 'Ib'],{})

// Inst::ADC_LOCKED(['Mv', 'Ib'],{})

// Inst::SBB_LOCKED(['Mv', 'Ib'],{})

// Inst::AND_LOCKED(['Mv', 'Ib'],{})

// Inst::SUB_LOCKED(['Mv', 'Ib'],{})

// Inst::XOR_LOCKED(['Mv', 'Ib'],{})

// Unknown::unknown(([], {}))

// Inst::XCHG_LOCKED(['Mb', 'Gb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xchg".
         */
        class XCHG_LOCKED_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XCHG_LOCKED_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xchg".
         */
        class XCHG_LOCKED_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XCHG_LOCKED_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::XCHG_LOCKED(['Mv', 'Gv'],{})

// Unknown::unknown(([], {}))

// Inst::NOT_LOCKED(['Mb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "not".
         */
        class NOT_LOCKED_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            NOT_LOCKED_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "not".
         */
        class NOT_LOCKED_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            NOT_LOCKED_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::NEG_LOCKED(['Mb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "neg".
         */
        class NEG_LOCKED_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            NEG_LOCKED_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "neg".
         */
        class NEG_LOCKED_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            NEG_LOCKED_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::NOT_LOCKED(['Mv'],{})

// Inst::NEG_LOCKED(['Mv'],{})

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Inst::INC_LOCKED(['Mb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "inc".
         */
        class INC_LOCKED_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            INC_LOCKED_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "inc".
         */
        class INC_LOCKED_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            INC_LOCKED_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::DEC_LOCKED(['Mb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "dec".
         */
        class DEC_LOCKED_M : public Macroop
        {
          private:
            
          public:
            // Constructor.
            DEC_LOCKED_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "dec".
         */
        class DEC_LOCKED_P : public Macroop
        {
          private:
            
          public:
            // Constructor.
            DEC_LOCKED_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::UD2([],{})

// Inst::INC_LOCKED(['Mv'],{})

// Inst::DEC_LOCKED(['Mv'],{})

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// WarnUnimpl::mov_Rd_CR8D(([], {}))

// WarnUnimpl::mov_CR8D_Rd(([], {}))

// Unknown::unknown(([], {}))

// Inst::BTS_LOCKED(['Mv', 'Gv'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bts".
         */
        class BTS_LOCKED_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTS_LOCKED_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bts".
         */
        class BTS_LOCKED_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTS_LOCKED_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::CMPXCHG_LOCKED(['Mb', 'Gb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmpxchg".
         */
        class CMPXCHG_LOCKED_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMPXCHG_LOCKED_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmpxchg".
         */
        class CMPXCHG_LOCKED_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            CMPXCHG_LOCKED_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::CMPXCHG_LOCKED(['Mv', 'Gv'],{})

// Inst::BTR_LOCKED(['Mv', 'Gv'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "btr".
         */
        class BTR_LOCKED_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTR_LOCKED_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "btr".
         */
        class BTR_LOCKED_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTR_LOCKED_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::BTS_LOCKED(['Mv', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bts".
         */
        class BTS_LOCKED_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTS_LOCKED_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "bts".
         */
        class BTS_LOCKED_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTS_LOCKED_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::BTR_LOCKED(['Mv', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "btr".
         */
        class BTR_LOCKED_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTR_LOCKED_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "btr".
         */
        class BTR_LOCKED_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTR_LOCKED_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::BTC_LOCKED(['Mv', 'Ib'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "btc".
         */
        class BTC_LOCKED_M_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTC_LOCKED_M_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "btc".
         */
        class BTC_LOCKED_P_I : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTC_LOCKED_P_I(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::BTC_LOCKED(['Mv', 'Gv'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "btc".
         */
        class BTC_LOCKED_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTC_LOCKED_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "btc".
         */
        class BTC_LOCKED_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            BTC_LOCKED_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Inst::XADD_LOCKED(['Mb', 'Gb'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xadd".
         */
        class XADD_LOCKED_M_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XADD_LOCKED_M_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "xadd".
         */
        class XADD_LOCKED_P_R : public Macroop
        {
          private:
            
          public:
            // Constructor.
            XADD_LOCKED_P_R(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Inst::XADD_LOCKED(['Mv', 'Gv'],{})

// Inst::CMPXCHG8B_LOCKED(['Mdp'],{})

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmpxchg8b".
         */
        class CMPXCHG8B_LOCKED_M : public Macroop
        {
          private:
            const static uint64_t label_doneComparing = 6;

          public:
            // Constructor.
            CMPXCHG8B_LOCKED_M(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

    GEM5_DEPRECATED_NAMESPACE(X86Macroop, x86_macroop);
    namespace x86_macroop
    {
        /**
         * Static instruction class for "cmpxchg8b".
         */
        class CMPXCHG8B_LOCKED_P : public Macroop
        {
          private:
            const static uint64_t label_doneComparing = 7;

          public:
            // Constructor.
            CMPXCHG8B_LOCKED_P(ExtMachInst machInst, X86ISA::EmulEnv _env);

            std::string generateDisassembly(
                    Addr pc, const loader::SymbolTable *symtab) const override;
        };
    }

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))

// Unknown::unknown(([], {}))
